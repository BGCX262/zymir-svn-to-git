//CHECK
//不要删除上一句注释，该注释为检查该文件是否已被自动增加异常处理
unit ObjBase;

interface
uses
  Windows, Classes, SysUtils, Forms, StrUtils, Math,DateUtils, SDK, Grobal2, Envir,
  ItmUnit, MD5Unit, FindMapPath, CenterShare, Messages, INIFIles, Shellapi;
                                          
type
  TClientAction = (cHit, cMagHit, cRun, cWalk, cDigUp, cTurn);
  //  TSayMsgType = (s_NoneMsg,s_GroupMsg,s_GuildMsg,s_SystemMsg,s_NoticeMsg);
  //  TGender = (gMan,gWoMan);
  //  TJob    = (jWarr,jWizard,jTaos);

const
  gMan = 0;
  gWoMan = 1;

type
{$REGION '数据定义'}
  TBaseObject = class;

  pTStartPoint = ^TStartPoint;
  TStartPoint = record
    sMapName: string[CurMapNameLen];
    nX: Integer;
    nY: Integer;
    btJob: Byte;
    Envir: TEnvirnoment;
    dwWhisperTick: LongWord;
    nSize: Byte;
    nClass: Byte;
    boPKZone: Boolean;
    boPKFire: Boolean;
    boCloseSay: Boolean;
  end;

  pTSendMessage = ^TSendMessage;
  TSendMessage = record
    wIdent: word;
    wParam: word;
    nParam1: integer;
    nParam2: integer;
    nParam3: integer;
    dwDeliveryTime: dword;
    BaseObject: TBaseObject;
    boLateDelivery: Boolean;
    Buff: pointer;
  end;

  pTVisibleBaseObject = ^TVisibleBaseObject;
  TVisibleBaseObject = record
    BaseObject: TBaseObject;
    nVisibleFlag: Integer;
  end;

  pTVisibleMapItem = ^TVisibleMapItem;
  TVisibleMapItem = record
    nX, nY: integer;
    MapItem: pTMapItem;
    sName: string;
    wLooks: word;
    nVisibleFlag: integer;
  end;

  TTempAddAbil = record
    nAddWord: Word;
    nAddTick: LongWord;
  end;
{$ENDREGION}

 {$REGION '基础类定义'}
  TBaseObject = class
    m_sMapName: string[MapNameLen]; //0x04
    m_sCharName: string[ActorNameLen]; //0x15
    // m_sAccounts               :String[AccountNameLen];
    m_nCurrX: Integer; //0x24  人物所在座标X(4字节)
    m_nCurrY: Integer; //0x28  人物所在座标Y(4字节)
    m_btDirection: Byte; //0x2C  人物所在方向(1字节)
    m_btGender: Byte; //0x2D  人物的性别(1字节)
    m_btHair: Byte; //0x2E  人物的头发(1字节)
    m_btJob: Byte; //0x2F  人物的职业(1字节)
    m_Helmet: Byte;
    m_nGold: Integer; //0x30  人物金币数(4字节)
    m_Abil: TAbility; //TAbility;   //0x34 -> 0x5B 正常能力值
    m_nCharStatus: Integer; //0x5C
    m_sHomeMap: string[MapNameLen]; //0x78  //回城地图
    m_nHomeX: Integer; //0x8C  //回城座标X
    m_nHomeY: Integer; //0x90  //回城座标Y
    m_sDieMap: string[MapNameLen]; //0x78  //回城地图
    m_nDieX: Integer; //0x8C  //回城座标X
    m_nDieY: Integer; //0x90  //回城座标Y
    //      bo942                    :Boolean;    //0x94
    m_boOnHorse: Boolean; //0x95
    m_btHorseType: Byte;
    m_btDressEffType: Byte;
    {     n982                     :Integer;    //0x98
         n9C2                     :Integer;    //0x9C
         nA02                     :Integer;    //0xA0
         nA42                     :Integer;    //0xA4
         nA82                     :Integer;    //0xA8  }
    m_nPkPoint: Integer; //0xAC  人物的PK值(4字节)
    m_boAllowGroup: Boolean; //0xB0  允许组队
    m_boAllowAddGroup: Boolean;
    m_boAllowGuild: Boolean; //0xB1  允许加入行会
    btB22: Byte; //0xB2
    //      btB32                    :Byte;       //0xB3
    m_nIncHealth: Integer; //0x0B4
    m_nIncSpell: Integer; //0x0B8
    m_nIncHealing: Integer; //0x0BC
    m_nIncHPStoneTime: LongWord;
    m_nIncMPStoneTime: LongWord;
    m_nFightZoneDieCount: Integer;
    //0x0C0  //在行会占争地图中死亡次数
    m_boFlagCheck: Boolean;
    m_dwMagicDeDingTick: LongWord; //地钉间隔时间
    m_MissIonEx: Boolean;
    m_btDiploidRate3: Byte; //爆击机率
    m_btDiploidRate: Byte; //保存爆击机率
    m_boDiploid: Boolean;
    m_MeteorRainTime: LongWord; //流星火雨使用时间间隔
    //nC4                     :Integer;
    //btC8                    :Byte;     //0xC8
    m_nSuitMonExpRate: Integer;
    //      btC92                    :Byte;     //0xC9
    m_BonusAbil: TNakedAbility; //0x0CA TNakedAbility
    //    m_CurBonusAbil            :TNakedAbility; //0x0DE
    m_nBonusPoint: Integer; //0x0F4
    m_nHungerStatus: Integer; //0x0F8
    m_boAllowGuildReCall: Boolean; //0xFC
    m_dwClientTick: LongWord;
    m_dwClientTickEx: LongWord;
    //      btFC               :Byte;
    m_dBodyLuck: Double; //0x100
    m_nBodyLuckLevel: Integer; //0x108
    m_wGroupRcallTime: Word; //0x10C
    m_boAllowGroupReCall: Boolean; //0x10E
    //m_QuestUnitOpen           :TQuestUnit;    //0x10F
    //m_QuestUnit               :TQuestUnit;    //0x11C
    m_QuestFlag: TQuestFlag; //0x128 129
    m_nCharStatusEx: Integer;
    m_dwFightExp: LongWord; //0x194   //怪物经验值
    m_WAbil: TAbility; //0x198 附加了属性的人物能力值
    m_AddAbil: TAddAbility; //0x1C0
    m_TempAbil: array[0..9] of TTempAddAbil;
    m_nViewRange: Integer; //0x1E4   //可视范围大小
    //m_nViewRange2             :Integer;
    m_wStatusTimeArr: TStatusTime; //0x60
    m_dwStatusArrTick: array[0..MAX_STATUS_ATTRIBUTE - 1] of LongWord; //0x1E8
    m_wStatusArrValue: array[0..5] of Word; //0x218 //临时属性
    m_dwStatusArrTimeOutTick: array[0..5] of LongWord; //临时属性时间限制

    // :Tarry220;           //0x220
    m_wAppr: Word; //0x238
    m_btRaceServer: Byte; //0x23A   //角色类型
    m_btRaceImg: Byte; //0x23B   //角色外形
    m_btHitPoint: Byte; //0x23C   人物攻击准确度(Byte)
    m_nHitPlus: ShortInt; //0x23D
    m_nHitDouble: ShortInt; //0x23E
    m_dwGroupRcallTick: LongWord; //0x240  记忆使用间隔(Dword)
    m_boRecallSuite: Boolean; //0x244  记忆全套
    //      bo245                   :Boolean;      //0x245
    m_boTestGa: Boolean; //0x246  //是否输入Testga 命令
    m_boGsa: Boolean; //0x247  //是否输入gsa 命令
    m_nHealthRecover: ShortInt; //0x248
    m_nSpellRecover: ShortInt; //0x249
    m_btAntiPoison: Byte; //0x24A
    m_nPoisonRecover: ShortInt; //0x24B
    m_nAntiMagic: ShortInt; //0x24C
    m_nLuck: Integer; //0x250  人物的幸运值Luck
    m_nPerHealth: Integer; //0x254
    m_nPerHealing: Integer; //0x258
    m_nPerSpell: Integer; //0x25C
    m_dwIncHealthSpellTick: LongWord; //0x260
    m_btGreenPoisoningPoint: Byte; //0x264  中绿毒降HP点数
    m_nGoldMax: Integer; //0x268  人物身上最多可带金币数(Dword)
    m_btSpeedPoint: Byte; //0x26C  人物敏捷度(Byte)
    m_btPermission: Byte; //0x26D  人物权限等级
    m_nHitSpeed: ShortInt; //0x26E  //1-18 更改数据类型
    m_btLifeAttrib: Byte; //0x26F
    m_btCoolEye: Byte; //0x270
    m_GroupOwner: TBaseObject; //0x274
    m_GroupMembers: TStringList; //0x278  组成员
    m_boHearWhisper: Boolean; //0x27C  允许私聊
    m_boBanShout: Boolean; //0x27D  允许群聊
    m_boBanGuildChat: Boolean; //0x27E  拒绝行会聊天
    m_boAllowDeal: Boolean; //0x27F  是不允许交易
    m_BlockWhisperList: TStringList; //0x280  禁止私聊人员列表
    m_dwShoutMsgTick: LongWord; //0x284
    m_Master2: TBaseObject; //0x288  是否被召唤(主人)
    m_dwMasterRoyaltyTick: LongWord; //0x28C  怪物叛变时间
    m_dwMasterTick: LongWord; //0x290
    n2942: Integer; //0x294  杀怪计数
    m_btSlaveExpLevel: Byte; //0x298  宝宝等级 1-7
    m_btSlaveMakeLevel: Byte; //0x299  召唤等级
    m_SlaveList: TList; //0x29C  下属列表
    //      bt2A02                   :Byte;         //0x2A0
    m_boSlaveRelax: Boolean; //0x2A0  宝宝攻击状态(休息/攻击)(Byte)
    m_btAttatckMode: Byte; //0x2A1  下属攻击状态
    m_btNameColor: Byte; //0x2A2  人物名字的颜色(Byte)
    m_nIconIdx: array[0..4] of Word;
    m_btChangeNameColor: Byte;
    m_AllMaster: TBaseObject; //最高主人
    m_Clone: TBaseObject; //分身
    m_CloneHum: TBaseObject; //分身主人
    m_CallCloneTick: LongWord; //分身的时间

    m_nSoftVersionDateEx: Integer;
    m_nSoftVersionDate: Integer;

    m_DrinkCount: array[0..5] of Byte;
    m_DrinkNpcCount: Byte;
    m_DrinkSelfCount: Byte;

    m_HeroName1: string[ActorNameLen];
    m_HeroLevel1: Word;
    m_HeroJob1: Byte;
    m_HeroGender1: Byte;
    m_HeroName2: string[ActorNameLen];
    m_HeroLevel2: Word;
    m_HeroJob2: Byte;
    m_HeroGender2: Byte;
    m_HeroClass: Boolean;

    m_boHero: Boolean; //是否英雄
    m_CreateHeroName: string[ActorNameLen]; //待创建英雄名称
    m_HeroName: string[ActorNameLen]; //英雄名称
    m_Hero: TBaseObject; // 英雄
    m_HeroHuman: TBaseObject; //英雄主人
    m_HeroLocked: TBaseObject; //英雄锁定目标
    m_HeroboLocked: Boolean; //英雄是否锁定目标
    m_HeroCallTime: LongWord; //上次召唤英雄时间
    m_HeroProtect: Boolean; //英雄守护
    m_HeroProtectX: Integer; //守护X
    m_HeroProtectY: Integer; //守护Y
    m_HeroBagCount: Byte; //英雄背包大小
    m_HeroMagic: array[0..99] of pTUserMagic; //英雄所学技能列表
    m_HeroJointAttack: pTUserMagic; //是否学习英雄技能
    m_HeroFireTick: LongWord; //烈火间隔
    m_HeroLongSword: LongWord; //开天斩间隔
    m_HeroEatItemsTime: LongWord; //英雄使用药品间隔
    m_HeroPickItem: pTVisibleMapItem; //当前英雄所捡物品指针
    m_HeroPickItemMap: TEnvirnoment;
    m_HeroAutoDong: Boolean; //法师自动魔法盾
    m_HeroCallMob: Byte;
    m_HeroDanderCount: Integer;
    m_HeroAutoDanderTick: Longword;
    m_HeroDanderOk: Boolean;
    m_HeroboDanderDel: Boolean;
    m_HeroJointAttackOk: Boolean;
    m_HeroJointAttackTime: LongWord;
    m_OldShowName: string;
    m_NewShowName: string;

    m_HeroAmu51Porc: Pointer;
    m_HeroAmu55Porc: Pointer;
    m_HeroAmu11Porc: Pointer;
    m_HeroAmu21Porc: Pointer;
    m_HeroAttackAmuPorc: Pointer;
    m_HeroAmuHintTime: LongWord;
    //   m_HeroPickItemX           :Integer;
   //    m_HeroPickItemY           :Integer;
    m_boRun: Boolean;
    m_boAutoGhost: Boolean;
    m_nLight: Integer; //0x2A4  亮度
    m_boGuildWarArea: Boolean; //0x2A8  行会占争范围
    m_Castle: TObject; //0x2AC //所属城堡
    bo2B02: Boolean; //0x2B0
    m_dw2B4Tick: LongWord; //0x2B4
    m_boSuperMan: Boolean; //0x2B8  无敌模式
    bo2B92: Boolean; //0x2B9
    bo2BA2: Boolean; //0x2BA
    m_boAnimal: Boolean; //0x2BB
    m_boNoItem: Boolean; //0x2BC
    m_boFixedHideMode: Boolean; //0x2BD
    m_boStickMode: Boolean; //0x2BE
    bo2BF2: Boolean; //0x2BF
    m_boNoAttackMode: Boolean; //0x2C0
    m_boNoTame: Boolean; //0x2C1
    m_boSkeleton: Boolean; //0x2C2
    m_nMeatQuality: Integer; //0x2C4
    m_nBodyLeathery: Integer; //0x2C8
    m_boHolySeize: Boolean; //0x2CC
    m_dwHolySeizeTick: LongWord; //0x2D0
    m_dwHolySeizeInterval: LongWord; //0x2D4
    m_boCrazyMode: Boolean; //0x2D8
    m_dwCrazyModeTick: LongWord; //0x2DC
    m_dwCrazyModeInterval: LongWord; //0x2E0
    m_boShowHP: Boolean; //0x2E4
    //      nC2E6                   :Integer;      //0x2E6
    m_dwShowHPTick: LongWord; //0x2E8  心灵启示检查时间(Dword)
    m_dwShowHPInterval: LongWord; //0x2EC  心灵启示有效时长(Dword)
    bo2F0: Boolean; //0x2F0
    m_dwDupObjTick: LongWord; //0x2F4
    m_PEnvir: TEnvirnoment; //0x2F8
    m_boGhost: Boolean; //0x2FC
    m_dwGhostTick: LongWord; //0x300
    m_boDeath: Boolean; //0x304
    m_dwDeathTick: LongWord; //0x308
    m_dwDeathTickEx: LongWord; //0x308
    m_btMonsterWeapon: Byte; //0x30C 怪物所拿的武器
    m_dwStruckTick: LongWord; //0x310
    m_boWantRefMsg: Boolean; //0x314
    m_boAddtoMapSuccess: Boolean; //0x315
    m_bo316: Boolean; //0x316
    m_boDealing: Boolean; //0x317  //正在交易中
    m_DealLastTick: LongWord; //0x318 交易最后操作时间
    m_DealCreat: TBaseObject; //0x31C
    m_MyGuild: TOBject; //0x320
    m_nGuildRankNo: Integer; //0x324
    m_sGuildRankName: string; //0x328
    m_sScriptLable: string; //0x32C
    m_btAttackSkillCount: Byte; //0x330
    m_btAttackSkillPointCount: Byte; //0x334
    m_boMission: Boolean; //0x338
    m_nMissionX: Integer; //0x33C
    m_nMissionY: Integer; //0x340
    m_boHideMode: Boolean; //0x344  隐身戒指(Byte)
    m_boStoneMode: Boolean; //0x345
    m_boCoolEye: Boolean; //0x346  //是否可以看到隐身人物
    m_boUserUnLockDurg: Boolean; //0x347  //是否用了神水
    m_boTransparent: Boolean; //0x348  //魔法隐身了
    m_boAdminMode: Boolean; //0x349  管理模式(Byte)
    m_boObMode: Boolean; //0x34A  隐身模式(Byte)
    m_boTeleport: Boolean; //0x34B  传送戒指(Byte)
    m_boTeleport2: Boolean; // 传送符
    m_boParalysis: Boolean; //0x34C  麻痹戒指(Byte)
    m_boUnParalysis: Boolean;
    m_boRevival: Boolean; //0x34D  复活戒指(Byte)
    m_boRevivalnotItem: Boolean; //复活不要减持久
    m_boUnRevival: Boolean; //防复活
    m_dwRevivalTick: LongWord; //0x350  复活戒指使用间隔计数(Dword)
    m_boFlameRing: Boolean; //0x354  火焰戒指(Byte)
    m_boRecoveryRing: Boolean; //0x355  治愈戒指(Byte)
    m_boAngryRing: Boolean; //0x356  未知戒指(Byte)
    m_boMagicShield: Boolean; //0x357  护身戒指(Byte)
    m_boUnMagicShield: Boolean; //防护身
    m_boMuscleRing: Boolean; //0x358  活力戒指(Byte)
    m_boFastTrain: Boolean; //0x359  技巧项链(Byte)
    m_boProbeNecklace: Boolean; //0x35A  探测项链(Byte)
    m_boGuildMove: Boolean; //行会传送
    m_boSupermanItem: Boolean;
    m_bopirit: Boolean; //祈祷

    m_btThrough: Byte; //穿怪模式
    m_dwThroughTick: LongWord;

    m_boNoDropItem: Boolean;
    m_boNoDropUseItem: Boolean;
    m_boCloneNoDropItem: Boolean;
    m_boExpItem: Boolean;
    m_boPowerItem: Boolean;

    m_rExpItem: Real;
    m_rPowerItem: Real;
    m_dwPKDieLostExp: LongWord; //PK 死亡掉经验，不够经验就掉等级
    m_nPKDieLostLevel: Integer; //PK 死亡掉等级

    m_boAbilSeeHealGauge: Boolean; //0x35B  //心灵启示
    m_boAbilMagBubbleDefence: Boolean; //0x35C  //魔法盾
    m_btMagBubbleDefenceLevel: Byte; //0x35D
    m_dwSearchTime: LongWord; //0x360
    m_dwSearchTick: LongWord; //0x364
    m_dwRunTick: LongWord; //0x368
    m_nRunTime: Integer; //0x36C
    m_nHealthTick: Integer;
    //0x370    //特别指定为 此类型  此处用到 004C7CF8
    m_nSpellTick: Integer; //0x374
    m_TargetCret: TBaseObject; //0x378   //攻击对方指针
    m_dwTargetFocusTick: LongWord; //0x37C
    m_LastHiter: TBaseObject;
    //0x380  人物被对方杀害时对方指针(Dword)
    m_LastHiterTick: LongWord; //0x384
    m_ExpHitter: TBaseObject; //0x388
    m_ExpHitterTick: LongWord; //0x38C
    m_dwTeleportTick: LongWord; //0x390  传送戒指使用间隔(Dword)
    m_dwProbeTick: LongWord; //0x394  探测项链使用间隔(Dword)
    m_dwSkill82Tick:LongWord;//乾坤大挪移使用间隔(Dword)
    m_dwMapMoveTick: LongWord; //0x398
    m_boPKFlag: Boolean; //0x39C  人物攻击变色标志(Byte)
    m_dwPKTick: LongWord; //0x3A0  人物攻击变色时间长度(Dword)
    m_nMoXieSuite: Integer; //0x3A4  魔血一套(Dword)
    m_nHongMoSuite: Integer; //0x3A8 虹魔一套(Dword)
    m_n3AC: Integer; //0x3AC
    m_dwPoisoningTick: LongWord; //0x3B8 中毒处理间隔时间(Dword)
    m_dwDecPkPointTick: LongWord; //0x3BC  减PK值时间(Dword)
    m_DecLightItemDrugTick: LongWord; //0x3C0
    m_dwVerifyTick: LongWord; //0x3C4
    m_dwCheckRoyaltyTick: LongWord; //0x3C8
    m_dwDecHungerPointTick: LongWord; //0x3CC
    m_dwHPMPTick: LongWord; //0x3D0
    m_VisibleActors: TList; //0x408
    m_VisibleHumanList: TList; //0x3D8
    m_VisibleItems: TList; //0x3DC
    m_VisibleEvents: TList; //0x3E0
    m_SendRefMsgTick: LongWord; //0x3E4
    m_boInFreePKArea: Boolean; //0x3E8  是否在开行会战(Byte)
    //      LIst_3EC                :TList;      //0x3EC
    //      dwTick3F02               :LongWord;   //0x3F0
    //      dwTick3F42               :LongWord;   //0x3F4
    m_dwHitTick: LongWord; //0x3F8
    m_dwWalkTick: LongWord; //0x3FC
    m_dwSearchEnemyTick: LongWord; //0x400
    m_dwHeroPickUpTick: LongWord;
    m_boNameColorChanged: Boolean; //0x404
    m_boIsVisibleActive: Boolean; //是否在可视范围内有人物,及宝宝
    m_nProcessRunCount: ShortInt;
    m_nProcessSearchCount: ShortInt;
    //    m_NotCheckAmulet          :Boolean;
    m_CloneAmuletIdx: Boolean;

    m_MsgList: TList; //0x3D4
    m_ItemList: TList; //0x40C  人物背包(Dword)数量
    //m_CustomDataList          :TList;
    m_DealItemList: TList; //0x410
    m_ShopItemList: TList;
    m_nDealGolds: Integer; //0x414  交易的金币数量(Dword)
    m_boDealOK: Boolean; //0x418  确认交易标志(Byte
    m_MagicList: TList; //0x41C  技能表
    m_UseItems: THumanUseItems; //0x420  + D8 -> 4F8
    m_SayMsgList: TList;
    m_StorageItemList: TList; //0x4F8
    m_nWalkSpeed: Integer; //0x4FC
    m_nWalkStep: Integer; //0x500
    m_nWalkCount: Integer; //0x504
    m_dwWalkWait: LongWord; //0x508
    m_dwWalkWaitTick: LongWord; //0x50C
    m_boWalkWaitLocked: Boolean; //0x510
    m_nNextHitTime: Integer; //0x514
    m_MagicOneSwordSkill: pTUserMagic; //0x518
    m_MagicPowerHitSkill: pTUserMagic; //0x51C
    m_MagicErgumSkill: pTUserMagic; //0x520 刺杀剑法
    m_MagicBanwolSkill: pTUserMagic; //0x524 半月弯刀
    m_MagicRedBanwolSkill: pTUserMagic;
    m_MagicFireSwordSkill: pTUserMagic; //0x528
    m_MagicLongFireSwordSkill: pTUserMagic;
    m_MagicCrsSkill: pTUserMagic; //0x528
    m_Magic41Skill: pTUserMagic; //0x528
    m_MagicTwnHitSkill: pTUserMagic; //0x528
    m_MagicLongSwordSkill: pTUserMagic; //0x528
    m_MagicShieldSkill: pTUserMagic; //0x528
    m_boPowerHit: Boolean; //0x52C
    m_boUseThrusting: Boolean; //0x52D
    m_boUseHalfMoon: Boolean; //0x52E
    m_boRedUseHalfMoon: Boolean;
    m_boFireHitSkill: Boolean; //0x52F
    m_boLongFireHitSkill: Boolean;
    m_boCrsHitkill: Boolean;
    m_bo41kill: Boolean;
    m_boTwinHitSkill: Boolean;
    m_boTwinHitSkill2: Boolean;
    m_boLongSwordSkill: Boolean;
    m_boLongSwordSkillCls: Boolean;
    m_bo43kill: Boolean;
    m_dwLatestFireHitTick: LongWord; //0x530
    m_dwLatestLongFireHitTick: LongWord;
    m_dwDoMotaeboTick: LongWord; //0x534
    m_dwLatestTwinHitTick: LongWord;
    m_dwLatestLongSwordTick: LongWord;
    m_boDenyRefStatus: Boolean; //是否刷新在地图上信息；
    m_boAddToMaped: Boolean; //是否增加地图计数
    m_boDelFormMaped: Boolean; //是否从地图中删除计数
    m_boAutoChangeColor: Boolean;
    m_dwAutoChangeColorTick: LongWord;
    m_nAutoChangeIdx: Integer;

    m_boFixColor: Boolean; //固定颜色
    m_nFixColorIdx: Integer;
    m_nFixStatus: Integer;
    m_boFastParalysis: Boolean; //快速麻痹，受攻击后麻痹立即消失

    m_boSmashSet: Boolean;
    m_boHwanDevilSet: Boolean;
    m_boPuritySet: Boolean;
    m_boMundaneSet: Boolean;
    m_boNokChiSet: Boolean;
    m_boTaoBuSet: Boolean;
    m_boFiveStringSet: Boolean;

    m_boNastyMode: Boolean;
    m_boShop: Boolean;
    m_sShopMsg: string[16];
    m_boOpenShield: Boolean; //护体神盾
    m_dwOpenShieldTick: LongWord;
    m_dwOpenShieldTime: LongWord;
    m_dwOpenShieldShowTime: LongWord;


    m_MagicSkill83: pTUserMagic; //0x528
    m_MagicSkill84: pTUserMagic; //0x528

    m_skill84Abil:word;//酒气护体附加能力值
    m_MedicineAbil:array[0..5] of Word; //药力附加能力值
    m_MedicineAbilTemp:array[0..4] of Word;//药酒临时附加值
    m_MedicineAbilArrTimeOutTick: array[0..4] of LongWord; //药力临时属性时间限制
    m_RUNKarray:array[0..1] of Byte; //酒醉了减魔法躲避 体力恢复
    m_boRUNK:Boolean;//是否醉酒过

    m_WineRec:TWineRec;//酒量值相关

    m_MedicineRec:TMedicineRec;//药力值相在

    m_SKILL83Rec:TSKILL83Rec; //先天元力相关

    m_SKILL84Rec:TSKILL84Rec;//酒气护体相关

    m_boskill84open:Boolean;//是否打开酒气护体
    m_dwskill84Time:LongWord;//使用酒气护体时间值
    m_dwdecDrunkScale:LongWord;//醉酒度时间值
    m_dwnDRUNKTick:LongWord;//显示醉酒状间隔
    m_dtAlcohoTime:TDateTime;//饮普通酒时间
    m_dtMedicineAlcohoTime:TDateTime;//饮药酒时间
    m_bLiquorProgress:Byte;//酒量提升进度值
    m_dwLiquorProgressTime:LongWord;//酒量提升时间
    m_dwSpeedupAlcoholTick:LongWord;//临昨属性酒量提升速度

    m_boISONMAKEWINE:Byte;//是否在酿酒 0没有1普通2药酒
    m_boNPCMOVE:Boolean;//是否在执行NPC移动操作
    m_dtGetGuildFountain:TDateTime; //领取行会泉水时间
    m_dtGetCastleFountain:TDateTime; //领沙城泉水时间
    m_dtMakeWineTime:TDateTime;//开始酿酒的时间
    m_WineItem:TUserItem;//酿造的酒
    m_WineItems:array[0..6] of TUserItem;//酿酒的物品
    m_bomapFOUNTAIN:Boolean;//是否站在泉水上
    m_GetfountainTick:LongWord;//站在泉水上获取的间隔
    FOUNTAINEvent:TObject;//泉水事件地图指针
  private
    function GetLevelExp(nLevel: Integer): LongWord;
    function GetMedicineLevelExp(nLevel: Integer): LongWord;
    function Getskill84LevelExp(nLevel: Integer): LongWord;
    procedure GetSkill83LevelAbil;
    function InSafeArea: Boolean;
    procedure UpdateVisibleGay(BaseObject: TBaseObject); virtual;
    function Walk(nIdent: Integer): Boolean;
    function AddToMap(): Boolean;
    procedure UseLamp();
    procedure CheckPKStatus();
    procedure UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);
    procedure UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
    function RecalcBagWeight(): Integer;

    procedure DecPKPoint(nPoint: Integer);

    function GetNamecolor: Byte;
    procedure SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord);
    procedure LeaveGroup();
    procedure DelMember(BaseObject: TBaseObject);
    procedure HearMsg(sMsg: string);

    procedure DoDamageWeapon(nWeaponDamage: Integer);
    function GetFeatureEx: Word;

  public
    constructor Create(); virtual;
    destructor Destroy; override;

    procedure NpcGotoLable(NormNpc: TBaseObject; sLabel: string; boMaster:
      Boolean);
    procedure RecalcHitSpeed();
    procedure DamageSpell(nSpellPoint: Integer);
    procedure AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word; nDir:
      Integer); virtual;
    function RunTo(btDir: Byte; boFlag: boolean; nDestX, nDestY: Integer):
      Boolean;
    function GetCharColor(BaseObject: TBaseObject): Byte;
    procedure SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word; nParam1,
      nParam2, nParam3: Integer; sMsg: string);
    procedure SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string);
    procedure SendDelayMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string; dwDelay: LongWord);
    procedure SendRefMsg(wIdent, wParam: Word; nParam1, nParam2, nParam3:
      Integer; sMsg: string);
    procedure SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string);
    procedure SendActionMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
      lParam1, lParam2, lParam3: Integer; sMsg: string);
    procedure SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY: Integer);
    procedure SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType: TMsgType);
    procedure SysColorMsg(sMsg: string; FColor, BColor: Byte);
    procedure SendGroupText(sMsg: string);
    procedure MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus:
      TMonStatus);
    function IsVisibleHuman(): Boolean;
    procedure RecalcLevelAbilitys;
    function PKLevel(): Integer;
    function InSafeZone(): Boolean; overload;
    function InSafeZone(Envir: TEnvirnoment; nX, nY: Integer): Boolean;
      overload;
    procedure OpenHolySeizeMode(dwInterval: LongWord);
    procedure BreakHolySeizeMode;
    procedure OpenCrazyMode(nTime: Integer);
    procedure BreakCrazyMode();
    procedure HealthSpellChanged();
    function _Attack(var wHitMode: Word; AttackTarget: TBaseObject): Boolean;
    function GetHitStruckDamage(Target: TBaseObject; nDamage: integer): Integer;
    procedure HasLevelUp(nLevel: Integer);
    procedure sub_4BC87C();
    procedure GoldChanged();
    procedure GameGoldChanged();
    procedure ClearBagItem();
    procedure ClearStorageItem();

    function GetGuildRelation(cert1: TBaseObject; cert2: TBaseObject): Integer;
    function IsGoodKilling(cert: TBaseObject): Boolean;
    procedure IncPkPoint(nPoint: Integer);
    procedure AddBodyLuck(dLuck: Double);
    procedure MakeWeaponUnlock();
    procedure ScatterGolds(GoldOfCreat: TBaseObject);
    function DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat,
      DropGoldCreat: TBaseObject): Boolean;
    function DropItemDown(UserItem: pTUserItem; nScatterRange: Integer;
      boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject; boHint: Boolean =
      True): Boolean;
    function DropItemDownEx(UserItem: pTUserItem; nScatterRange: Integer; Envir:
      TEnvirnoment; X, Y: Integer): Boolean;
    procedure DamageHealth(nDamage: Integer);
    function GetAttackPower(nBasePower, nPower: Integer): Integer;
    function CharPushed(nDir, nPushCount: Integer): Integer;
    function GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX: Integer; var
      nDY: Integer): Boolean;
    function GetBackDir(nDir: integer): Integer;
    function GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY: Integer; nRage:
      Integer; rList: TList): Boolean;
    function GetMapBaseObjectCount(tEnvir: TEnvirnoment; nX, nY: Integer; nRage:
      Integer): Integer;
    function MagPassThroughMagic(sx, sy, tx, ty, ndir, magpwr: integer;
      undeadattack: Boolean): integer;
    function MagPassThroughMagic2(sx, sy, tx, ty, ndir, magpwr: integer;
      undeadattack: Boolean): integer;
    procedure KickException;
    function GetMagStruckDamage(BaseObject: TBaseObject; nDamage: Integer):
      Integer;
    procedure DamageBubbleDefence(nInt: Integer);
    procedure BreakOpenHealth;
    function GetCharStatus: Integer;
    procedure MakeOpenHealth;
    procedure IncHealthSpell(nHP, nMP: Integer);
    procedure ItemDamageRevivalRing;
    function CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
    procedure GainSlaveExp(nLevel: Integer);
    procedure MapRandomMove(sMapName: string; nInt: Integer);
    procedure TurnTo(nDir: integer);
    procedure FeatureChanged();
    function GetFeatureToLong(): Integer;
    function GetPoseCreate(): TBaseObject;
    function GetFeature(BaseObject: TBaseObject): Integer; virtual;
    function IsGroupMember(target: TBaseObject): Boolean;
    procedure AbilCopyToWAbil();
    procedure ChangePKStatus(boWarFlag: Boolean);
    procedure StruckDamage(var nDamage: integer; AttackBase: TBaseObject);
    function sub_4C4CD4(sItemName: string; var nCount: Integer): pTUserItem;
    procedure StatusChanged;
    function GeTBaseObjectInfo(): string;
    procedure TrainSkill(UserMagic: pTUserMagic; nTranPoint: Integer);
    function CheckMagicLevelup(UserMagic: pTUserMagic): Boolean;
    function MagCanHitTarget(nX, nY: Integer; TargeTBaseObject: TBaseObject):
      Boolean;
    procedure sub_4C713C(Magic: pTUserMagic);
    function MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
    function MagBubbleDefenceUp57(nLevel, nSec: Integer): Boolean;
    procedure ApplyMeatQuality();
    function TakeBagItems(BaseObject: TBaseObject): Boolean;
    function TakeCloneBagItems(BaseObject: TBaseObject): Boolean;
    function TakeUserItems(BaseObject: TBaseObject): Boolean;
    function AddItemToBag(UserItem: PTUserItem): Boolean;
    function DelBagItem(nIndex: Integer): Boolean; overload;
    function DelBagItem(nItemIndex: Integer; sItemName: string): Boolean;
      overload;
    procedure WeightChanged();
    function IsTrainingSkill(nIndex: Integer): Boolean;
    procedure SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
    function GetQuestFalgStatus(nFlag: integer): Integer;
    //procedure SetQuestUnitOpenStatus(nFlag:Integer;nValue:Integer);
    //function  GetQuestUnitOpenStatus(nFlag:integer):Integer;
    //procedure SetQuestUnitStatus(nFlag:Integer;nValue:Integer);
    //function  GetQuestUnitStatus(nFlag:integer):Integer;
    function GetAttackDir(BaseObject: TBaseObject; var btDir: Byte; btRate: Byte
      = 1): Boolean;
    function TargetInSpitRange(BaseObject: TBaseObject; var btDir: Byte):
      Boolean;
    procedure MonsterRecalcAbilitys();
    procedure RefNameColor;
    procedure SetPKFlag(BaseObject: TBaseObject);
    procedure SetLastHiter(BaseObject: TBaseObject);
    function EnterAnotherMap(Envir: TEnvirnoment; nDMapX, nDMapY: Integer):
      Boolean;
    function sub_4DD704(): Boolean;
    function DefenceUp(nSec: Integer): Boolean;
    function MagDefenceUp(nSec: Integer): Boolean;
    function AttPowerUp(nPower, nTime: Integer): Boolean;
    //function  SCPowerUp(nPower, nTime: Integer): Boolean;
    //function  SCPowerUp(nSec:Integer):Boolean;
    procedure RefShowName;
    function MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob:
      Integer; dwRoyaltySec: LongWord): TBaseObject;

    function MakePosion(nType, nTime, nPoint: Integer): Boolean;
    function GetFrontPosition(var nX: Integer; var nY: Integer): Boolean;
    function GetBackPosition(var nX: Integer; var nY: Integer): Boolean;
    function WalkTo(btDir: Byte; boFlag: boolean): Boolean;
    function GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer):Boolean;
    procedure SpaceMove(sMap: string; nX, nY: Integer; nInt: Integer);
    function sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY:
      Integer): Boolean;
    function CheckItems(sItemName: string): pTUserItem;
    function MagMakeDefenceArea(nX, nY, nRange, nSec: Integer; btState: Byte):
      Integer;
    function sub_4C3538(): Integer;
    function IsGuildMaster(): Boolean;
    function IsStorage(): Boolean;
    procedure LoadSayMsg();
    procedure DisappearA();
    function GetAddName(sName: string; CorpsIdx: Integer): string;
    function GetShowName(): string; virtual;
    procedure DropUseItems(BaseObject: TBaseObject; AttactObject: TBaseObject =
      nil); virtual;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); virtual;
    function GetMessage(Msg: pTProcessMessage): Boolean; virtual; //FFFF
    procedure Initialize(); virtual; //FFFE
    procedure Disappear(); virtual; //FFFD
    function Operate(ProcessMsg: pTProcessMessage): Boolean; virtual; //FFFC
    procedure SearchViewRange(); virtual; //dynamic;
    procedure Run(); virtual; //dynamic;//FFFB
    procedure ProcessSayMsg(sMsg: string); virtual; //FFFA
    procedure MakeGhost; virtual;
    procedure Die(); virtual; //FFF9;
    procedure ReAlive(); virtual; //FFF8;
    procedure RecalcAbilitys(); virtual; //FFF7
    function IsProtectTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF6
    function IsAttackTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF5
    function IsProperTarget(BaseObject: TBaseObject): Boolean; virtual; //FFF4
    function IsProperFriend(BaseObject: TBaseObject): Boolean; virtual; //FFF3
    function IsFriend(cret: TBaseObject): Boolean; virtual;
    procedure SetTargetCreat(BaseObject: TBaseObject); virtual; //FFF2
    procedure DelTargetCreat(); virtual; //FFF1
    procedure RecallSlave(sSlaveName: string);

    function GetMagicInfo(nMagicID: Integer): pTUserMagic;
    function GetMagicInfoEx(nMagic: Integer): pTUserMagic;
    procedure ChangeSKILL(nSour,nNew:Integer);
    procedure SKILL_82(sMap: string; nX, nY: Integer);
    procedure AddItemSkill(nIndex: Integer);
    procedure DelItemSkill(nIndex: Integer);
    function GetItemState(UserItem: pTUserItem; nValType: Integer): Byte;
    //070521新增
    function NewAddDCMCSCUp(nTime: Integer): Boolean;
    function GetHeroBagCount(): Integer;
    function CheckMsgCode(wIdent: Integer): Boolean;
    procedure ChangeShieldMode(boAttact: Boolean);
  end;
{$ENDREGION}

{$REGION 'TAnimalObject'}
  TAnimalObject = class(TBaseObject)
    m_nNotProcessCount: Integer; //未被处理次数，用于怪物处理循环
    m_nTargetX: Integer; //0x538
    m_nTargetY: Integer; //0x53C
    m_boRunAwayMode: Boolean; //0x540
    m_dwRunAwayStart: LongWord; //0x544
    m_dwRunAwayTime: LongWord; //0x548
    m_FPath: pTPaht;
    m_FPathIdx: Integer;
  private

  public
    constructor Create(); override;
    procedure SearchTarget();
    procedure sub_4C959C;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override; //FFFC
    procedure Run; override; //FFFB
    procedure DelTargetCreat(); override; //FFF1
    procedure SetTargetXY(nX, nY: Integer); virtual; //FFF0
    procedure GotoTargetXY(); virtual; //0FFEF
    procedure Wondering(); virtual; //0FFEE
    procedure GetMissionXY(var TargetX: Integer; var TargetY: Integer);
    procedure Attack(TargeTBaseObject: TBaseObject; nDir: Integer); virtual;
    //0FFED
    procedure Struck(Hiter: TBaseObject); virtual; //FFEC

    procedure HitMagAttackTarget(TargeTBaseObject: TBaseObject; nHitPower:
      Integer; nMagPower: integer; boFlag: Boolean);
  end;
{$ENDREGION}

  {$REGION 'play类'}
  TPlayObject = class(TAnimalObject)
    m_dwThinkTick: LongWord;
    m_DefMsg: TDefaultMessage; //0x550
    //      TList55C                :TList;      //0x55C
    m_sOldSayMsg: string; //0x560
    m_nSayMsgCount: Integer; //0x560
    m_dwSayMsgTick: LongWord; //0x568
    m_boDisableSayMsg: Boolean; //0x56C
    m_dwDisableSayMsgTick: LongWord; //0x570
    m_dwCheckDupObjTick: LongWord; //0x574
    dwTick578: LongWord; //0x578
    //      dwTick57C               :LongWord;   //0x57C
    m_boInSafeArea: Boolean; //0x580
    n584: Integer; //0x584
    n588: Integer; //0x584
    m_sUserID: string[11]; //0x58C    登录帐号名
    m_sIPaddr: string; //0x598    人物IP地址
    m_sIPLocal: string;
    m_nSocket: Integer; //0x59C nSocket
    m_nGSocketIdx: Integer;
    //0x5A0 wGateIndex 人物连接到游戏网关SOCKET ID
    m_nGateIdx: Integer; //0x5A8 nGateIdx   人物所在网关号
    m_dLogonTime: TDateTime; //0x5B0  //登录时间
    m_dwLogonTick: LongWord; //0x5B8  战领沙城时间(Dword)
    m_boReadyRun: Boolean; //0x5BC  //是否进入游戏完成
    m_nSessionID: Integer; //0x5C0
    m_nPayMent: Integer; //0x5C4  人物当前模式(测试/付费模式)(Dword)
    m_nPayMode: Integer; //0x5C8
    //m_SessInfo                :pTSessInfo; //全局会话信息
    m_dwLoadTick: LongWord; //0x5CC
    m_nServerIndex: Integer; //0x5D0  人物当前所在服务器序号
    m_boEmergencyClose: Boolean; //0x5D4  掉线标志
    m_boSoftClose: Boolean; //0x5D5
    m_boKickFlag: Boolean; //0x5D6  断线标志(Byte)(@kick 命令)
    m_boReconnection: Boolean; //0x5D7
    m_boRcdSaved: Boolean; //0x5D8
    m_boSwitchData: Boolean; //0x5D9
    m_nWriteChgDataErrCount: Integer; //0x5DC
    m_sSwitchMapName: string; //0x5E0
    m_nSwitchMapX: Integer; //0x5E4
    m_nSwitchMapY: Integer; //0x5E8
    m_boSwitchDataSended: Boolean; //0x5EC
    m_dwChgDataWritedTick: LongWord; //0x5F0
    m_dw5D4: LongWord; //0x5F4
    n5F8: Integer; //0x5F8
    n5FC: Integer; //0x5FC
    m_dwHitIntervalTime: LongWord; //攻击间隔  //英雄攻击间隔
    m_dwMagicHitIntervalTime: LongWord; //魔法间隔
    m_dwRunIntervalTime: LongWord; //走路间隔  //英雄走动间隔
    m_dwWalkIntervalTime: LongWord; //走路间隔
    m_dwTurnIntervalTime: LongWord; //换方向间隔
    m_dwActionIntervalTime: LongWord; //组合操作间隔
    m_dwRunLongHitIntervalTime: LongWord; //移动刺杀间隔
    m_dwRunHitIntervalTime: LongWord; //跑位攻击间隔
    m_dwWalkHitIntervalTime: LongWord; //走位攻击间隔
    m_dwRunMagicIntervalTime: LongWord; //跑位魔法间
    m_dwSortViewTime: LongWord;
    m_RandomNo: Word;

    m_dwMagicAttackTick: LongWord; //0x600  魔法攻击时间(Dword)
    m_dwMagicAttackInterval: LongWord; //0x604  魔法攻击间隔时间(Dword)
    m_dwAttackTick: LongWord; //0x608  攻击时间(Dword)
    m_dwMoveTick: LongWord; //0x60C  人物跑动时间(Dword)
    m_dwAttackCount: LongWord; //0x610  人物攻击计数(Dword)
    m_dwAttackCountA: LongWord; //0x614  人物攻击计数(Dword)
    m_dwMagicAttackCount: LongWord; //0x618  魔法攻击计数(Dword)
    m_dwMoveCount: LongWord; //0x61C  人物跑计数(Dword)
    m_dwMoveCountA: LongWord; //0x620  人物跑计数(Dword)
    m_nOverSpeedCount: Integer; //0x624  超速计数(Dword)
    m_boDieInFight3Zone: Boolean; //0x628
    m_Script: pTScript; //0x62C
    m_NPC: TBaseObject; //0x630
    m_DealGoldBase: TBaseObject;
    m_nVal: array[0..99] of Integer; //0x634 - 658
    m_nMval: array[0..99] of Integer;
    m_DyVal: array[0..99] of Integer; //0x65C - 680
    m_DyValEx: array[0..99] of Integer; //0x65C - 680
    m_StrVal: array[0..99] of string;
    m_ServerStrVal: array[0..20] of string;
    m_ServerIntVal: array[0..20] of Integer;
    m_sPlayDiceLabel: string;
    m_boTimeRecall: Boolean; //0x684
    m_dwTimeRecallTick: LongWord; //0x688
    m_sMoveMap: string; //0x68C
    m_nMoveX: Integer; //0x690
    m_nMoveY: Integer; //0x694
    bo698: Boolean; //0x698
    n69C: Integer; //0x69C
    m_dwSaveRcdTick: LongWord; //0x6A0 保存人物数据时间间隔
    m_btBright: Byte;
    m_boNewHuman: Boolean; //0x6A8
    m_boSendNotice: Boolean; //0x6A9
    m_dwWaitLoginNoticeOKTick: LongWord;
    m_boLoginNoticeOK: Boolean; //0x6AA
    bo6AB: Boolean; //0x6AB
    m_boExpire: Boolean; //0x6AC  帐号过期
    m_dwShowLineNoticeTick: LongWord; //0x6B0
    m_nShowLineNoticeIdx: Integer; //0x6B4
    m_dwShowLineNoticeTick2: LongWord; //0x6B0
    m_nShowLineNoticeIdx2: Integer; //0x6B4

    m_dwSendWhisperTime: LongWord;
    m_nSendWhisperIdx: Byte;

    //m_AddUseItems             :array[9..12] of TUserItem;
    m_CanJmpScriptLableList: TStringList;
    m_nScriptGotoCount: Integer;
    m_sScriptCurrLable: string; //用于处理 @back 脚本命令
    m_sScriptGoBackLable: string; //用于处理 @back 脚本命令
    m_dwTurnTick: LongWord;
    m_wOldIdent: Word;
    m_btOldDir: Byte;

    m_boFirstAction: Boolean; //第一个操作
    m_dwActionTick: LongWord; //二次操作之间间隔时间
    m_sDearName: string[ActorNameLen]; //配偶名称
    m_DearHuman: TPlayObject;
    m_boCanDearRecall: Boolean; //是否允许夫妻传送
    m_boCanMasterRecall: Boolean;
    m_dwDearRecallTick: LongWord; //夫妻传送时间
    m_dwMasterRecallTick: LongWord;
    m_sMasterName: string[ActorNameLen]; //师徒名称
    m_MasterHuman: TPlayObject;
    m_MasterList: TList;

    m_boMaster: Boolean;
    m_btCreditPoint: integer; //声望点
    m_btMarryCount: Byte; //离婚次数
    m_nMasterCount: Integer; //出师徒弟个数
    m_btReLevel: Byte; //转生等级
    m_btReColorIdx: Byte;
    m_dwReColorTick: LongWord;
    m_nKillMonExpMultiple: Integer; //杀怪经验倍数
    m_dwGetMsgTick: LongWord; //处理消息循环时间控制

    m_boNpcOffLine: Boolean;
    m_boAutoOffLine: Boolean;
    m_boSafeOffLine: Boolean;
    m_dwSafeOffLine: LongWord;
    m_nOffLineAddExp: Integer;
    m_dwOffLineAddExpTick: LongWord;
    m_dwOffLineAddExpTime: LongWord;
    m_boOffLineLogin: Boolean;

    m_boSetStoragePwd: Boolean;
    m_boReConfigPwd: Boolean;
    m_boCheckOldPwd: Boolean;
    m_boUnLockPwd: Boolean;
    m_boUnLockStoragePwd: Boolean;
    m_boPasswordLocked: Boolean; //锁密码
    m_btPwdFailCount: Byte;
    m_boLockLogon: Boolean; //是否启用锁登录功能
    m_boLockLogoned: Boolean; //是否打开登录锁
    m_sTempPwd: string[7];
    m_sStoragePwd: string[7];
    m_PoseBaseObject: TBaseObject;
    m_boStartMarry: Boolean;
    m_boStartMaster: Boolean;
    m_boStartUnMarry: Boolean;
    m_boStartUnMaster: Boolean;
    m_boFilterSendMsg: Boolean; //禁止发方字(发的文字只能自己看到)
    m_nKillMonExpRate: Integer;
    //杀怪经验倍数(此数除以 100 为真正倍数)
    m_nPowerRate: Integer;
    //人物攻击力倍数(此数除以 100 为真正倍数)
    m_dwKillMonExpRateTime: LongWord;
    m_dwPowerRateTime: LongWord;
    m_dwRateTick: LongWord;

    m_nKillMonCount: Integer;

    m_boCanUseItem: Boolean; //是否允许使用物品
    m_boCanDeal: Boolean;
    m_boCanDrop: Boolean;
    m_boCanGetBackItem: Boolean;
    m_boCanWalk: Boolean;
    m_boCanRun: Boolean;
    m_boCanHit: Boolean;
    m_boCanSpell: Boolean;
    m_boCanSendMsg: Boolean;

    m_nMemberType: Integer; //会员类型
    m_nMemberLevel: Integer; //会员等级
    m_boSendMsgFlag: Boolean; //发祝福语标志
    m_boChangeItemNameFlag: Boolean;
    m_nGloryPoint: Word; //荣誉值/英雄忠诚度

    m_nGameGold: Integer; //游戏币
    m_boDecGameGold: Boolean; //是否自动减游戏币
    m_dwDecGameGoldTime: LongWord;
    m_dwDecGameGoldTick: LongWord;
    m_nDecGameGold: Integer; //一次减点数

    m_boIncGameGold: Boolean; //是否自动加游戏币
    m_dwIncGameGoldTime: LongWord;
    m_dwIncGameGoldTick: LongWord;
    m_nIncGameGold: Integer; //一次减点数

    m_nGamePoint: Integer; //游戏点数
    m_dwIncGamePointTick: LongWord;

    m_nPayMentPoint: Integer;
    m_dwPayMentPointTick: LongWord;

    m_dwDecHPTick: LongWord;
    m_dwIncHPTick: LongWord;

    m_GetWhisperHuman: TPlayObject;
    m_dwClearObjTick: LongWord;
    m_wContribution: Word; //贡献度
    m_sRankLevelName: string; //显示名称格式串
    m_boFilterAction: Boolean;
    //m_boClientFlag            :Boolean;
    m_nStep: Byte;
    //    m_nClientFlagMode         :Integer;
    m_dwAutoGetExpTick: LongWord;
    m_nAutoGetExpTime: Integer;
    m_nAutoGetExpPoint: Integer;
    m_AutoGetExpEnvir: TEnvirnoment;
    m_boAutoGetExpInSafeZone: Boolean;
    m_DynamicVarList: TList;
    m_boTestSpeedMode: Boolean; //进入速度测试模式

    m_ShopSend: array[0..5] of Boolean; //商铺
    m_ShopTickTime: LongWord; //商铺购买时间

    m_DelayNpc: pTDelayCall;
    m_OnTimerList: TList;

    m_nGameDiamond: Integer;
    m_nGameGird: Integer;
    m_boOpenBox: Boolean;
    OpenBoxItem: array[0..8] of TClientItem;
    OpenBoxGetItem: TClientItem;
    OpenBoxsSet: TBoxsSet;
    nTwinHitSkillTick: LongWord;
    nTwinHitSkillCount: Integer;
    m_SuitIdx: array[0..255] of Byte;
    m_sOffLineFunc: string;
 {$REGION '没用的'}
    {
    LatestRevivalTime       :LongWord;
    wObjectType  :Word;
    Feature      :TObjectFeature;
    boOpenHealth :Boolean;
    dwOpenHealthStart :LongWord;
    dwOpenHealthTime  :LongWord;
    dwMapMoveTime    :LongWord;

    dwTargetFocusTime:LongWord;

    dwWalkTime  :LongWord;
    AntiMagic     :Integer;
    BoAbilSeeHealGauge :Boolean;
    dwStruckTime :LongWord;
    nMeatQuality :Integer;
    nHitTime     :Integer;
    bofirst      :Boolean;
    nSlaveMakeLevel :Integer;
    dwNextHitTime  :LongWord;
    dwNextWalkTime :LongWord;
    boUsePoison    :Boolean;
    }
 {$ENDREGION}
    nRunCount: Integer;
    dwRunTimeCount: LongWord;
    m_dwDelayTime: LongWord;
    m_dwHeroAllExp: LongWord;
    m_boHeroFourMagic: Boolean;
    m_boCheckOk: Boolean;
    m_nChickNpc: Byte;
    m_nChangeMap: Byte;
    m_nChangeMap2: Byte;
    m_nAttact: Byte;
    m_boAutoCheck: Boolean;
    m_OpenAd: array[0..ADMAX] of Byte;
    m_HeroMinHPTail:Word;//英雄低血逃跑
    m_Challenge: TPlayObject;//挑战的玩家
    m_boChallengeing:Boolean;//是否打开了挑战窗口正在抵押物品
    m_boChallengeOK:Boolean;//是否按了确定了抵押品
    m_dwChallengeTime:LongWord;//开始挑战时间
    pChallengeItem:PTChallengeItem;//挑战物品
    m_boKILLBYHUM:Boolean;//玩家是被怪物杀死还是人物
  private
    procedure RecalcHeroBagCount();
    //    function  IsHero(BaseObject:TBaseObject):Boolean;
    function IsSelf(BaseObject: TBaseObject): Boolean;
    function IsOfGroup(BaseObject: TBaseObject): Boolean;
    function ClientDropGold(nGold: Integer): Boolean;
    procedure ClientQueryBagItems();
    procedure ClientQueryUserState(PlayObject: TBaseObject; nX, nY: Integer);
    procedure ClientQueryUserSet(ProcessMsg: pTProcessMessage);
    function ClientDropItem(sItemName: string; nItemIdx: Integer): Boolean;
    function ClientPickUpItem: Boolean;
    procedure ClientOpenDoor(nX, nY: Integer);
    procedure ClientTakeOnItems(btWhere: Byte; nItemIdx: integer; sItemName:
      string);
    procedure ClientIncFireDrakeHeartDander(nItemIdx: integer);
    procedure ClientItemFold(bHero:Byte;sMsg:String);
    procedure ClientTakeOffItems(btWhere: Byte; nItemIdx: integer; sItemName:
      string);
    procedure ClientUseItems(nItemIdx: Integer; sItemName: string);
    function UseStdmodeFunItem(StdItem: TItem): Boolean;
    function ClientGetButchItem(BaseObject: TBaseObject; nX, nY: Integer; btDir:
      Byte; var dwDelayTime: LongWord): Boolean;
    procedure ClientChangeMagicKey(nSkillIdx, nKey: integer; bohero: integer);
    procedure ClientClickNPC(NPC: Integer);
    procedure ClientClickPlay(BaseObject: TBaseObject; nX, nY: Integer);
    procedure ClientGetShopList();
    procedure ClientBuySelfShopItem(BaseObject: TBaseObject; nX, nY: Integer;
      sMsg: string);
    procedure ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);
    procedure ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer; sMsg:
      string);
    procedure ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg: string);
    procedure ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer; sMsg:
      string);
    procedure ClientQueryRepairCost(nParam1, nInt: Integer; sMsg: string);
    procedure ClientRepairItem(nParam1, nInt: Integer; sMsg: string);
    procedure ClientCheckVer(nParam1: Integer; sMsg: string);
    procedure ClientCheckDecodeMessagePacket(datablock: string);
    function EncodeDefMessageRsaString(wIdent: Word; nRecog: Integer; wParam,
      wTag, wSeries: Word; sSendMsg: string): string;

    procedure ClientGroupClose();
    procedure ClientCreateGroup(sHumName: string; boAuto: Boolean);
    procedure ClientAutoGroup(boAuto: Boolean);
    procedure ClientAutoAddGroup(sName: string);
    procedure ClientAddGroupMember(sHumName: string);
    procedure ClientDelGroupMember(sHumName: string);
    procedure ClientDealTry(sHumName: string);
    procedure ClientChallengeTry(); //申请挑战
    procedure ClientAddChallengeItem(nItemIdx,nidx: integer);//添加挑战抵押物品
    procedure ClientDelChallengeItem(nItemIdx,nidx: integer);//删除挑战抵押物品
    procedure ClientAddDealItem(nItemIdx: integer; sItemName: string);
    procedure ClientDelDealItem(nItemIdx: integer; sItemName: string);
    procedure ClientCancelDeal();
    procedure ClientChangeDealGold(nGold: Integer);//更改交易金币
    procedure ClientChangeChallengeGold(nGold: Integer);//更改挑战抵押金币
    procedure ClientChangeChallengeGameDiamond(nGold: Integer);//更改挑战抵押金刚石
    procedure ClientChallengeEnd();//确认挑战抵押物品
    procedure ChallengeWine();//挑战获胜
    procedure ClientDealEnd();
    procedure ClientStorageItem(NPC: TObject; nItemIdx: Integer; sMsg: string);
    procedure ClientPlayDrink(NPC: TObject; nItemIdx: Integer);
    procedure ClientPlayDrinkGame(Npc, nIdx: Integer);
    procedure ClientPlayDrinkSend(Npc, nIdx, DClass: Integer);
    procedure ClientTakeBackStorageItem(NPC: TObject; nItemIdx: Integer; sMsg:
      string);
    procedure ClientGetMinMap();
    procedure ClientMakeDrugItem(NPC: TObject; nItemName: string);
    procedure ClientOpenGuildDlg();
    procedure ClientGuildHome();
    procedure ClientGuildMemberList();
    procedure ClientGuildAddMember(sHumName: string);
    procedure ClientGuildDelMember(sHumName: string);
    procedure ClientGuildUpdateNotice(Notict: string);
    procedure ClientGuildUpdateMsg(nClose: Byte; Notict: string);
    procedure ClientGuildUpdateRankInfo(sRankInfo: string);
    procedure ClientGuildAlly();
    procedure ClientGuildBreakAlly(sGuildName: string);
    procedure ClientAdjustBonus(nPoint: Integer; sMsg: string);
    function ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var
      dwDelayTime: LongWord): Boolean;
    function ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery:
      Boolean; var dwDelayTime: LongWord): Boolean;

    function ClientHorseRunXY(wIdent: Word; nX, nY: Integer; boLateDelivery:
      Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer; var
      dwDelayTime: LongWord): Boolean;
    function ClientHitXY(wIdent: Word; nX, nY, nDir: Integer; boLateDelivery:
      Boolean; var dwDelayTime: LongWord): Boolean;
    function ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime: LongWord):
      Boolean;
    function ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX, nTargetY:
      Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var
      dwDelayTime: LongWord): Boolean;

    function GetUserItemWeitht(nWhere: Integer): Integer;

    procedure SendDelDealItem(UserItem: pTUserItem);
    procedure SendDelShopItem(UserItem: pTUserItem);
    procedure SendAddDealItem(UserItem: pTUserItem);

    procedure SendChallengeADDitem(UserItem: pTUserItem;nidx:Integer);
    procedure SendChallengeDelItem(UserItem: pTUserItem;nidx:Integer);

    procedure MapEventCheck(nEvent: Byte; sItemName: string);

    procedure OpenDealDlg(BaseObject: TBaseObject);
    procedure OpenChallengeDlg(PlayObject: TPlayObject);

    function EatItems(StdItem: TItem; var nCount: Integer): Boolean;

    function ReadBook(StdItem: TItem): Boolean;
    function DayBright(): Byte;
    procedure BaseObjectMove(sMap, sX, sY: string);
    procedure MoveToHome();
    function RepairWeapon(): Boolean;
    function SuperRepairWeapon(): Boolean;
    function WinLottery(): Boolean;
    procedure ChangeServerMakeSlave(SlaveInfo: pTSlaveInfo);
    function WeaptonMakeLuck(): Boolean;
    function PileStones2(nX, nY: Integer): Boolean;

    procedure ThrustingOnOff(boSwitch: Boolean);
    procedure HalfMoonOnOff(boSwitch: Boolean);
    procedure RedHalfMoonOnOff(boSwitch: Boolean);
    procedure SkillCrsOnOff(boSwitch: Boolean);
    //    procedure SkillTwinOnOff(boSwitch: Boolean);
    //    procedure Skill43OnOff(boSwitch: Boolean);
    function AllowFireHitSkill(): Boolean;
    function AllowLongFireHitSkill(): Boolean;
    function AllowTwinHitSkill(): Boolean;
    function AllowLongSwordSkill(): Boolean;
    procedure MakeMine();
    procedure MakeMine2();

    function GetRangeHumanCount(): Integer;
    procedure GetHomePoint();
    //    function  GetStartPoint(var StartPoint:pTStartPoint):Boolean;

        //procedure MobPlace(sX, sY, sMonName, sCount: String);

    procedure LogonTimcCost;
    procedure SendNotice();
    procedure SendLogon();
    procedure SendOpenItem();
    procedure SendServerStatus();
    procedure DelBagItemEx(MakeIdx: Integer; LogIdx: Byte);

    //    procedure SendUserName(PlayObject:TPlayObject;nX,nY:Integer);

    procedure ClientQueryUserName(target: TBaseObject; x, y: integer);
    procedure SendUseitems();
    procedure SendUseMagic();
    procedure SendSaveItemList(nBaseObject: Integer);
    procedure SendDelItemList(ItemList: TStringList);
    procedure SendAdjustBonus();
    procedure SendChangeGuildName();
    procedure SendMapDescription();
    procedure SendGoldInfo(boSendName: Boolean);

    procedure ShowMapInfo(sMap, sX, sY: string);

    function CancelGroup(): Boolean;
    function GetSpellPoint(UserMagic: pTUserMagic): Integer;
    function DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
    function CanMotaebo(BaseObject: TBaseObject; nMagicLevel: Integer): Boolean;
    function DoSpell(UserMagic: pTUserMagic; nTargetX, nTargetY: Integer;
      BaseObject: TBaseObject): boolean;
    procedure GetOldAbil(var OAbility: TOAbility);
    //procedure ReadAllBook;
    function CheckItemsNeed(StdItem: TItem): Boolean;
    function CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord):
      Boolean;
    procedure RecalcAdjusBonus;
    procedure CheckMarry();
    procedure CheckMaster();
    procedure RefMyStatus;

    procedure ProcessClientPassword(ProcessMsg: pTProcessMessage);
    function CheckDenyLogon: Boolean;
    procedure ProcessSpiritSuite;
    function HorseRunTo(btDir: Byte; boFlag: boolean): Boolean;
  public
    constructor Create(); override;
    destructor Destroy; override;

    procedure SendServerConfig();
    procedure SendExpShowConfig();
    //    procedure SendServerConfig22();
    function CheckItemBindUse(UserItem: pTUserItem): Boolean;
    function CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem): Boolean;
    function CretInNearXY(TargeTBaseObject: TBaseObject; nX, nY: Integer):
      Boolean;
    function EatUseItems(nShape: integer): Boolean;
    procedure RunHero();
    function Think(): Boolean;
    procedure HeroTail();
    function HeroThink(): Boolean; //004A8E54
    function HeroAttackTarget(): Boolean; //001833E0
    function HeroPickUpItems(): Boolean; //001AB2CC
    procedure SetPickItems(MapItem: pTVisibleMapItem);
    procedure DelPickItems(); //004A8E54
    function HeroBasicAttackTarget(): Boolean; //004A8E54
    function HeroWarrAttackTarget(): Boolean; //004A8E54
    function HeroWizardAttackTarget(): Boolean; //004A8E54
    function HeroTaosAttackTarget(): Boolean; //004A8E54
    procedure RefDiamondGird;
    //    procedure HeroMove(BaseObject:TBaseObject);

    function MakeSlaveEx(sMonName: string; nX, nY, nMaxMob: Integer;
      dwRoyaltySec: LongWord): TBaseObject;

    procedure SendSocket(DefMsg: pTDefaultMessage; sMsg: string); virtual;
    procedure SendDefMessage(wIdent: Word; nRecog: Integer; nParam, nTag,
      nSeries: Word; sMsg: string);
    procedure SendDefMessagebyClass(wIdent: Word; nRecog: Integer; nParam, nTag,
      nSeries: Word; sMsg, sClass: string);
    procedure SendDefCheckMessage(sMsg: string);
    procedure SearchViewRange(); override;
    procedure UpdateVisibleGay(BaseObject: TBaseObject); override;
    procedure PKDie(PlayObject: TPlayObject);
    procedure GameTimeChanged();
    procedure RunNotice();
    function GetMyStatus(): Integer;
    function IncGold(tGold: Integer): Boolean;
    function IsEnoughBag(): Boolean;
    function IsAddWeightAvailable(nWeight: Integer): Boolean;
    procedure SendAddItem(UserItem: pTUserItem;bShow:byte=0);
    procedure SendMsgItem(wIdent: Word; nRecog: Integer; nParam, nTag, nSeries:
      Word; UserItem: pTUserItem);
    procedure SendActionGood();
    procedure SendActionFail();
    procedure SendDelItems(UserItem: pTUserItem);
    procedure Whisper(whostr, saystr: string);
    function IsBlockWhisper(sName: string): Boolean;
    function QuestCheckItem(sItemName: string; var nCount: Integer; var nParam:
      Integer; var nDura: Integer): pTUserItem;
    function QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
    procedure GainExp(dwExp: LongWord);
    procedure GetExp(dwExp2: LongWord; boHero: Boolean = False);
    procedure WinExp(dwExp: LongWord);
    function DecGold(nGold: Integer): Boolean;
    procedure Run(); override;
    function Operate(ProcessMsg: pTProcessMessage): Boolean; override;
    function HeroOperate(ProcessMsg: pTProcessMessage): Boolean;
    procedure RecalcAbilitys(); override; //FFF7
    procedure MakeSaveRcd(var HumanRcd: THumDataInfo);
    procedure DealCancel();
    procedure ChallengeCancel();
    procedure DealCancelA();
    function  GetShowName(): string; override;
    procedure GetBackDealItems();
    Procedure GetBackChallengeItems();
    procedure GetBackShopItems();
    procedure Disappear(); override; //FFFD
    procedure ShopCancel();
    procedure GoldChange(sChrName: string; nGold: Integer);
    procedure ProcessUserLineMsg(sData: string);
    procedure ProcessSayMsg(sData: string); override;
    procedure ClearStatusTime();
    procedure UserLogon(); virtual;
    procedure UserOffLineLogon();
    procedure HeroLogon();
    procedure RefRankInfo(nRankNo: Integer; sRankName: string);
    procedure RefUserState;
    procedure SendGroupMembers();
    procedure JoinGroup(PlayObject: TPlayObject);
    function GeTBaseObjectInfo(): string;
    function GetHitMsgCount(): Integer;
    function GetSpellMsgCount(): Integer;
    function GetWalkMsgCount(): Integer;
    function GetRunMsgCount(): Integer;
    function GetTurnMsgCount(): Integer;
    function GetSiteDownMsgCount(): Integer;
    function GetDigUpMsgCount(): Integer;
    procedure SetScriptLabel(sLabel: string);
    procedure GetScriptLabel(sMsg: string);
    function LableIsCanJmp(sLabel: string): Boolean;
    function GetMyInfo(): string;
    function GetSelfInfo(sMsg: string): string;
    procedure MakeGhost; override;
    function MakeOffLine(): Boolean;
    procedure ScatterBagItems(ItemOfCreat: TBaseObject); override;
    //procedure DropUseItems(BaseObject:TBaseObject); override;
    procedure RecallHuman(sHumName: string);
    procedure SendAddMagic(UserMagic: pTUserMagic);
    procedure SendDelMagic(UserMagic: pTUserMagic);
    procedure ReQuestGuildWar(sGuildName: string);
    procedure SendUpdateItem(UserItem: pTUserItem);
    //    procedure GetBagUseItems(var btDc:Byte;var btSc:Byte;var btMc:Byte;var btDura:Byte);
    function GetBagItemsEx(nItemIdx: Integer): pTUserItem;
    function MakeClientItem(UserItem: pTUserItem; boCarp: Boolean = False):
      string;
    function MakeClientItemex(UserItem: pTUserItem):
      string;
    function MakeBoxClientItem(ClientItem: TClientItem): string;

    //protected
    procedure CmdEndGuild();
    procedure CmdMemberFunction(sCmd, sParam: string);
    procedure CmdMemberFunctionEx(sCmd, sParam: string);

    procedure CmdSearchDear(sCmd, sParam: string);
    procedure CmdSearchMaster(sCmd, sParam: string);
    procedure CmdDearRecall(sCmd, sParam: string);
    procedure CmdMasterRecall(sCmd, sParam: string);
    procedure CmdSbkDoorControl(sCmd, sParam: string);

    procedure CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowUseItemInfo(Cmd: pTGameCmd; sHumanName: string);

    procedure CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType: string);
    procedure CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem, sType:
      string);
    procedure CmdLockLogin(Cmd: pTGameCmd);
    procedure CmdViewDiary(sCMD: string; nFlag: Integer);
    procedure CmdUserMoveXY(sCMD, sX, sY: string);
    procedure CmdSearchHuman(sCMD, sHumanName: string);
    procedure CmdGroupRecall(sCMD: string);
    procedure CmdAllowGroupReCall(sCmd, sParam: string);

    procedure CmdGuildRecall(sCmd, sParam: string);

    procedure CmdChangeAttackMode(nMode: Integer; sParam1, sParam2, sParam3,
      sParam4, sParam5, sParam6, sParam7: string);
    procedure CmdChangeSalveStatus();
    procedure CmdTakeOnHorse(sCmd, sParam: string);
    procedure CmdTakeOffHorse(sCmd, sParam: string);

    procedure CmdPrvMsg(sCmd: string; nPermission: Integer; sHumanName: string);
    procedure CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMapMove(Cmd: pTGameCmd; sMapName: string);

    procedure CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);

    procedure CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReLoadAdmin(sCmd: string);
    procedure CmdReloadNpc(sParam: string);
    procedure CmdReloadManage(Cmd: pTGameCmd; sParam: string);
    procedure CmdReloadRobotManage;
    procedure CmdReloadRobot;
    procedure CmdReloadMonItems();
    procedure CmdAdjustExp(Human: TPlayObject; nExp: Integer);
    procedure CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief: string);
    procedure CmdDelGuild(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdGuildWar(sCmd, sGuildName: string);
    procedure CmdChangeSabukLord(Cmd: pTGameCmd; sCastleName, sGuildName:
      string; boFlag: Boolean);
    procedure CmdForcedWallconquestWar(Cmd: pTGameCmd; sCastleName: string);
    procedure CmdOPTraining(sHumanName, sSkillName: string; nLevel: Integer);
    procedure CmdOPDeleteSkill(sHumanName, sSkillName: string);
    procedure CmdReloadGuildAll();
    procedure CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string; nLevel:
      Integer);
    procedure CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);

    procedure CmdBackStep(sCmd: string; nType, nCount: Integer);
    procedure CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdPKpoint(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint:
      Integer);
    procedure CmdHunger(sCmd, sHumanName: string; nHungerPoint: Integer);
    procedure CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair: Integer);
    procedure CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string;
      nLevel: Integer);
    procedure CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName: string;
      nLevel: Integer);

    procedure CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName: string);
    procedure CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName: string;
      nCount: Integer);
    procedure CmdClearMission(Cmd: pTGameCmd; sHumanName: string);

    procedure CmdTraining(sSkillName: string; nLevel: Integer);
    procedure CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName: string);
    procedure CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
    procedure CmdMission(Cmd: pTGameCmd; sX, sY: string);
    procedure CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount: string);
    procedure CmdMobLevel(Cmd: pTGameCmd; Param: string);
    procedure CmdMobCount(Cmd: pTGameCmd; sMapName: string);
    procedure CmdHumanCount(Cmd: pTGameCmd; sMapName: string);

    procedure CmdDisableFilter(sCmd, sParam1: string);
    procedure CmdChangeUserFull(sCmd, sUserCount: string);
    procedure CmdChangeZenFastStep(sCmd, sFastStep: string);

    procedure CmdReconnection(sCmd, sIPaddr, sPort: string);
    procedure CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdStartContest(Cmd: pTGameCmd; sParam1: string);
    procedure CmdEndContest(Cmd: pTGameCmd; sParam1: string);

    procedure CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
    procedure CmdKill(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount: Integer);
    procedure CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue: Integer);
    procedure CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
    procedure CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);

    procedure CmdFireBurn(nInt, nTime, nN: Integer);
    procedure CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint: Integer);

    procedure CmdTestStatus(sCmd: string; nType, nTime: Integer);

    procedure CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount: Integer);
    procedure CmdDelGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdAddGameGold(sCmd, sHumName: string; nPoint: Integer);
    procedure CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr: string;
      nGold: Integer);
    procedure CmdGamePoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string;
      nPoint: Integer);
    procedure CmdCreditPoint(Cmd: pTGameCmd; sHumanName: string; sCtr: string;
      nPoint: Integer);

    procedure CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel: Integer;
      nExpRatio: Integer = -1);

    procedure CmdRefineWeapon(Cmd: pTGameCmd; nDC, nMC, nSC, nHit: Integer);
    procedure CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel,
      nAutoChangeColor, nFixColor: Integer);
    procedure CmdLuckPoint(sCmd: string; nPerMission: Integer; sHumanName, sCtr,
      sPoint: string);
    procedure CmdLotteryTicket(sCmd: string; nPerMission: Integer; sParam1:
      string);
    procedure CmdReloadGuild(sCmd: string; nPerMission: Integer; sParam1:
      string);
    procedure CmdReloadLineNotice(sCmd: string; nPerMission: Integer; sParam1:
      string);
    procedure CmdReloadAbuse(sCmd: string; nPerMission: Integer; sParam1:
      string);

    procedure CmdMobNpc(sCmd: string; nPermission: Integer; sParam1, sParam2,
      sParam3, sParam4: string);
    procedure CmdNpcScript(sCmd: string; nPermission: Integer; sParam1, sParam2,
      sParam3: string);
    procedure CmdDelNpc(sCmd: string; nPermission: Integer; sParam1: string);
    procedure CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
    procedure CmdTing(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
    procedure CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
    procedure CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
    procedure CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);

    procedure CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string; boAll:
      Boolean);
    procedure CmdShutupList(Cmd: pTGameCmd; sParam1: string);
    procedure CmdShowSbkGold(Cmd: pTGameCmd; sCastleName, sCtr, sGold: string);
    procedure CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdShowHumanFlag(sCmd: string; nPermission: Integer; sHumanName,
      sFlag: string);
    procedure CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer;
      sHumanName, sUnit: string);
    procedure CmdShowHumanUnit(sCmd: string; nPermission: Integer; sHumanName,
      sUnit: string);

    procedure CmdChangeAdminMode(sCmd: string; nPermission: Integer; sParam1:
      string; boFlag: Boolean);
    procedure CmdChangeObMode(sCmd: string; nPermission: Integer; sParam1:
      string; boFlag: Boolean);
    procedure CmdChangeSuperManMode(sCmd: string; nPermission: Integer; sParam1:
      string; boFlag: Boolean);
    procedure CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
    procedure CmdChangeDearName(Cmd: pTGameCmd; sHumanName: string; sDearName:
      string);
    procedure CmdChangeMasterName(Cmd: pTGameCmd; sHumanName: string;
      sMasterName, sIsMaster: string);
    procedure CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
    procedure CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission: string);
    procedure CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName, sItems:
      string);
    procedure CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);

    procedure CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);
    procedure CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny: string);

    procedure CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny: string);
    procedure CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny:
      string);
    procedure CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny:
      string);

    procedure CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny: string);
    procedure CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny:
      string);
    procedure CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny:
      string);
    procedure CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2: string);
    procedure CmdSpirtStart(sCmd: string; sParam1: string);
    procedure CmdSpirtStop(sCmd: string; sParam1: string);
    procedure CmdSetMapMode(sCmd: string; sMapName, sMapMode, sParam1, sParam2:
      string);
    procedure CmdShowMapMode(sCmd: string; sMapName: string);
    procedure CmdClearHumanPassword(sCmd: string; nPermission: Integer;
      sHumanName: string);

    procedure CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName:
      string);
    procedure CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdDisableSendMsgList(Cmd: pTGameCmd);
    procedure CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
    procedure CmdMobFireBurn(Cmd: pTGameCmd; sMap, sX, sY, sType, sTime, sPoint:
      string);
    procedure CmdTestSpeedMode(Cmd: pTGameCmd);

    procedure SendWhisperMsg(PlayObject: TPlayObject);

    procedure CmdHeroState();
    procedure CmdHeroLevel(Cmd: pTGameCmd; sHumanName: string; nLevel: Integer);
    procedure CmdHeroFealty(Cmd: pTGameCmd; sHumanName: string; nLevel: Word);
    procedure CmdSignMove(Cmd: pTGameCmd; sHumanName: string);
    procedure CmdAllSysMsg(sParam: string);
    procedure CmdShowEffect(Cmd: pTGameCmd; nParam: Integer);

    procedure ClientGetPlayDrink(Npc, Drink1: Integer; Msg: string);
    procedure ClientGetHero(Hero: Integer);
    procedure HeroItemToMasterBag(ItemId: Integer; Msg: string);
    procedure MasterItemToHeroBag(ItemId: Integer; Msg: string);
    procedure HeroEatItems(nItemIdx: Integer; sItemName: string);
    procedure HeroLockedObject(t_Type, nX, nY: Integer; BaseObject:
      TBaseObject);
    function HeroGetWideCount(): Integer;
    function HeroGetCrsHitCount(): Integer;
    //procedure HeroAutoEatItems();     m_boCrsHitkill
    procedure HeroFunction(nJob: Byte; noff: Byte);
    procedure HeroCallMob(nClass, nFairy, nDogz, BoneFamm: Byte);
    procedure HeroAllowJointAttac();
    function HeroGetMagicCode(nJob, mJob: Byte): Byte;
    procedure HeroChangeGlory(nPoint: Word; nMode: Byte);

    procedure ClientLevelItem(nItemIdx, BijobIdx, BijobIdx2: integer);
    procedure ClientOpenArk(nItemIdx, KeyIdx: integer);
    procedure ClientOpenArkEx(nItemIdx, KeyIdx: integer);
    procedure ClientOpenMove();
    procedure ClientOpenItem();
    procedure ClientGetTaxisList(nIdx, njob, nPage: integer);
    procedure ClientGetShopItems(Msg: string);
    procedure ClientGetCloseShop();
    procedure ClientGetWineitems(Msg: string;nMakeWineidx:Integer);
    procedure SendChangeShop(BaseObject: TBaseObject; boShop: Boolean);
    function CheckItemState(UserItem: pTUserItem; nValType: Integer; boMsg:
      Boolean): Boolean;
    procedure SetItemState(UserItem: pTUserItem; nValType: Integer; nRate:
      Integer);

  end;
{$ENDREGION}

implementation

uses M2Share, Guild, HUtil32, EDcode, ObjNpc, IdSrvClient, Event,ObjMon, LocalDB,
    Castle, EncryptUnit, svMain, Shopping, InfinityStorage, PlugFun, DES,ObjMon4,
    PlugShare, ObjClone;

{ TBaseObject }
{$REGION 'TBaseObject.Create'}
constructor TBaseObject.Create; //4B780C
var
  I: Integer;
begin
  try
    m_dwMagicDeDingTick := GetTickCount;
    m_MissIonEx := False;
    m_boRun := False;
    m_boAutoGhost := False;
    m_AllMaster := nil;
    m_Clone := nil;
    m_CloneHum := nil;
    m_boShop := False;
    m_sShopMsg := '';
    m_boHero := False; //是否英雄
    m_CreateHeroName := ''; //待创建英雄名称
    m_HeroName := ''; //英雄名称
    m_Hero := nil; // 英雄对像
    m_HeroHuman := nil;
    m_HeroLocked := nil;
    m_HeroboLocked := False;
    m_MeteorRainTime := GetTickCount;
    m_HeroCallTime := 0;
    m_HeroProtectX := -1;
    m_HeroProtectY := -1;
    m_HeroProtect := False; //英雄守护
    m_HeroBagCount := 10;
    m_HeroFireTick := GetTickCount;
    m_HeroLongSword := GetTickCount;
    m_HeroEatItemsTime := GetTickCount;
    m_HeroPickItem := nil;
    m_HeroPickItemMap := nil;
    m_HeroAutoDong := False;
    m_HeroCallMob := 2;
    m_HeroDanderCount := 0;
    m_HeroAutoDanderTick := GetTickCount;
    m_HeroDanderOk := False;
    m_HeroboDanderDel := False;
    m_HeroJointAttackOk := False;
    m_HeroJointAttackTime := GetTickCount;

    m_HeroAmu51Porc := nil;
    m_HeroAmu55Porc := nil;
    m_HeroAmu11Porc := nil;
    m_HeroAmu21Porc := nil;
    m_HeroAttackAmuPorc := nil;
    m_HeroAmuHintTime := GetTickCount;
    //m_HeroPickItemX         := -1;
    //m_HeroPickItemY         := -1;

    for I := Low(m_HeroMagic) to High(m_HeroMagic) do
      //置英雄所学技能为假
      m_HeroMagic[I] := nil;

    m_HeroJointAttack := nil;
    m_boGhost := False;
    m_dwGhostTick := 0;
    m_boDeath := False;
    m_dwDeathTick := 0;
    m_dwDeathTickEx := 0;
    m_SendRefMsgTick := GetTickCount();
    m_btDirection := 4;
    m_btRaceServer := RC_ANIMAL;
    m_btRaceImg := 0;
    m_btHair := 0;
    m_btJob := jWarr;
    m_nGold := 0;
    m_wAppr := 0;
    bo2B92 := True;
    m_nViewRange := 5;
    // m_nViewRange2           := g_Config.nMagicAttackRage;
    m_sHomeMap := '0';
    //  bo942                    := False;
    m_btPermission := 0;
    m_nLight := 0;
    m_btNameColor := 255;
    m_btChangeNameColor := 255;
    m_CallCloneTick := 0;
    FillChar(m_nIconIdx, SizeOf(m_nIconIdx), 0);
    m_nHitPlus := 0;
    m_nHitDouble := 0;
    m_dBodyLuck := 0;
    m_wGroupRcallTime := 0;
    m_dwGroupRcallTick := GetTickCount();
    m_boRecallSuite := False;
    m_boCloneNoDropItem := False;
    //  bo245                   := False;
    m_boTestGa := False;
    m_boGsa := False;
    bo2BA2 := False;
    m_boAbilSeeHealGauge := False;
    m_boPowerHit := False;
    m_boUseThrusting := False;
    m_boUseHalfMoon := False;
    m_boRedUseHalfMoon := False;
    m_boFireHitSkill := False;
    m_boLongFireHitSkill := False;
    m_boTwinHitSkill := False;
    m_boTwinHitSkill2 := False;
    m_boLongSwordSkill := False;
    m_boLongSwordSkillCls := False;
    m_btHitPoint := 5;
    m_btSpeedPoint := 15;
    m_nHitSpeed := 0;
    m_btLifeAttrib := 0;
    m_btAntiPoison := 0;
    m_nPoisonRecover := 0;
    m_nHealthRecover := 0;
    m_nSpellRecover := 0;
    m_nAntiMagic := 0;
    m_nLuck := 0;
    m_nIncSpell := 0;
    m_nIncHealth := 0;
    m_nIncHealing := 0;
    m_btDiploidRate := 0;
    m_boDiploid := False;
    m_nIncHPStoneTime := GetTickCount;
    m_nIncMPStoneTime := GetTickCount;
    m_nPerHealth := 5;
    m_nPerHealing := 5;
    m_nPerSpell := 5;
    m_dwIncHealthSpellTick := GetTickCount();
    m_btGreenPoisoningPoint := 0;
    m_nFightZoneDieCount := 0;
    m_boFlagCheck := False;

    m_btThrough := 255; //穿怪模式
    m_dwThroughTick := 0;

    //  m_nGoldMax       := 5000000;
    m_nGoldMax := g_Config.nHumanMaxGold;
    m_nCharStatus := 0;
    m_nCharStatusEx := 0;
    m_Helmet := 0;
    FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0); //004B7A83
    FillChar(m_BonusAbil, SizeOf(TNakedAbility), #0);
    //FillChar(m_CurBonusAbil, SizeOf(TNakedAbility), #0);

    FillChar(m_wStatusArrValue, Sizeof(m_wStatusArrValue), 0);
    FillChar(m_dwStatusArrTimeOutTick, SizeOf(m_dwStatusArrTimeOutTick), #0);
    m_boAllowGroup := False;
    m_boAllowAddGroup := False;
    m_boAllowGuild := False;
    btB22 := 0;
    m_btAttatckMode := 0;
    m_boInFreePKArea := False;
    m_boGuildWarArea := False;
    bo2B02 := False;
    m_boSuperMan := False;
    m_boSkeleton := False;
    bo2BF2 := False;
    m_boHolySeize := False;
    m_boCrazyMode := False;
    m_boShowHP := False;
    bo2F0 := False;
    m_boAnimal := False;
    m_boNoItem := False;
    m_nBodyLeathery := 50;
    m_boFixedHideMode := False;
    m_boStickMode := False;
    m_boNoAttackMode := False;
    m_boNoTame := False;
    m_boPKFlag := False;
    m_nMoXieSuite := 0;
    m_nHongMoSuite := 0;
    //  m_db3B0                 := 0;
    FillChar(m_AddAbil, SizeOf(TAddAbility), 0);
    FillChar(m_TempAbil, SizeOf(TTempAddAbil) * 10, 0);
    m_MsgList := TList.Create;
    m_VisibleHumanList := TList.Create;
    //LIst_3EC                := TList.Create;
    m_VisibleActors := TList.Create;
    m_VisibleItems := TList.Create;
    m_VisibleEvents := TList.Create;
    m_ItemList := TList.Create;
    //m_CustomDataList        := TList.Create;
    m_DealItemList := TList.Create;
    m_ShopItemList := TList.Create;
    m_boIsVisibleActive := False;
    m_nProcessRunCount := 0;
    m_nProcessSearchCount := 10;
    m_nDealGolds := 0;
    m_MagicList := TList.Create;
    m_StorageItemList := TList.Create;
    FillChar(m_UseItems, SizeOf(THumanUseItems), 0);
    m_MagicOneSwordSkill := nil;
    m_MagicPowerHitSkill := nil;
    m_MagicErgumSkill := nil;
    m_MagicBanwolSkill := nil;
    m_MagicRedBanwolSkill := nil;
    m_MagicFireSwordSkill := nil;
    m_MagicLongFireSwordSkill := nil;
    m_MagicCrsSkill := nil;
    m_Magic41Skill := nil;
    m_MagicTwnHitSkill := nil;
    m_MagicLongSwordSkill := nil;
    m_MagicShieldSkill := nil;
    m_GroupOwner := nil;
    m_Castle := nil;
    m_Master2 := nil;
    n2942 := 0;
    m_btSlaveExpLevel := 0;
    //  bt2A02                   := 0;
    m_GroupMembers := TStringList.Create;
    m_boHearWhisper := True;
    m_boBanShout := True;
    m_boBanGuildChat := True;
    m_boAllowDeal := True;
    m_boAllowGroupReCall := False;
    m_BlockWhisperList := TStringList.Create;
    m_SlaveList := TList.Create;
    FillChar(m_WAbil, SizeOf(TAbility), 0);
    //FillChar(m_QuestUnitOpen, SizeOf(TQuestUnit),0);
    //FillChar(m_QuestUnit,SizeOf(TQuestUnit),0);
    m_Abil.Level := 1;
    m_Abil.AC := 0;
    m_Abil.MAC := 0;
    m_Abil.DC := MakeLong(1, 4);
    m_Abil.MC := MakeLong(1, 2);
    m_Abil.SC := MakeLong(1, 2);
    m_Abil.HP := 15;
    m_Abil.MP := 15;
    m_Abil.MaxHP := 15;
    m_Abil.MaxMP := 15;
    m_Abil.Exp := 0;
    m_Abil.MaxExp := 50;
    m_Abil.Weight := 0;
    m_Abil.MaxWeight := 100;
    m_boWantRefMsg := False;
    m_boDealing := False;
    m_DealCreat := nil;
    m_MyGuild := nil;
    m_nGuildRankNo := 0;
    m_sGuildRankName := '';
    m_sScriptLable := '';
    m_boMission := False;
    m_boHideMode := False;
    m_boStoneMode := False;
    m_boCoolEye := False;
    m_boUserUnLockDurg := False;
    m_boTransparent := False;
    m_boAdminMode := False;
    m_boObMode := False;
    m_dwRunTick := GetTickCount + LongWord(Random(1500));
    m_nRunTime := 250;
    m_dwSearchTime := Random(2000) + 2000;
    m_dwSearchTick := GetTickCount;
    m_dwDecPkPointTick := GetTickCount;
    m_DecLightItemDrugTick := GetTickCount();
    m_dwPoisoningTick := GetTickCount;
    m_dwVerifyTick := GetTickCount();
    m_dwCheckRoyaltyTick := GetTickCount();
    m_dwDecHungerPointTick := GetTickCount();
    m_dwHPMPTick := GetTickCount();
    m_dwShoutMsgTick := 0;
    m_dwTeleportTick := 0;
    m_dwProbeTick := 0;
    m_dwSkill82Tick:=0;
    m_dwMapMoveTick := GetTickCount();
    m_dwMasterTick := 0;
    m_nWalkSpeed := 1400;
    m_nNextHitTime := 2000;
    m_nWalkCount := 0;
    m_dwWalkWaitTick := GetTickCount();
    m_boWalkWaitLocked := False;
    m_nHealthTick := 0;
    m_nSpellTick := 0;
    m_TargetCret := nil;
    m_LastHiter := nil;
    m_ExpHitter := nil;
    m_SayMsgList := nil;
    m_boDenyRefStatus := False;
    m_btHorseType := 0;
    m_btDressEffType := 0;
    m_dwPKDieLostExp := 0;
    m_nPKDieLostLevel := 0;
    m_boAddToMaped := False;
    m_boDelFormMaped := True;
    m_boAutoChangeColor := False;
    m_dwAutoChangeColorTick := GetTickCount();
    m_nAutoChangeIdx := 0;

    m_boFixColor := False;
    m_nFixColorIdx := 0;
    m_nFixStatus := -1;
    m_boFastParalysis := False;

    m_boNastyMode := False;
    m_boOpenShield := False;
    m_dwOpenShieldTick := 0;
    m_dwOpenShieldTime := 0;
    m_dwOpenShieldShowTime := GetTickCount;


    m_MagicSkill83:=nil;
    m_MagicSkill84:=nil;
    m_skill84Abil:=0;
    FillChar(m_MedicineAbil, Sizeof(m_MedicineAbil), 0);
    FillChar(m_MedicineAbilTemp, Sizeof(m_MedicineAbilTemp), 0);
    FillChar(m_MedicineAbilArrTimeOutTick, Sizeof(m_MedicineAbilArrTimeOutTick), 0);
    FillChar(m_SKILL83Rec,SizeOf(TSKILL83Rec),0); //先天元力
    FillChar(m_RUNKarray, Sizeof(m_RUNKarray), 0); //酒醉了减魔法躲避 体力恢复
    m_boRUNK:=False;//是否醉酒过

    m_WineRec.WineValue:= 0;//酒量值
    m_WineRec.Alcoho:= 0;//饮酒量

    m_MedicineRec.MedicineLevel:= 0;//药力等级
    m_MedicineRec.MedicineValue:= 0;//当前药力值
    m_MedicineRec.MaxMedicineValue:=0;//当前等级药力值升级值

    m_SKILL84Rec.SKILL84Level:= 0;//酒气护体等级
    m_SKILL84Rec.SKILL84Exp:= 0;//酒气护体经验
    m_SKILL84Rec.MaxSKILL84Exp:=0;//当前等级酒气护体升级经验

    m_boISONMAKEWINE:= 0;//是否在酒 0没有1普通2药酒
    m_boNPCMOVE:=False;//是否在执行NPC移动操作
    m_dtGetGuildFountain:= 0; //领取行会泉水时间
    m_dtGetCastleFountain:=0; //领沙城泉水时间
    m_dtMakeWineTime:= 0;//开始酿酒的时间
    FillChar(m_WineItem,SizeOf(TUserItem),#0);//酿造的酒
    FillChar(m_WineItems,SizeOf(TUserItem)*7,#0);//酿酒的物品

    m_boskill84open:=False;//是否打开酒气护体
    m_dwskill84Time:=0;//使用酒气护体时间值

    m_dtAlcohoTime:=0;//饮普通酒时间
    m_dtMedicineAlcohoTime:=0;//饮药酒时间
    m_bLiquorProgress:=0;//酒量提升进度值
    m_dwSpeedupAlcoholTick:=0;//临昨属性酒量提升速度
    m_dwLiquorProgressTime:=0;//酒量提升时间
    m_dwdecDrunkScale:=0;
    m_dwnDRUNKTick:=0;//显示醉酒状态间隔
    m_bomapFOUNTAIN:=False; //是不是站在泉水上
    FOUNTAINEvent:=nil;
    m_GetfountainTick:=0;
  except
    MainOutMessage('[Exception] TBaseObject.Create');
  end;
end;
{$ENDREGION}

{$REGION 'TBaseObject.Destroy}
destructor TBaseObject.Destroy; //004B80C0
var
  I: Integer;
  SendMessage: pTSendMessage;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::Destroy Code: %d %s';
begin
  try
    nCheckCode := 0;
    try
      nCheckCode := 1;
      for I := 0 to m_MsgList.Count - 1 do
      begin
        nCheckCode := 2;
        SendMessage := m_MsgList.Items[I];
        if (SendMessage.wIdent = RM_SENDDELITEMLIST) and (SendMessage.nParam1 <>
          0) then
        begin
          nCheckCode := 3;
          if TStringList(SendMessage.nParam1) <> nil then
          begin
            TStringList(SendMessage.nParam1).Free;
            nCheckCode := 4;
          end;
        end;
        if (SendMessage.wIdent = RM_10401) and (SendMessage.nParam1 <> 0) then
        begin
          nCheckCode := 5;
          Dispose(pTSlaveInfo(SendMessage.nParam1));
        end;
        nCheckCode := 6;
        if (SendMessage.Buff <> nil) then
        begin
          nCheckCode := 7;
          FreeMem(SendMessage.Buff);
        end;
        Dispose(SendMessage);
        nCheckCode := 8;
      end; //004B81EE
      nCheckCode := 9;
      m_MsgList.Free;
      nCheckCode := 10;
      m_VisibleHumanList.Free;
      nCheckCode := 12;
      for i := 0 to m_VisibleActors.Count - 1 do
      begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end; //004B8296
      nCheckCode := 13;
      m_VisibleActors.Free;
      nCheckCode := 14;
      for i := 0 to m_VisibleItems.Count - 1 do
      begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
      end; //004B82E3
      nCheckCode := 15;
      m_VisibleItems.Free;
      nCheckCode := 16;
      m_VisibleEvents.Free;
      nCheckCode := 17;
      for i := 0 to m_ItemList.Count - 1 do
      begin
        Dispose(PTUserItem(m_ItemList.Items[i]));
      end; //004B833E
      nCheckCode := 18;
      m_ItemList.Free;
      nCheckCode := 19;
      for i := 0 to m_DealItemList.Count - 1 do
      begin
        Dispose(pTUserItem(m_DealItemList.Items[i]));
      end; //004B838B
      m_DealItemList.Free;
      nCheckCode := 20;
      for i := 0 to m_MagicList.Count - 1 do
      begin
        Dispose(pTUserMagic(m_MagicList.Items[i]));
      end; //004B83D8
      m_MagicList.Free;
      nCheckCode := 21;
      for i := 0 to m_StorageItemList.Count - 1 do
      begin
        Dispose(pTUserItem(m_StorageItemList.Items[i]));
      end; //004B8425
      m_StorageItemList.Free;
      nCheckCode := 22;
      m_GroupMembers.Free;
      nCheckCode := 23;
      m_BlockWhisperList.Free;
      nCheckCode := 24;
      m_SlaveList.Free;
      nCheckCode := 25;
      for I := 0 to m_ShopItemList.Count - 1 do
      begin
        Dispose(pTUserShopItem(m_ShopItemList.Items[i]));
      end;
      nCheckCode := 26;
      m_ShopItemList.Free;
      //nCheckCode:=27;
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg, [nCheckCode, m_sCharName]));
        MainOutMessage(E.Message);
      end;
    end;
    {
    for I := 0 to CertCheck.Count - 1 do begin
      if CertCheck.Items[I] = Self then begin
        CertCheck.Delete(I);
        break;
      end;
    end;
    }
    inherited;
  except
    MainOutMessage('[Exception] TBaseObject.Destroy');
  end;
end;
{$ENDREGION}

{$REGION 'TBaseObject.ChangePKStatus'}
procedure TBaseObject.ChangePKStatus(boWarFlag: Boolean); //004B84C8
begin
  try
    if m_boInFreePKArea <> boWarFlag then
    begin
      m_boInFreePKArea := boWarFlag;
      m_boNameColorChanged := True;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.ChangePKStatus');
  end;
end;
{$ENDREGION}

{$REGION 'TBaseObject.GetDropPosition'}
  function TBaseObject.GetDropPosition(nOrgX, nOrgY, nRange: Integer; var nDX:
    Integer; var nDY: Integer): Boolean; //004C5238
  var
    i, ii, iii: Integer;
    nItemCount, n24, n28, n2C: integer;
  begin
    Result := False;
    try
      n24 := 999;
      n28 := 0; //09/10
      n2C := 0; //09/10
      for I := 1 to nRange do
      begin
        for II := -I to I do
        begin
          for III := -I to I do
          begin
            nDX := nOrgX + III;
            nDY := nOrgY + II;
            if m_PEnvir.GetItemEx(nDX, nDY, nItemCount) = nil then
            begin
              if m_PEnvir.bo2C then
              begin
                Result := True;
                break;
              end;
            end
            else
            begin
              if m_PEnvir.bo2C and (n24 > nItemCount) then
              begin
                n24 := nItemCount;
                n28 := nDX;
                n2C := nDY;
              end;
            end;
          end;
          if Result then
            break;
        end;
        if Result then
          break;
      end;
      if not Result then
      begin
        if n24 < 8 then
        begin
          nDX := n28;
          nDY := n2C;
        end
        else
        begin
          nDX := nOrgX;
          nDY := nOrgY;
        end;
      end;
    except
      MainOutMessage('[Exception] TBaseObject.GetDropPosition');
    end;
  end;
  
{$ENDREGION}

{$REGION 'TBaseObject.DropItemDownEx'}
  function TBaseObject.DropItemDownEx(UserItem: pTUserItem; nScatterRange:
    Integer; Envir: TEnvirnoment; X, Y: Integer): Boolean;
  var
    dx, dy, idura: integer;
    MapItem, pr: pTMapItem;
    StdItem: TItem;
    logcap: string;
  begin
    Result := FALSE;
    try
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        if StdItem.StdMode = 40 then
        begin
          idura := UserItem.Dura;
          idura := idura - 2000;
          if idura < 0 then
            idura := 0;
          UserItem.Dura := idura;
        end;
  
        New(MapItem);
        MapItem.UserItem := UserItem^;
        MapItem.Name := GetItemName(UserItem); //取自定义物品名称
  
        MapItem.Looks := StdItem.Looks;
        if StdItem.StdMode = 45 then
        begin //林荤困, 格犁
          MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
        end;
        MapItem.AniCount := StdItem.AniCount;
        MapItem.Reserved := 0;
        MapItem.Count := 1;
        MapItem.OfBaseObject := nil;
        MapItem.dwCanPickUpTick := GetTickCount();
        MapItem.DropBaseObject := nil;
        GetDropPosition(X, Y, nScatterRange, dx, dy);
        pr := Envir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
        if pr = MapItem then
        begin
          SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), dx, dy,
            MapItem.Name);
          logcap := '7';
          if not IsCheapStuff(StdItem.StdMode) then
            //004C5716
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog(logcap + #9 +
                m_sMapName + #9 +
                IntToStr(X) + #9 +
                IntToStr(Y) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(ui.wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                '0');
          Result := TRUE;
        end
        else
        begin
          Dispose(MapItem);
        end;
      end;
    except
      MainOutMessage('[Exception] TBaseObject.DropItemDownEx');
    end;
  end;
{$ENDREGION}
//004C5478

{$REGION 'TBaseObject.DropItemDown'}
  function TBaseObject.DropItemDown(UserItem: pTUserItem; nScatterRange: Integer;
    boDieDrop: Boolean; ItemOfCreat, DropCreat: TBaseObject; boHint: Boolean =
    True): Boolean;
  var
    dx, dy, idura: integer;
    MapItem, pr: pTMapItem;
    StdItem: TItem;
    logcap: string;
    sMyInfo: string;
  begin
    Result := FALSE;
    try
  
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        if StdItem.StdMode = 40 then
        begin
          idura := UserItem.Dura;
          idura := idura - 2000;
          if idura < 0 then
            idura := 0;
          UserItem.Dura := idura;
        end;
  
        New(MapItem);
        MapItem.UserItem := UserItem^;
        MapItem.Name := GetItemName(UserItem); //取自定义物品名称
  
        MapItem.Looks := StdItem.Looks;
        if StdItem.StdMode = 45 then
        begin //林荤困, 格犁
          MapItem.Looks := GetRandomLook(MapItem.Looks, StdItem.Shape);
        end;
        MapItem.AniCount := StdItem.AniCount;
        MapItem.Reserved := 0;
        MapItem.Count := 1;
        MapItem.OfBaseObject := ItemOfCreat;
        MapItem.dwCanPickUpTick := GetTickCount();
        MapItem.DropBaseObject := DropCreat;
        if m_MissIonEx then
        begin
          if (ItemOfCreat <> nil) then
          begin
            GetDropPosition(ItemOfCreat.m_nCurrX, ItemOfCreat.m_nCurrY,
              nScatterRange, dx, dy);
          end
          else if m_Master2 <> nil then
          begin
            GetDropPosition(m_Master2.m_nCurrX, m_Master2.m_nCurrY, nScatterRange,
              dx, dy);
          end
          else
            GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy);
  
          MapItem.OfBaseObject := m_Master2;
        end
        else
          GetDropPosition(m_nCurrX, m_nCurrY, nScatterRange, dx, dy);
        if boHint and StdItem.nRule[RULE_DROPHINT] then
        begin
          sMyInfo := sDropItemHintMsg;
          sMyInfo := AnsiReplaceText(sMyInfo, '%s', Stditem.Name);
          if DropCreat <> nil then
          begin
            if DropCreat.m_btRaceServer = RC_PLAYOBJECT then
              sMyInfo := AnsiReplaceText(sMyInfo, '%name', DropCreat.m_sCharName)
            else
              sMyInfo := AnsiReplaceText(sMyInfo, '%name',
                FilterShowName(DropCreat.m_sCharName));
          end
          else
            sMyInfo := AnsiReplaceText(sMyInfo, '%name', '');
          sMyInfo := AnsiReplaceText(sMyInfo, '%m', m_PEnvir.sMapDesc);
          sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(dx));
          sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(dy));
          UserEngine.SendBroadCastMsgExt(sMyInfo, t_System);
        end;
        pr := m_PEnvir.AddToMap(dx, dy, OS_ITEMOBJECT, TObject(MapItem));
        if pr = MapItem then
        begin
          SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), dx, dy,
            MapItem.Name);
          if boDieDrop then
            logcap := '15'
          else
            logcap := '7';
          if not IsCheapStuff(StdItem.StdMode) then
            //004C5716
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog(logcap + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(ui.wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                '0');
          Result := TRUE;
        end
        else
        begin
          Dispose(MapItem);
        end;
      end;
    except
      MainOutMessage('[Exception] TBaseObject.DropItemDown');
    end;
  end;
{$ENDREGION}

{$REGION 'TBaseObject.GoldChanged'}
  procedure TBaseObject.GoldChanged(); //004C49F4
  begin
    try
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
      end;
    except
      MainOutMessage('[Exception] TBaseObject.GoldChanged');
    end;
  end;
  
{$ENDREGION}

{$REGION 'TBaseObject.GameGoldChanged'}
  procedure TBaseObject.GameGoldChanged(); //004C49F4
  begin
    try
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        SendUpdateMsg(Self, RM_GAMEGOLDCHANGED, 0, 0, 0, 0, '');
      end;
    except
      MainOutMessage('[Exception] TBaseObject.GameGoldChanged');
    end;
  end;
{$ENDREGION}

{$REGION 'TPlayObject.IsSelf'}
  function TPlayObject.IsSelf(BaseObject: TBaseObject): Boolean;
  begin
    Result := False;
    try
      try
        if (BaseObject = nil) or (Self = BaseObject) or (BaseObject = m_AllMaster)
          then
          Result := True
        else
          Result := False;
      except
        MainOutMessage('[Exception] TPlayObject.IsSelf');
      end;
    except
      MainOutMessage('[Exception] TPlayObject.IsSelf');
    end;
  end;
{$ENDREGION}

function TPlayObject.IsOfGroup(BaseObject: TBaseObject): Boolean;
var
  I: Integer;
  GroupMember: TBaseObject;
begin
  Result := False;
  try
    if m_GroupOwner = nil then
      exit;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      GroupMember := TBaseObject(m_GroupOwner.m_GroupMembers.Objects[i]);
      if GroupMember = BaseObject then
      begin
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.IsOfGroup');
  end;
end;

function TPlayObject.ClientPickUpItem: Boolean; //004C5CB0

var
  UserItem: PTUserItem;
  MapItem: pTMapItem;
  StdItem: TItem;
  //  PlayObject:TPlayObject;
begin
  Result := False;
  try
    if m_boDealing then
      exit;
    MapItem := m_PEnvir.GetItem(m_nCurrX, m_nCurrY);
    if MapItem = nil then
      exit;

    if (GetTickCount - MapItem.dwCanPickUpTick) >
      g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then
    begin
      MapItem.OfBaseObject := nil;
    end;
    if not IsSelf(TBaseObject(MapItem.OfBaseObject)) and
      //not IsHero(TBaseObject(MapItem.OfBaseObject)) and
    not IsOfGroup(TBaseObject(MapItem.OfBaseObject)) then
    begin
      SysMsg(g_sCanotPickUpItem
        {'在一定时间以内无法捡起此物品！！！'}, c_Red, t_Hint);
      exit;
    end;
    if CompareText(MapItem.Name, sSTRING_GOLDNAME) = 0 then
    begin
      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT,
        TObject(MapItem)) = 1 then
      begin
        if m_boHero then
        begin
          if (m_HeroHuman <> nil) and
            TPlayObject(m_HeroHuman).IncGold(MapItem.Count) then
          begin
            m_HeroHuman.SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX,
              m_nCurrY, '');
            if g_boGameLogGold then //004C5E8C
              AddGameDataLog('4' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                sSTRING_GOLDNAME + #9 +
                IntToStr(MapItem.Count) + #9 +
                '1' + #9 +
                '0');
            m_HeroHuman.GoldChanged;
            Dispose(MapItem);
          end
          else
            m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT,
              TObject(MapItem));
        end
        else
        begin
          if IncGold(MapItem.Count) then
          begin
            SendRefMsg(RM_ITEMHIDE, 0, Integer(MapItem), m_nCurrX, m_nCurrY,
              '');
            if g_boGameLogGold then //004C5E8C
              AddGameDataLog('4' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                sSTRING_GOLDNAME + #9 +
                IntToStr(MapItem.Count) + #9 +
                '1' + #9 +
                '0');
            GoldChanged;
            Dispose(MapItem);
          end
          else
            m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT,
              TObject(MapItem));
        end;
      end;
      exit;
    end;

    if IsEnoughBag then
    begin
      if m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT,
        TObject(MapItem)) = 1 then
      begin
        New(UserItem);
        UserItem^ := MapItem.UserItem;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if (StdItem <> nil) and
          IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex))
            then
        begin
          SendMsg(self, RM_ITEMHIDE, 0, integer(MapItem), m_nCurrX, m_nCurrY,
            '');
          AddItemToBag(UserItem);

          if not IsCheapStuff(StdItem.StdMode) then
            if StdItem.NeedIdentify = 1 then //004C60FF
              AddGameDataLog('4' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(pu.wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(UserItem.MakeIndex) + #9 +
                '1' + #9 +
                '0');
          Dispose(MapItem);
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            SendAddItem(UserItem);
            if StdItem.nRule[RULE_MAKE] then
            begin
              m_ServerStrVal[2] := StdItem.Name;
              NpcGotoLable(g_FunctionNPC, '@PickUpItem', False);
            end;
            MapEventCheck(OS_PICKUPITEM, StdItem.Name); //地图事件触发
          end;
          Result := TRUE;
        end
        else
        begin
          Dispose(UserItem);
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_ITEMOBJECT,
            TObject(MapItem));
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientPickUpItem:');
  end;
end;

procedure TPlayObject.RunNotice; //004DA588
var
  Msg: TProcessMessage;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::RunNotice';
begin
  try
    if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then
    begin
      if m_boKickFlag then
        SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
      MakeGhost();
    end
    else
    begin
      try
        if not m_boSendNotice then
        begin
          RunSocket.CheckConnectUser(m_nGateIdx, m_nSocket);
          SendNotice();
          m_boSendNotice := True;
          m_dwWaitLoginNoticeOKTick := GetTickCount();
        end
        else
        begin
          if GetTickCount - m_dwWaitLoginNoticeOKTick > 30 * 1000 then
          begin
            SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
            m_boEmergencyClose := True;
          end;

          while GetMessage(@Msg) do
          begin
            if (msg.wIdent = CM_LOGINNOTICEOKEX) or (msg.wIdent =
              CM_LOGINNOTICEOK) then
            begin
              if g_Config.boCanVipClientLogon then
              begin
                if (msg.wIdent = CM_LOGINNOTICEOKEX) and (msg.wParam = 3) then
                begin
                  m_boLoginNoticeOK := True;
                  m_dwClientTick := Msg.nParam1;
                  if LoByte(msg.nParam2) = msg.nParam3 then
                    m_dwClientTickEx := Msg.nParam1 + 1
                  else
                    m_dwClientTickEx := 0;
                end
                else
                begin
                  SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
                  m_boEmergencyClose := True;
                end;
              end
              else
              begin
                if msg.wIdent = CM_LOGINNOTICEOKEX then
                begin
                  m_boLoginNoticeOK := True;
                  m_dwClientTick := Msg.nParam1;
                  if LoByte(msg.nParam2) = msg.nParam3 then
                    m_dwClientTickEx := Msg.nParam1 + 1
                  else
                    m_dwClientTickEx := 0;
                end
                else if msg.wIdent = CM_LOGINNOTICEOK then
                begin
                  m_boLoginNoticeOK := True;
                  m_dwClientTick := Msg.nParam1;
                  if LoByte(msg.nParam2) = msg.nParam3 then
                    m_dwClientTickEx := Msg.nParam1 + 1
                  else
                    m_dwClientTickEx := 0;
                end;
              end;
            end;
          end;
        end;
      except
        MainOutMessage(sExceptionMsg);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.RunNotice');
  end;
end;

procedure TPlayObject.WinExp(dwExp: LongWord);
begin
  try
    if m_boHero then
    begin
      if m_HeroHuman <> nil then
        TPlayObject(m_HeroHuman).WinExp(dwExp);
      exit;
    end;
    dwExp := g_Config.dwKillMonExpMultiple * dwExp;
    //系统指定杀怪经验倍数
    dwExp := LongWord(m_nKillMonExpMultiple) * dwExp;
    //人物指定的杀怪经验倍数

    dwExp := ROUND((m_nKillMonExpRate / 100) * dwExp);
    //人物指定的杀怪经验倍数
    dwExp := Round((m_nSuitMonExpRate / 10) * dwExp);
    //套装指定的杀怪经验倍数
    if m_PEnvir.Flag.boEXPRATE then
      dwExp := ROUND((m_PEnvir.Flag.nEXPRATE / 100) * dwExp);
    //地图上指定杀怪经验倍数

    if m_boExpItem then
    begin //物品经验倍数
      dwExp := ROUND(m_rExpItem * dwExp);
    end;
    GetExp(dwExp);
  except
    MainOutMessage('[Exception] TPlayObject.WinExp');
  end;
end;

procedure TPlayObject.GetExp(dwExp2: LongWord; boHero: Boolean = False);
//004BEB74
var
  Exp: LongWord;
begin
  try
    Exp := dwExp2;
    if m_boGhost or m_boDeath then
      exit;
  // MainOutmessage(Self.m_sCharName);
    if not boHero then
    begin
      if m_boHero then
      begin
        Exp := Trunc(Exp / g_Config.nHeroKillMonExp);
        if m_HeroHuman <> nil then
          TPlayObject(m_HeroHuman).GetExp(dwExp2, True);
      end
      else
      begin
        if (m_Hero <> nil) and
          (m_PEnvir = m_Hero.m_PEnvir) and
          (abs(m_nCurrX - m_Hero.m_nCurrX) < 10) and
          (abs(m_nCurrY - m_Hero.m_nCurrY) < 10) then
          TPlayObject(m_Hero).GetExp(Trunc(Exp / g_Config.nHeroKillMonExp),
            True);
      end;
    end;

    //080608英雄经验是从人物分享还是共享
    if (m_Hero <> nil) and g_Config.boHeroExpMode then
      Exp := Exp - Trunc(Exp / g_Config.nHeroKillMonExp);

    if m_MagicSkill84<>nil then //酒气护体
    begin
     Inc(m_SKILL84Rec.SKILL84Exp,Exp);
     if m_SKILL84Rec.SKILL84Exp>=m_SKILL84Rec.MaxSKILL84Exp then
     begin
       Inc(m_SKILL84Rec.SKILL84Level);

       if m_SKILL84Rec.SKILL84Level>g_Config.nskill84MaxLevel then //限制最大等级
         m_SKILL84Rec.SKILL84Level:=g_Config.nskill84MaxLevel;

       m_SKILL84Rec.SKILL84Exp:=m_SKILL84Rec.SKILL84Exp-m_SKILL84Rec.MaxSKILL84Exp;
       m_SKILL84Rec.MaxSKILL84Exp:=Getskill84LevelExp(m_SKILL84Rec.SKILL84Level);//酒气护身升级经验
     end;

     SendMsg(Self, RM_SKILL84Exp, 0, 0, 0, 0, '');
    end;

    if (m_boHero and (m_Abil.Level >= g_Config.nHeroMaxLevel)) or
    ((not m_boHero) and (m_Abil.Level >= g_Config.nPlayMaxLevel)) then
    exit; //最高等级限制

     Inc(m_Abil.Exp, Exp);

    if m_boHero then
    begin
      Inc(m_dwHeroAllExp, Exp);
      if (g_Config.nHeroFealtyExp > 0) and
        (g_Config.nHeroFealtyExpAdd > 0) and
        (m_nGloryPoint < 10000) and
        (m_dwHeroAllExp >= g_Config.nHeroFealtyExp) then
      begin
        HeroChangeGlory(g_Config.nHeroFealtyExpAdd, 0);
        m_dwHeroAllExp := 0;
      end;
    end;
    AddBodyLuck(Exp * 0.002);
    SendMsg(Self, RM_WINEXP, 0, Exp, 0, 0, '');

    if m_Abil.Exp >= m_Abil.MaxExp then
    begin
      Dec(m_Abil.Exp, m_Abil.MaxExp);

      if m_Abil.Level < MAXUPLEVEL then
      begin
        Inc(m_Abil.Level);
      end;

      HasLevelUp(m_Abil.Level - 1);
      AddBodyLuck(100);

      IncHealthSpell(High(Word), High(Word));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetExp');
  end;
end;

procedure TBaseObject.RecalcLevelAbilitys(); //004BF7DC
var
  nLevel, n: integer;
begin
  try
{$IF OEMVER = OEM775}

{$ELSE}
    nLevel := m_Abil.Level;
    case m_btJob of
      jTaos:
        begin
          //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 6 + 2.5) * nLevel));
          m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
            g_Config.nLevelValueOfTaosHP + g_Config.nLevelValueOfTaosHPRate) *
            nLevel)));

          //m_Abil.MaxMP:=_MIN(High(Word),13 + ROUND((nLevel / 8)* 2.2 * nLevel));
          m_Abil.MaxMP := _MIN(High(Word), 13 + ROUND(((nLevel /
            g_Config.nLevelValueOfTaosMP) * 2.2 * nLevel)));

          m_Abil.MaxWeight := 50 + ROUND((nLevel / 4) * nLevel);
          m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 50) * nLevel);
          m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 42) * nLevel);

          n := nLevel div 7;
          m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
          m_Abil.MC := 0;
          m_Abil.SC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
          m_Abil.AC := 0;

          n := ROUND(nLevel / 6);
          m_Abil.MAC := MakeLong(n div 2, n + 1);
        end;
      jWizard:
        begin
          //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 15 + 1.8) * nLevel));
          m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
            g_Config.nLevelValueOfWizardHP + g_Config.nLevelValueOfWizardHPRate)
            *
            nLevel)));

          m_Abil.MaxMP := _MIN(High(Word), 13 + ROUND((nLevel / 5 + 2) * 2.2 *
            nLevel));
          m_Abil.MaxWeight := 50 + ROUND((nLevel / 5) * nLevel);
          m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 100) * nLevel);
          m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 90) * nLevel);

          n := nLevel div 7;
          m_Abil.DC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
          m_Abil.MC := MakeLong(_MAX(n - 1, 0), _MAX(1, n));
          m_Abil.SC := 0;
          m_Abil.AC := 0;
          m_Abil.MAC := 0;
        end;
      jWarr:
        begin
          //m_Abil.MaxHP:=_MIN(High(Word),14 + ROUND((nLevel / 4.0 + 4.5 + nLevel / 20) * nLevel));
          m_Abil.MaxHP := _MIN(High(Word), 14 + ROUND(((nLevel /
            g_Config.nLevelValueOfWarrHP + g_Config.nLevelValueOfWarrHPRate +
            nLevel / 20) * nLevel)));

          m_Abil.MaxMP := _MIN(High(Word), 11 + ROUND(nLevel * 3.5));
          m_Abil.MaxWeight := 50 + ROUND((nLevel / 3) * nLevel);
          m_Abil.MaxWearWeight := 15 + ROUND((nLevel / 20) * nLevel);
          m_Abil.MaxHandWeight := 12 + ROUND((nLevel / 13) * nLevel);

          m_Abil.DC := MakeLong(_MAX((nLevel div 5) - 1, 1), _MAX(1, (nLevel div
            5)));
          m_Abil.SC := 0;
          m_Abil.MC := 0;
          m_Abil.AC := MakeLong(0, (nLevel div 7));
          m_Abil.MAC := 0;
        end;
    end;
    if m_boHero then
    begin
      if (m_Abil.MaxHP * 2) > 65535 then
      begin
        if m_Abil.HP = m_Abil.MaxHP then
          m_Abil.HP := 65535;
        m_Abil.MaxHP := 65535;
      end
      else
      begin
        if m_Abil.HP = m_Abil.MaxHP then
          Inc(m_Abil.HP, m_Abil.HP);
        Inc(m_Abil.MaxHP, m_Abil.MaxHP);
      end;
    end;
    if m_Abil.HP > m_Abil.MaxHP then
      m_Abil.HP := m_Abil.MaxHP;
    if m_Abil.MP > m_Abil.MaxMP then
      m_Abil.MP := m_Abil.MaxMP;
{$IFEND}
  except
    MainOutMessage('[Exception] TBaseObject.RecalcLevelAbilitys');
  end;
end;

procedure TBaseObject.HasLevelUp(nLevel: Integer); //004BED6C
begin
  try
    m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
    RecalcLevelAbilitys();
    RecalcAbilitys();
    SendMsg(Self, RM_LEVELUP, 0, m_Abil.Exp, 0, 0, '');
    NpcGotoLable(g_FunctionNpc, '@PlayLevelUp', False);
  except
    MainOutMessage('[Exception] TBaseObject.HasLevelUp');
  end;
end;

function TPlayObject.IncGold(tGold: Integer): Boolean; //004BF64C
begin

  Result := False;
  try
    //  if m_nGold + tGold <= BAGGOLD then begin
    if m_nGold + tGold <= g_Config.nHumanMaxGold then
    begin
      Inc(m_nGold, tGold);
      Result := True;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.IncGold');
  end;
end;

function TBaseObject.WalkTo(btDir: Byte; boFlag: boolean): Boolean; //004C3F64
var
  nOX, nOY, nNX, nNY, n20, n24: Integer;
  //Envir:TEnvirnoment;
  bo29: Boolean;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::WalkTo';
begin

  Result := False;
  try
    if m_boHolySeize then
      exit;
    try
      nOX := m_nCurrX;
      nOY := m_nCurrY;
      //    Envir:=m_PEnvir;
      m_btDirection := btDir;
      nNX := 0;
      nNY := 0;
      case btDir of
        DR_UP:
          begin
            nNX := m_nCurrX;
            nNY := m_nCurrY - 1;
          end;
        DR_UPRIGHT:
          begin
            nNX := m_nCurrX + 1;
            nNY := m_nCurrY - 1;
          end;
        DR_RIGHT:
          begin
            nNX := m_nCurrX + 1;
            nNY := m_nCurrY;
          end;
        DR_DOWNRIGHT:
          begin
            nNX := m_nCurrX + 1;
            nNY := m_nCurrY + 1;
          end;
        DR_DOWN:
          begin
            nNX := m_nCurrX;
            nNY := m_nCurrY + 1;
          end;
        DR_DOWNLEFT:
          begin
            nNX := m_nCurrX - 1;
            nNY := m_nCurrY + 1;
          end;
        DR_LEFT:
          begin
            nNX := m_nCurrX - 1;
            nNY := m_nCurrY;
          end;
        DR_UPLEFT:
          begin
            nNX := m_nCurrX - 1;
            nNY := m_nCurrY - 1;
          end;
      end;
      if (nNX >= 0) and ((m_PEnvir.Header.wWidth - 1) >= nNX) and
        (nNY >= 0) and ((m_PEnvir.Header.wHeight - 1) >= nNY) then
      begin
        bo29 := True;
        if bo2BA2 and not m_PEnvir.CanSafeWalk(nNX, nNY) then
          bo29 := False;
        if m_Master2 <> nil then
        begin
          m_Master2.m_PEnvir.GetNextPosition(m_Master2.m_nCurrX,
            m_Master2.m_nCurrY, m_Master2.m_btDirection, 1, n20, n24);
          if (nNX = n20) and (nNY = n24) then
            bo29 := False;
        end;
        if bo29 then
        begin
          if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nNX, nNY,
            boFlag) > 0 then
          begin
            m_nCurrX := nNX;
            m_nCurrY := nNY;
          end;
        end;
      end;
      if (m_nCurrX <> nOX) or (m_nCurrY <> nOY) then
      begin
        if Walk(RM_WALK) then
        begin
          if m_boTransparent and m_boHideMode then
            m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] := 1;
          Result := True;
        end
        else
        begin
          m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
          m_nCurrX := nOX;
          m_nCurrY := nOY;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.WalkTo');
  end;
end;

function TPlayObject.IsEnoughBag: Boolean; //004C4990
begin
  Result := False;
  try

    if m_boHero then
    begin
      if m_ItemList.Count < GetHeroBagCount then
        Result := True;
    end
    else if m_ItemList.Count < MAXBAGITEM then
      Result := True;
  except
    MainOutMessage('[Exception] TPlayObject.IsEnoughBag:');
  end;
end;

function TPlayObject.IsAddWeightAvailable(nWeight: Integer): Boolean; //004C4A78
begin
  Result := False;
  try

    if m_boHero then
    begin
      Result := True;
    end
    else
    begin
      if (m_WAbil.Weight + nWeight) <= m_WAbil.MaxWeight then
        Result := True;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.IsAddWeightAvailable');
  end;
end;

procedure TPlayObject.SendActionFail();
{var
  I:integer; }
begin
  try
    SendSocket(nil, sSTATUS_FAIL + IntToStr(GetTickCount));
    try
      if Assigned(m_HookSendActionFail) then
        m_HookSendActionFail(Self);
    except
      MainOutMessage('[Exception] TPlayObject.SendActionFail->HookApi');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendActionFail');
  end;
end;

procedure TPlayObject.SendActionGood();
{var
  I:integer; }
begin
  try
    SendSocket(nil, sSTATUS_GOOD + IntToStr(GetTickCount));
    try
      if Assigned(m_HookSendActionGood) then
        m_HookSendActionGood(Self);
    except
      MainOutMessage('[Exception] TPlayObject.SendActionGood->HookApi');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendActionGood');
  end;
end;

procedure TPlayObject.SendMsgItem(wIdent: Word; nRecog: Integer; nParam, nTag,
  nSeries: Word; UserItem: pTUserItem);
begin
  try
    if m_boHero then
    begin
      m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end
    else
    begin
      m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries);
      SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendMsgItem');
  end;
end;

procedure TPlayObject.SendAddItem(UserItem: pTUserItem;bShow:byte); //004D0824
begin
  try
    if m_boHero then
    begin
      m_DefMsg := MakeDefaultMsg(SM_905, Integer(Self),word(bShow), 0, 1);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end
    else
    begin
      m_DefMsg := MakeDefaultMsg(SM_ADDITEM, Integer(Self),word(bShow), 0, 1);
      SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendAddItem');
  end;
end;

function TBaseObject.IsGroupMember(target: TBaseObject): Boolean; //004C3908
var
  I: Integer;
begin
  Result := False;
  try

    if m_GroupOwner = nil then
      exit;
    for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
    begin
      if m_GroupOwner.m_GroupMembers.Objects[i] = target then
      begin
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsGroupMember');
  end;
end;

//004D1558

procedure TPlayObject.Whisper(whostr, saystr: string);
var
  PlayObject: TPlayObject;
  svidx: Integer;
begin
  try
    PlayObject := UserEngine.GeTPlayObject(whostr);
    if PlayObject <> nil then
    begin
      if not PlayObject.m_boReadyRun then
      begin
        SysMsg(whostr + g_sCanotSendmsg {'无法发送信息.'}, c_Red, t_Hint);
        exit;
      end;
      if not PlayObject.m_boHearWhisper or PlayObject.IsBlockWhisper(m_sCharName)
        then
      begin
        SysMsg(whostr + g_sUserDenyWhisperMsg {' 拒绝私聊！！！'}, c_Red,
          t_Hint);
        exit;
      end;
      if m_btPermission > 0 then
      begin
        PlayObject.SendMsg(PlayObject, RM_WHISPER, 0,
          g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0,
          m_sCharName + '=> ' + saystr);
        //取得私聊信息
        if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
          m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0,
            g_Config.btGMWhisperMsgFColor, g_Config.btGMWhisperMsgBColor, 0,
            m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + saystr);

        if (PlayObject.m_GetWhisperHuman <> nil) and (not
          PlayObject.m_GetWhisperHuman.m_boGhost) then
          PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman,
            RM_WHISPER, 0, g_Config.btGMWhisperMsgFColor,
            g_Config.btGMWhisperMsgBColor, 0, m_sCharName + '=>' +
            PlayObject.m_sCharName + ' ' + saystr);
      end
      else
      begin
        PlayObject.SendMsg(PlayObject, RM_WHISPER, 0,
          g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0,
          m_sCharName
          + '=> ' + saystr);
        if (m_GetWhisperHuman <> nil) and (not m_GetWhisperHuman.m_boGhost) then
          m_GetWhisperHuman.SendMsg(m_GetWhisperHuman, RM_WHISPER, 0,
            g_Config.btWhisperMsgFColor, g_Config.btWhisperMsgBColor, 0,
            m_sCharName + '=>' + PlayObject.m_sCharName + ' ' + saystr);

        if (PlayObject.m_GetWhisperHuman <> nil) and (not
          PlayObject.m_GetWhisperHuman.m_boGhost) then
          PlayObject.m_GetWhisperHuman.SendMsg(PlayObject.m_GetWhisperHuman,
            RM_WHISPER, 0, g_Config.btWhisperMsgFColor,
            g_Config.btWhisperMsgBColor, 0, m_sCharName + '=>' +
            PlayObject.m_sCharName + ' ' + saystr);
      end;

    end
    else
    begin
      if UserEngine.FindOtherServerUser(whostr, svidx) then
      begin
        UserEngine.SendServerGroupMsg(SS_WHISPER, svidx, whostr + '/' +
          m_sCharName + '=> ' + saystr);
      end
      else
      begin
        SysMsg(whostr + g_sUserNotOnLine {'  没有在线！！！'}, c_Red,
          t_Hint);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.Whisper');
  end;
end;
//004D199C

function TPlayObject.IsBlockWhisper(sName: string): Boolean;
var
  I: Integer;
begin
  Result := False;
  try

    for I := 0 to m_BlockWhisperList.Count - 1 do
    begin
      if CompareText(sName, m_BlockWhisperList.Strings[i]) = 0 then
      begin
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.IsBlockWhisper');
  end;
end;

function TBaseObject.PKLevel(): Integer; //004BF0A0
begin
  Result := m_nPkPoint div 100;
end;

procedure TBaseObject.HealthSpellChanged; //004C4A24
begin
  try
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      SendUpdateMsg(Self, RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
    end;
    if m_boShowHP then
    begin
      SendRefMsg(RM_HEALTHSPELLCHANGED, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TBaseObject.HealthSpellChanged');
  end;
end;

function TBaseObject.CalcGetExp(nLevel: Integer; nExp: Integer): Integer;
//004BE59F
begin
  if g_Config.boHighLevelKillMonFixExp or (m_Abil.Level < (nLevel + 10)) then
  begin
    Result := nExp;
  end
  else
  begin
    Result := nExp - ROUND((nExp / 15) * (m_Abil.Level - (nLevel + 10)));
  end;
  if Result <= 0 then
    Result := 1;
end;

procedure TBaseObject.RefNameColor(); //004BF124
begin
  try
    SendRefMsg(RM_CHANGENAMECOLOR, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.RefNameColor');
  end;
end;

procedure TBaseObject.GainSlaveExp(nLevel: Integer); //004BE8BC
  function GetUpKillCount(): Integer; //004BE864
  var
    tCount: Integer;
  begin
    if m_btSlaveExpLevel < SLAVEMAXLEVEL - 2 then
    begin
      tCount := g_Config.MonUpLvNeedKillCount[m_btSlaveExpLevel];
    end
    else
    begin
      tCount := 0;
    end;
    //    Result:= ((m_Abil.Level shl 4) - m_Abil.Level) + 100 + tCount
    Result := ((m_Abil.Level * g_Config.nMonUpLvRate {16}) - m_Abil.Level) +
      g_Config.nMonUpLvNeedKillBase {100} + tCount
  end;
  {
  var
    nNeedCount:Integer;
  }
begin
  try
    Inc(n2942, nLevel);
    if GetUpKillCount() < n2942 then
    begin
      Dec(n2942, GetUpKillCount);
      if m_btSlaveExpLevel < (m_btSlaveMakeLevel * 2 + 1) then
      begin
        Inc(m_btSlaveExpLevel);
        RecalcAbilitys();
        RefNameColor();
      end;
    end; //004BE92F
  except
    MainOutMessage('[Exception] TBaseObject.GainSlaveExp');
  end;
end;

function TBaseObject.DropGoldDown(nGold: Integer; boFalg: Boolean; GoldOfCreat,
  DropGoldCreat: TBaseObject): Boolean; //004C5794
var
  MapItem, MapItemA: PTMapItem;
  nX, nY: Integer;
  s20: string;
begin

  Result := False;
  try
    New(MapItem);
    FillChar(MapItem^, SizeOf(TMapItem), #0);
    MapItem.Name := sSTRING_GOLDNAME;
    MapItem.Count := nGold;
    MapItem.Looks := GetGoldShape(nGold);
    MapItem.OfBaseObject := GoldOfCreat;
    MapItem.dwCanPickUpTick := GetTickCount();
    MapItem.DropBaseObject := DropGoldCreat;
    GetDropPosition(m_nCurrX, m_nCurrY, 3, nX, nY);
    MapItemA := m_PEnvir.AddToMap(nX, nY, OS_ITEMOBJECT, TObject(MapItem));
    if MapItemA <> nil then
    begin
      if MapItemA <> MapItem then
      begin
        Dispose(MapItem);
        MapItem := MapItemA;
      end;
      SendRefMsg(RM_ITEMSHOW, MapItem.Looks, integer(MapItem), nX, nY,
        MapItem.Name);
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if boFalg then
          s20 := '15'
        else
          s20 := '7';
        //004C5995
        if g_boGameLogGold then
          AddGameDataLog(s20 + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            sSTRING_GOLDNAME + #9 +
            IntToStr(nGold) + #9 +
            BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
            '0');
      end; //004C599A
      Result := True;
    end
    else
      Dispose(MapItem);
  except
    MainOutMessage('[Exception] TBaseObject.DropGoldDown');
  end;
end;

function TBaseObject.GetGuildRelation(cert1, cert2: TBaseObject): Integer;
//004BF380
begin
  Result := 0;
  try

    m_boGuildWarArea := False;
    if (cert1.m_MyGuild = nil) or (cert2.m_MyGuild = nil) then
      exit;
    if cert1.InSafeArea or (cert2.InSafeArea) then
      exit;
    if TGuild(cert1.m_MyGuild).GuildWarList.Count <= 0 then
      exit;
    m_boGuildWarArea := True;
    if TGuild(cert1.m_MyGuild).IsWarGuild(TGuild(cert2.m_MyGuild)) and
      TGuild(cert2.m_MyGuild).IsWarGuild(TGuild(cert1.m_MyGuild)) then
      Result := 2;

    if cert1.m_MyGuild = cert2.m_MyGuild then
      Result := 1;
    if TGuild(cert1.m_MyGuild).IsAllyGuild(TGuild(cert2.m_MyGuild)) and
      TGuild(cert2.m_MyGuild).IsAllyGuild(TGuild(cert1.m_MyGuild)) then
      Result := 3;
  except
    MainOutMessage('[Exception] TBaseObject.GetGuildRelation');
  end;
end;

procedure TBaseObject.IncPkPoint(nPoint: Integer); //004BF4D4
var
  nOldPKLevel: Integer;
begin
  try
    nOldPKLevel := PKLevel;
    Inc(m_nPkPoint, nPoint);
    if PKLevel <> nOldPKLevel then
    begin
      if PKLevel <= 2 then
        RefNameColor;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IncPkPoint');
  end;
end;

procedure TBaseObject.AddBodyLuck(dLuck: Double); //004BF580
var
  n: Integer;
begin
  try
    if (dLuck > 0) and (m_dBodyLuck < 5 * BODYLUCKUNIT) then
    begin
      m_dBodyLuck := m_dBodyLuck + dLuck;
    end;
    if (dLuck < 0) and (m_dBodyLuck > -(5 * BODYLUCKUNIT)) then
    begin
      m_dBodyLuck := m_dBodyLuck + dLuck;
    end;

    n := Trunc(m_dBodyLuck / BODYLUCKUNIT);
    if n > 5 then
      n := 5;
    if n < -10 then
      n := -10;
    m_nBodyLuckLevel := n;
  except
    MainOutMessage('[Exception] TBaseObject.AddBodyLuck');
  end;
end;

procedure TBaseObject.MakeWeaponUnlock; //004C1198
begin
  try
    if m_UseItems[U_WEAPON].wIndex <= 0 then
      exit;
    if m_UseItems[U_WEAPON].btValue[3] > 0 then
    begin
      Dec(m_UseItems[U_WEAPON].btValue[3]);
      SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
    end
    else
    begin
      if m_UseItems[U_WEAPON].btValue[4] < 10 then
      begin
        Inc(m_UseItems[U_WEAPON].btValue[4]);
        SysMsg(g_sTheWeaponIsCursed, c_Red, t_Hint);
      end;
    end;
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TBaseObject.MakeWeaponUnlock');
  end;
end;

function TBaseObject.GetAttackPower(nBasePower, nPower: Integer): Integer;
var
  PlayObject: TPlayObject;
begin
  if nPower < 0 then
    nPower := 0;
  if m_nLuck > 0 then
  begin
    if Random(10 - _MIN(9, m_nLuck)) = 0 then
      Result := nBasePower + nPower
    else
      Result := nBasePower + Random(nPower + 1);
  end
  else
  begin
    Result := nBasePower + Random(nPower + 1);
    if m_nLuck < 0 then
    begin
      if Random(10 - _MAX(0, -m_nLuck)) = 0 then
        Result := nBasePower;
    end;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    PlayObject := TPlayObject(Self);
    //Result:=Result * PlayObject.m_nPowerMult + ROUND(Result * (PlayObject.m_nPowerMultPoint / 100));
    Result := ROUND(Result * (PlayObject.m_nPowerRate / 100));
    if PlayObject.m_boPowerItem then
      Result := ROUND(m_rPowerItem * Result);
  end;
  if m_boAutoChangeColor then
  begin
    Result := Result * m_nAutoChangeIdx + 1;
  end;
  if m_boFixColor then
  begin
    Result := Result * m_nFixColorIdx + 1;
  end;
end;

procedure TBaseObject.DamageHealth(nDamage: Integer); //004BE3FC
var
  nSpdam: Integer;
begin
  try
    if ((m_LastHiter = nil) or not m_LastHiter.m_boUnMagicShield) and
      m_boMagicShield and (nDamage > 0) and (m_WAbil.MP > 0) then
    begin
      nSpdam := Round(nDamage * 1.5);
      if integer(m_WAbil.MP) >= nSpdam then
      begin
        m_WAbil.MP := m_WAbil.MP - nSpdam;
        nSpdam := 0;
      end
      else
      begin
        nSpdam := nSpdam - m_WAbil.MP;
        m_WAbil.MP := 0;
      end;
      nDamage := Round(nSpdam / 1.5);
      HealthSpellChanged();
    end;
    if nDamage > 0 then
    begin
      if (m_WAbil.HP - nDamage) > 0 then
      begin
        m_WAbil.HP := m_WAbil.HP - nDamage;
      end
      else
      begin
        m_WAbil.HP := 0;
      end;
    end
    else
    begin
      if (m_WAbil.HP - nDamage) < m_WAbil.MaxHP then
      begin
        m_WAbil.HP := m_WAbil.HP - nDamage;
      end
      else
      begin
        m_WAbil.HP := m_WAbil.MaxHP;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DamageHealth');
  end;
end;

function TBaseObject.GetBackDir(nDir: integer): Integer; //004B2708
begin

  Result := 0;
  try
    case nDir of
      DR_UP: Result := DR_DOWN;
      DR_DOWN: Result := DR_UP;
      DR_LEFT: Result := DR_RIGHT;
      DR_RIGHT: Result := DR_LEFT;
      DR_UPLEFT: Result := DR_DOWNRIGHT;
      DR_UPRIGHT: Result := DR_DOWNLEFT;
      DR_DOWNLEFT: Result := DR_UPRIGHT;
      DR_DOWNRIGHT: Result := DR_UPLEFT;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetBackDir');
  end;
end;

function TBaseObject.CharPushed(nDir, nPushCount: Integer): integer; //004C2F90
var
  i, nx, ny, olddir, nBackDir: integer;
begin

  Result := 0;
  try
    olddir := m_btDirection;
    //oldx := m_nCurrX;
    //oldy := m_nCurrY;
    m_btDirection := ndir;
    nBackDir := GetBackDir(ndir);
    for i := 0 to nPushCount - 1 do
    begin
      GetFrontPosition(nx, ny);
      if m_PEnvir.CanWalk(nX, nY, False) then
      begin
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False)
          > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          //SendRefMsg(RM_PUSH, GetBackDir(ndir), m_nCurrX, m_nCurrY, 0, '');
          SendRefMsg(RM_PUSH, nBackDir, m_nCurrX, m_nCurrY, 0, '');
          Inc(Result);
          if m_btRaceServer >= RC_ANIMAL then
            m_dwWalkTick := m_dwWalkTick + 800;
        end
        else
          break;
      end
      else
        break;
    end;

    m_btDirection := nBackDir;
    if Result = 0 then
      m_btDirection := olddir;
  except
    MainOutMessage('[Exception] TBaseObject.CharPushed');
  end;
end;

function TBaseObject.MagPassThroughMagic(sx, sy, tx, ty, ndir, magpwr: integer;
  undeadattack: Boolean): integer; //004C69F4
var
  i, tcount: integer;
  BaseObject: TBaseObject;
begin
  Result := 0;
  try
    tcount := 0;
    for i := 0 to 12 do
    begin
      BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sx, sy, True));
      if BaseObject <> nil then
      begin
        if IsProperTarget(BaseObject) then
        begin
          if Random(10) >= BaseObject.m_nAntiMagic then
          begin
            if undeadattack then
              magpwr := Round(magpwr * 1.5);

            BaseObject.SendDelayMsg(self, RM_MAGSTRUCK, 0, magpwr, 0, 0, '',
              600);
            Inc(tcount);
          end;
        end;
      end;
      if not ((abs(sx - tx) <= 0) and (abs(sy - ty) <= 0)) then
      begin
        ndir := GetNextDirection(sx, sy, tx, ty);
        if not m_PEnvir.GetNextPosition(sx, sy, ndir, 1, sx, sy) then
          break;
      end
      else
        break;
    end;
    Result := tcount;
  except
    MainOutMessage('[Exception] TBaseObject.MagPassThroughMagic');
  end;
end;

function TBaseObject.MagPassThroughMagic2(sx, sy, tx, ty, ndir, magpwr: integer;
  undeadattack: Boolean): integer; //004C69F4
var
  i, tcount: integer;
  BaseObject: TBaseObject;
  nPower, X: Integer;
begin
  Result := 0;
  try
    tcount := 0;
    for i := 0 to 12 do
    begin
      BaseObject := TBaseObject(m_PEnvir.GetMovingObject(sx, sy, True));
      if BaseObject <> nil then
      begin
        if IsProperTarget(BaseObject) then
        begin
          if Random(10) >= BaseObject.m_nAntiMagic then
          begin
            nPower := magpwr;
            if undeadattack then
            begin
              X := Round(magpwr * 0.1);
              nPower := magpwr - Round(X * 0.5) + Random(X);
            end;
            BaseObject.SendDelayMsg(self, RM_MAGSTRUCK, 0, nPower, 0, 0, '',
              600);
            Inc(tcount);
          end;
        end;
      end;
      if not ((abs(sx - tx) <= 0) and (abs(sy - ty) <= 0)) then
      begin
        ndir := GetNextDirection(sx, sy, tx, ty);
        if not m_PEnvir.GetNextPosition(sx, sy, ndir, 1, sx, sy) then
          break;
      end
      else
        break;
    end;
    Result := tcount;

  except
    MainOutMessage('[Exception] TBaseObject.MagPassThroughMagic2');
  end;
end;

procedure TPlayObject.SendSocket(DefMsg: pTDefaultMessage; sMsg: string);
//004CAB38
var
  MsgHdr: TMsgHeader;
  nSendBytes: Integer;
  tBuff: PChar;
  nCheck: Byte;
  // i:integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::SendSocket %d';
begin
  try
    if m_boHero or m_boSafeOffLine or (m_nGateIdx = -1) then
      exit; //如果为英雄，则不发送客户端数据，以防出错
    try
      if Assigned(m_HookSendSocket) then
      begin
        m_HookSendSocket(Self, DefMsg, PChar(sMsg));
      end;
    except
      MainOutMessage('[Exception] TPlayObject.SendSocket->HookApi');
    end;
    tBuff := nil;
    nCheck := 0;
    try
      MsgHdr.dwCode := RUNGATECODE;
      MsgHdr.nSocket := m_nSocket;
      MsgHdr.wGSocketIdx := m_nGSocketIdx;
      MsgHdr.wIdent := GM_DATA;
      nCheck := 1;
      //    MsgHdr.nUserListIndex := 0;
          //004CAB9A
      if DefMsg <> nil then
      begin
        nCheck := 2;
        if sMsg <> '' then
        begin
          nCheck := 3;
          MsgHdr.nLength := Length(sMsg) + SizeOf(TDefaultMessage) + 1;
          nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
          GetMem(tBuff, nSendBytes + SizeOf(Integer));
          Move(nSendBytes, tBuff^, SizeOf(Integer));
          Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
          Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],
            SizeOf(TDefaultMessage));
          Move(sMsg[1], tBuff[SizeOf(TDefaultMessage) + SizeOf(TMsgHeader) +
            SizeOf(Integer)], Length(sMsg) + 1);
          nCheck := 4;
        end
        else
        begin //004CAC29
          nCheck := 5;
          MsgHdr.nLength := SizeOf(TDefaultMessage);
          nSendBytes := MsgHdr.nLength + SizeOf(TMsgHeader);
          GetMem(tBuff, nSendBytes + SizeOf(Integer));
          Move(nSendBytes, tBuff^, SizeOf(Integer));
          Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
          Move(DefMsg^, tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)],
            SizeOf(TDefaultMessage));
          nCheck := 6;
        end;
      end
      else
      begin //004CAC7F
        nCheck := 7;
        if sMsg <> '' then
        begin
          nCheck := 8;
          MsgHdr.nLength := -(Length(sMsg) + 1);
          nSendBytes := abs(MsgHdr.nLength) + SizeOf(TMsgHeader);
          GetMem(tBuff, nSendBytes + SizeOf(Integer));
          Move(nSendBytes, tBuff^, SizeOf(Integer));
          Move(MsgHdr, tBuff[SizeOf(Integer)], SizeOf(TMsgHeader));
          Move(sMsg[1], tBuff[SizeOf(TMsgHeader) + SizeOf(Integer)], Length(sMsg)
            + 1);
          nCheck := 9;
        end; //004CACF0
      end; //004CACF0
      if not RunSocket.AddGateBuffer(m_nGateIdx, tBuff) then
      begin
        nCheck := 10;
        FreeMem(tBuff);
        nCheck := 11;
        //MainOutMessage('SendSocket Buffer Fail ' + IntToStr(m_nGateIdx));
      end;
    except
      MainOutMessage(Format(sExceptionMsg, [nCheck]));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendSocket');
  end;
end;

procedure TPlayObject.SendDefMessagebyClass(wIdent: Word; nRecog: Integer;
  nParam, nTag, nSeries: Word; sMsg, sClass: string);
var
  GuildRank: pTGuildRank;
  I, II: integer;
  SendObject: TPlayObject;
  sSendMsg: string;
begin
  if Trim(sMsg) = '' then
    exit;

  m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries);
  sSendMsg := EncodeString(sMsg);
  if CompareText(sClass, 'GROUP') = 0 then
  begin
    SendSocket(@m_DefMsg, EncodeString(sMsg));
    for i := 0 to m_GroupMembers.Count - 1 do
    begin
      SendObject := TPlayObject(m_GroupMembers.Objects[I]);
      if SendObject = self then
        Continue;
      SendObject.SendSocket(@m_DefMsg, sSendMsg);
    end;
  end
  else if CompareText(sClass, 'GUILD') = 0 then
  begin
    SendSocket(@m_DefMsg, EncodeString(sMsg));
    if IsGuildMaster then
    begin
      for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
      begin
        GuildRank := TGuild(m_MyGuild).m_RankList.Items[I];
        for II := 0 to GuildRank.MemberList.Count - 1 do
        begin
          SendObject := TPlayObject(GuildRank.MemberList.Objects[II]);
          if SendObject = self then
            Continue;
          if SendObject <> nil then
            SendObject.SendSocket(@m_DefMsg, sSendMsg);
        end;
      end;
    end;
  end
  else if CompareText(sClass, 'Self') = 0 then
  begin
    SendSocket(@m_DefMsg, sSendMsg)
  end
  else
  begin
    UserEngine.SendBroadSocket(@m_DefMsg, sSendMsg);
  end;
end;

procedure TPlayObject.SendDefMessage(wIdent: Word; nRecog: Integer; nParam,
  nTag, nSeries: Word; sMsg: string); //004CAD6C
begin
  try
    m_DefMsg := MakeDefaultMsg(wIdent, nRecog, nParam, nTag, nSeries);
    if sMsg <> '' then
      SendSocket(@m_DefMsg, EncodeString(sMsg))
    else
      SendSocket(@m_DefMsg, '');
  except
    MainOutMessage('[Exception] TPlayObject.SendDefMessage');
  end;
end;

procedure TPlayObject.ClientQueryUserName(target: TBaseObject; x, y: integer);
//004DA8E8
var
  uname: string;
  TagColor: Integer;
  Def: TDefaultMessage;
begin
  try
    if CretInNearXY(target, x, y) then
    begin
      tagcolor := GetCharColor(target);
      Def := MakeDefaultMsg(SM_USERNAME, Integer(target), tagcolor, 0, 0);
      uname := target.GetShowName;
      if m_dwClientTickEx > 20070818 then
        uname := target.m_NewShowName;
      SendSocket(@Def, EncodeString(uname));
    end
    else
      SendDefMessage(SM_GHOST, integer(target), x, y, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientQueryUserName');
  end;
end;

function TBaseObject.GetAddName(sName: string; CorpsIdx: Integer): string;
var
  sGroupname: string;
begin
  try
    Result := sName;
    if Result = '' then
      Result := '　';
    Result := Result + '|' + IntToStr(CorpsIdx) + '\' + IntToStr(m_nIconIdx[0])
      +
      '\' + IntToStr(m_nIconIdx[1]) + '\' + IntToStr(m_nIconIdx[2]) + '\' +
      IntToStr(m_nIconIdx[3]) + '\' + IntToStr(m_nIconIdx[4]) + '\' +
      IntToStr(m_Helmet);
    if (m_btRaceServer = RC_PLAYOBJECT) and
      (m_GroupOwner = Self) and
      (m_boAllowAddGroup) and
      (m_GroupMembers.Count > 0) then
    begin
      sGroupname := Format(sAutoAddGroupMembers, [m_GroupMembers.Count - 1,
        g_Config.nGroupMembersMax]);
      sGroupname := AnsiReplaceText(sGroupname, '/', '\');
      sGroupname := AnsiReplaceText(sGroupname, '|', '\');
      Result := Result + '|' + sGroupname;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetAddName');
  end;
end;

function TBaseObject.GetShowName: string; //004C129C
var
  sShowName: string;
  nCheck: Integer;
begin
  nCheck := 0;
  try
    sShowName := m_sCharName;
    nCheck := 1;
    Result := FilterShowName(sShowName);
    nCheck := 2;
    if (m_Master2 <> nil) and (m_AllMaster <> nil) and not m_Master2.m_boObMode
      then
    begin
      nCheck := 3;
      if m_AllMaster.m_btRaceServer <> RC_PLAYOBJECT then
        Result := Result + '(' + FilterShowName(m_Master2.m_sCharName) + ')'
      else
        Result := Result + '(' + m_Master2.m_sCharName + ')';
      nCheck := 4;
    end
    else if (g_Config.boMonShowLevel) and (m_btRaceServer >= RC_ANIMAL) and (not
      (m_btRaceServer in [110, 111])) then
      Result := Format(Result + '\' + g_Config.boMonShowLevelMsg,
        [m_Abil.Level]);
    nCheck := 5;
    m_OldShowName := Result;
    nCheck := 6;
    m_NewShowName := GetAddName(Result, 0);
    nCheck := 7;
  except
    MainOutMessage('[Exception] TBaseObject.GetShowName ' + IntToStr(nCheck));
  end;
end;

procedure TAnimalObject.GetMissionXY(var TargetX: Integer; var TargetY:
  Integer);
var
  oX, oY: Integer;
begin
  TargetX := -1;
  TargetY := -1;
  //  nX:=-1;
  //  nY:=-1;
  if m_FPath <> nil then
  begin
    oX := m_FPath^[m_FPathIdx - 1].X;
    oY := m_FPath^[m_FPathIdx - 1].Y;
    if (m_nCurrX = oX) and (m_nCurrY = oY) then
    begin
      Inc(m_FPathIdx);
      if m_FPathIdx <= High(m_FPath^) then
      begin
        TargetX := m_FPath^[m_FPathIdx].X;
        TargetY := m_FPath^[m_FPathIdx].Y;
      end;
    end
    else
    begin
      TargetX := oX;
      TargetY := oY;
    end;

  end;
end;

procedure TAnimalObject.Attack(TargeTBaseObject: TBaseObject; nDir: Integer);
//004C9380
begin
  try
    inherited AttackDir(TargeTBaseObject, 0, nDir);
  except
    MainOutMessage('[Exception] TAnimalObject.Attack');
  end;
end;

constructor TAnimalObject.Create; //004C9190
begin
  try
    inherited;
    m_nNotProcessCount := 0;
    m_nTargetX := -1;
    //  dwTick3F02:=Random(4) * 500 + 1000;
    //  dwTick3F42:=GetTickCount();
    m_btRaceServer := RC_ANIMAL;
    m_dwHitTick := GetTickCount - LongWord(Random(3000));
    m_dwWalkTick := GetTickCount - LongWord(Random(3000));
    m_dwSearchEnemyTick := GetTickCount();
    m_dwHeroPickUpTick := GetTickCount;
    m_boRunAwayMode := False;
    m_dwRunAwayStart := GetTickCount();
    m_dwRunAwayTime := 0;
    m_FPath := nil;
    m_FPathIdx := 0;
    m_MissIonEx := False;
  except
    MainOutMessage('[Exception] TAnimalObject.Create');
  end;
end;

procedure TAnimalObject.GotoTargetXY; //004C9694
var
  I: Integer;
  nDir: Integer;
  n10: Integer;
  n14: Integer;
  n20: Integer;
  nOldX: Integer;
  nOldY: Integer;
begin
  try
    if ((m_nCurrX <> m_nTargetX) or (m_nCurrY <> m_nTargetY)) then
    begin
      n10 := m_nTargetX;
      n14 := m_nTargetY;
      //   dwTick3F42:=GetTickCount();
      nDir := DR_DOWN;
      if n10 > m_nCurrX then
      begin
        nDir := DR_RIGHT;
        if n14 > m_nCurrY then
          nDir := DR_DOWNRIGHT;
        if n14 < m_nCurrY then
          nDir := DR_UPRIGHT;
      end
      else
      begin //004C9728
        if n10 < m_nCurrX then
        begin
          nDir := DR_LEFT;
          if n14 > m_nCurrY then
            nDir := DR_DOWNLEFT;
          if n14 < m_nCurrY then
            nDir := DR_UPLEFT;
        end
        else
        begin //004C9760
          if n14 > m_nCurrY then
            nDir := DR_DOWN
          else if n14 < m_nCurrY then
            nDir := DR_UP;
        end;
      end;
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      WalkTo(nDir, False);
      n20 := Random(3);
      for I := DR_UP to DR_UPLEFT do
      begin
        if (nOldX = m_nCurrX) and (nOldY = m_nCurrY) then
        begin
          if n20 <> 0 then
            Inc(nDir)
          else if nDir > 0 then
            Dec(nDir)
          else
            nDir := DR_UPLEFT;
          if (nDir > DR_UPLEFT) then
            nDir := DR_UP;
          WalkTo(nDir, False);
        end;
      end;
    end; //004C980B
  except
    MainOutMessage('[Exception] TAnimalObject.GotoTargetXY');
  end;
end;

function TAnimalObject.Operate(ProcessMsg: pTProcessMessage): Boolean; //004C9280
begin
  Result := False;
  try
    //  Result:=False;
    if ProcessMsg.wIdent = RM_STRUCK then
    begin
      if (ProcessMsg.BaseObject = Self) and (TBaseObject(ProcessMsg.nParam3
        {AttackBaseObject}) <> nil) then
      begin
        SetLastHiter(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject}));
        Struck(TBaseObject(ProcessMsg.nParam3 {AttackBaseObject})); {0FFEC}
        BreakHolySeizeMode();
        if ((m_AllMaster <> nil) and (m_AllMaster.m_btRaceServer =
          RC_PLAYOBJECT)) and
          (TBaseObject(ProcessMsg.nParam3) <> m_AllMaster) and
          (TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT) then
        begin

          m_AllMaster.SetPKFlag(TBaseObject(ProcessMsg.nParam3));
        end;
        if g_Config.boMonSayMsg then
          MonsterSayMsg(TBaseObject(ProcessMsg.nParam3), s_UnderFire);
      end;
      Result := True;
    end
    else
    begin //004C932C
      Result := inherited Operate(ProcessMsg);
    end;
  except
    MainOutMessage('[Exception] TAnimalObject.Operate');
  end;
end;

procedure TAnimalObject.Run; //004C936C

begin
  try
    try
      inherited;
    except
      MainOutMessage('[Exception] TBaseObject.Run AnimalObject');
    end;

  except
    MainOutMessage('[Exception] TAnimalObject.Run');
  end;
end;

procedure TAnimalObject.Struck(Hiter: TBaseObject); //004C93A8
var
  btDir: Byte;
begin
  try
    m_dwStruckTick := GetTickCount;
    if Hiter <> nil then
    begin
      if (m_TargetCret = nil) or GetAttackDir(m_TargetCret, btDir) or (Random(6)
        = 0) then
      begin
        if IsProperTarget(Hiter) then
          SetTargetCreat(Hiter);
      end;
    end; //004C941D
    if m_boAnimal then
    begin
      m_nMeatQuality := m_nMeatQuality - Random(300);
      if m_nMeatQuality < 0 then
        m_nMeatQuality := 0;
    end;
    //if m_Abil.Level < 50 then
    m_dwHitTick := m_dwHitTick + LongWord(150 - _MIN(130, m_Abil.Level * 4));
    //WalkTime := WalkTime + (300 - _MIN(200, (Abil.Level div 5) * 20));
  except
    MainOutMessage('[Exception] TAnimalObject.Struck');
  end;
end;

procedure TBaseObject.RecalcAbilitys; //004C03B0
var
  wOldHP, wOldMP: Word;
  boOldHideMode: Boolean;
  nOldLight: Integer;
  I, X: Integer;
  StdItem: TItem;

  boRecallSuite: array[0..3] of Boolean;
  boMoXieSuite: array[0..2] of Boolean;

  boHongMoSuite1: Boolean;
  boHongMoSuite2: Boolean;
  boHongMoSuite3: Boolean;
  boSpirit: array[0..3] of Boolean;

  boSmash1, boSmash2, boSmash3: Boolean;
  boHwanDevil1, boHwanDevil2, boHwanDevil3: Boolean;
  boPurity1, boPurity2, boPurity3: Boolean;
  boMundane1, boMundane2: Boolean;
  boNokChi1, boNokChi2: Boolean;
  boTaoBu1, boTaoBu2: Boolean;
  boFiveString1, boFiveString2, boFiveString3: Boolean;
  SuitIdx: array[0..255] of Byte;
  boShow: Boolean;
  SuitItems: pTSuitItems;
begin
  try
{$REGION '初始化'}
    FillChar(m_AddAbil, SizeOf(TAddAbility), 0);
    FillChar(SuitIdx, SizeOf(SuitIdx), 0);
    wOldHP := m_WAbil.HP;
    wOldMP := m_WAbil.MP;
    m_WAbil := m_Abil;
    m_WAbil.HP := wOldHP;
    m_WAbil.MP := wOldMP;
    m_WAbil.Weight := 0;
    m_WAbil.WearWeight := 0;
    m_WAbil.HandWeight := 0;
    m_btAntiPoison := 0;
    m_nPoisonRecover := 0;
    m_nHealthRecover := 0;
    m_nSpellRecover := 0;
    m_nAntiMagic := 1;
    m_nLuck := 0;
    m_Helmet := 0;
    m_nHitSpeed := 0;
    m_btDiploidRate3 := 0;
    m_boExpItem := False;
    m_rExpItem := 0;
    m_boPowerItem := False;
    m_rPowerItem := 0;
    boOldHideMode := m_boHideMode;
    m_boHideMode := False;
    m_boTeleport := False;
    m_boTeleport2 := False;
    m_boParalysis := False;
    m_boRevival := False;
    m_boRevivalnotItem := False;
    m_boUnRevival := False;
    m_boFlameRing := False;
    m_boRecoveryRing := False;
    m_boAngryRing := False;
    m_boMagicShield := False;
    m_boUnMagicShield := False;
    m_boMuscleRing := False;
    m_boFastTrain := False;
    m_boProbeNecklace := False;
    m_boSupermanItem := False;
    m_boGuildMove := False;
    m_boUnParalysis := False;
    m_boExpItem := False;
    m_boPowerItem := False;
    m_boNoDropItem := False;
    m_boNoDropUseItem := False;
    //m_boCloneNoDropItem:= False;
    m_bopirit := False;
    m_btHorseType := 0;
    m_btDressEffType := 0;

    m_nMoXieSuite := 0;
    boMoXieSuite[0] := False;
    boMoXieSuite[1] := False;
    boMoXieSuite[2] := False;
    //  m_db3B0            := 0;
    m_nHongMoSuite := 0;
    boHongMoSuite1 := False;
    boHongMoSuite2 := False;
    boHongMoSuite3 := False;

    m_nSuitMonExpRate := 10;

    boSpirit[0] := False;
    boSpirit[1] := False;
    boSpirit[2] := False;
    boSpirit[3] := False;

    m_boRecallSuite := False;
    boRecallSuite[0] := False;
    boRecallSuite[1] := False;
    boRecallSuite[2] := False;
    boRecallSuite[3] := False;

    m_boSmashSet := False;
    boSmash1 := False;
    boSmash2 := False;
    boSmash3 := False;

    m_boHwanDevilSet := False;
    boHwanDevil1 := False;
    boHwanDevil2 := False;
    boHwanDevil3 := False;

    m_boPuritySet := False;
    boPurity1 := False;
    boPurity2 := False;
    boPurity3 := False;

    m_boMundaneSet := False;
    boMundane1 := False;
    boMundane2 := False;

    m_boNokChiSet := False;
    boNokChi1 := False;
    boNokChi2 := False;

    m_boTaoBuSet := False;
    boTaoBu1 := False;
    boTaoBu2 := False;

    m_boFiveStringSet := False;
    boFiveString1 := False;
    boFiveString2 := False;
    boFiveString3 := False;

    m_dwPKDieLostExp := 0;
    m_nPKDieLostLevel := 0;
{$ENDREGION}
    if (m_btRaceServer = RC_PLAYOBJECT) and (not m_boHero) then
    begin //只有人物才处理附加属性
      m_AddAbil.wAC := MakeLong(m_TempAbil[0].nAddWord, m_TempAbil[1].nAddWord);
      m_AddAbil.wMAC := MakeLong(m_TempAbil[2].nAddWord,
        m_TempAbil[3].nAddWord);
      m_AddAbil.wDC := MakeLong(m_TempAbil[4].nAddWord, m_TempAbil[5].nAddWord);
      m_AddAbil.wSC := MakeLong(m_TempAbil[6].nAddWord, m_TempAbil[7].nAddWord);
      m_AddAbil.wMC := MakeLong(m_TempAbil[8].nAddWord, m_TempAbil[9].nAddWord);
    end;

    m_btDiploidRate3 := m_btDiploidRate;

    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if (m_UseItems[I].wIndex <= 0) or (m_UseItems[I].Dura <= 0) then
        Continue;
      StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem = nil then
        Continue;
      //StdItem.GetItemAddValue(UserItem, StdItem);
      StdItem.ApplyItemParameters(m_AddAbil, @m_UseItems[I]);//计算身上装备属性

      //套装属性
{$REGION '计算套装属性'}
      if (StdItem.SuitIdx[0] > 0) then
      begin
        for X := 1 to StdItem.SuitIdx[0] do
        begin
          Inc(SuitIdx[StdItem.SuitIdx[X]]);
        end;
      end;
      if I = U_HELMET then
        m_Helmet := StdItem.AniCount;
      if i = U_BUJUK then
      begin
        if (StdItem.StdMode = 25) and (StdItem.Shape = 6) then
        begin
          m_boTeleport := True;
          m_boTeleport2 := True;
        end;
      end;
      //m_boTeleport2
      if (I = U_WEAPON) or (I = U_RIGHTHAND) or (I = U_DRESS) then
      begin
        if I = U_DRESS then
        begin
          Inc(m_WAbil.WearWeight, StdItem.Weight);
        end
        else
        begin
          Inc(m_WAbil.HandWeight, StdItem.Weight);
        end;
        //新增开始
        if StdItem.AniCount = 120 then
          m_boFastTrain := True;
        if StdItem.AniCount = 121 then
          m_boProbeNecklace := True;
        if StdItem.AniCount = 145 then
          m_boGuildMove := True;
        if StdItem.AniCount = 111 then
        begin
          m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] := 6 * 10 * 1000;
          m_boHideMode := True;
        end;
        if StdItem.AniCount = 112 then
          m_boTeleport := True;
        if StdItem.AniCount = 113 then
          m_boParalysis := True;
        if StdItem.AniCount = 114 then
          m_boRevival := True;
        if StdItem.AniCount = 115 then
          m_boFlameRing := True;
        if StdItem.AniCount = 116 then
          m_boRecoveryRing := True;
        if StdItem.AniCount = 117 then
          m_boAngryRing := True;
        if StdItem.AniCount = 118 then
          m_boMagicShield := True;
        if StdItem.AniCount = 119 then
          m_boMuscleRing := True;
        if StdItem.AniCount = 135 then
        begin
          boMoXieSuite[0] := True;
          Inc(m_nMoXieSuite, StdItem.Weight div 10);
        end;
        if StdItem.AniCount = 138 then
        begin
          Inc(m_nHongMoSuite, StdItem.Weight);
        end;
        if StdItem.AniCount = 139 then
          m_boUnParalysis := True;
        if StdItem.AniCount = 140 then
          m_boSupermanItem := True;
        if StdItem.AniCount = 141 then
        begin
          m_boExpItem := True;
          m_rExpItem := m_rExpItem + (m_UseItems[i].Dura /
            g_Config.nItemExpRate);
        end;
        if StdItem.AniCount = 142 then
        begin
          m_boPowerItem := True;
          m_rPowerItem := m_rPowerItem + (m_UseItems[i].Dura /
            g_Config.nItemPowerRate);
        end;
        if StdItem.AniCount = 182 then
        begin
          m_boExpItem := True;
          m_rExpItem := m_rExpItem + (m_UseItems[i].DuraMax /
            g_Config.nItemExpRate);
        end;
        if StdItem.AniCount = 183 then
        begin
          m_boPowerItem := True;
          m_rPowerItem := m_rPowerItem + (m_UseItems[i].DuraMax /
            g_Config.nItemPowerRate);
        end;

        if StdItem.AniCount = 143 then
          m_boUnMagicShield := True;
        if StdItem.AniCount = 144 then
          m_boUnRevival := True;
        if StdItem.AniCount = 170 then
          m_boAngryRing := True;
        if StdItem.AniCount = 171 then
          m_boNoDropItem := True;
        if StdItem.AniCount = 172 then
          m_boNoDropUseItem := True;
        if StdItem.AniCount = 150 then
        begin //麻痹护身
          m_boParalysis := True;
          m_boMagicShield := True;
        end;
        if StdItem.AniCount = 151 then
        begin //麻痹火球
          m_boParalysis := True;
          m_boFlameRing := True;
        end;
        if StdItem.AniCount = 152 then
        begin //麻痹防御
          m_boParalysis := True;
          m_boRecoveryRing := True;
        end;
        if StdItem.AniCount = 153 then
        begin //麻痹负载
          m_boParalysis := True;
          m_boMuscleRing := True;
        end;
        if StdItem.Shape = 154 then
        begin //护身火球
          m_boMagicShield := True;
          m_boFlameRing := True;
        end;
        if StdItem.AniCount = 155 then
        begin //护身防御
          m_boMagicShield := True;
          m_boRecoveryRing := True;
        end;
        if StdItem.AniCount = 156 then
        begin //护身负载
          m_boMagicShield := True;
          m_boMuscleRing := True;
        end;

        if StdItem.AniCount = 157 then
        begin //传送麻痹
          m_boTeleport := True;
          m_boParalysis := True;
        end;

        if StdItem.AniCount = 158 then
        begin //传送护身
          m_boTeleport := True;
          m_boMagicShield := True;
        end;

        if StdItem.AniCount = 159 then
        begin //传送探测
          m_boTeleport := True;
          m_boProbeNecklace := True;
        end;
        if StdItem.AniCount = 160 then
        begin //传送复活
          m_boTeleport := True;
          m_boRevival := True;
        end;
        if StdItem.AniCount = 161 then
        begin //麻痹复活
          m_boParalysis := True;
          m_boRevival := True;
        end;
        if StdItem.AniCount = 162 then
        begin //护身复活
          m_boMagicShield := True;
          m_boRevival := True;
        end;
        if StdItem.AniCount = 180 then
        begin //PK 死亡掉经验
          m_dwPKDieLostExp := StdItem.DuraMax *
            LongWord(g_Config.dwPKDieLostExpRate);
          //        m_nPKDieLostLevel:=1;
        end;
        if StdItem.AniCount = 181 then
        begin //PK 死亡掉等级
          m_nPKDieLostLevel := StdItem.DuraMax div
            LongWord(g_Config.nPKDieLostLevelRate);
        end;
        //新增结束
      end
      else
      begin
        Inc(m_WAbil.WearWeight, StdItem.Weight);
      end;
      Inc(m_WAbil.Weight, StdItem.Weight);
      if (i = U_WEAPON) then
      begin
        if (StdItem.Source - 1 - 10) < 0 then
        begin
          m_AddAbil.btWeaponStrong := StdItem.Source; //强度+
        end;
        if (StdItem.Source <= -1) and (StdItem.Source >= -50) then
        begin // -1 to -50
          m_AddAbil.btUndead := m_AddAbil.btUndead + -StdItem.Source; //Holy+
        end;
        if (StdItem.Source <= -51) and (StdItem.Source >= -100) then
        begin // -51 to -100
          m_AddAbil.btUndead := m_AddAbil.btUndead + (StdItem.Source + 50);
          //Holy-
        end;

        Continue;
      end;
      if (i = U_RIGHTHAND) then
      begin
        if StdItem.Shape in [1..50] then
          m_btDressEffType := StdItem.Shape;
        if StdItem.Shape in [51..100] then
          m_btHorseType := StdItem.Shape - 50;
        Continue;
      end;

      if (I = U_DRESS) then
      begin
        if m_UseItems[I].btValue[5] > 0 then
          m_btDressEffType := m_UseItems[I].btValue[5];
        if StdItem.AniCount > 0 then
          m_btDressEffType := StdItem.AniCount;

        if StdItem.Light then
          m_nLight := 3;

        Continue;
      end;
      //新增开始
      if StdItem.Shape = 139 then
        m_boUnParalysis := True;
      if StdItem.Shape = 140 then
        m_boSupermanItem := True;
      if StdItem.Shape = 141 then
      begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[i].Dura / g_Config.nItemExpRate);
      end;
      if StdItem.Shape = 142 then
      begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[i].Dura /
          g_Config.nItemPowerRate);
      end;
      if StdItem.Shape = 182 then
      begin
        m_boExpItem := True;
        m_rExpItem := m_rExpItem + (m_UseItems[i].DuraMax /
          g_Config.nItemExpRate);
      end;
      if StdItem.Shape = 183 then
      begin
        m_boPowerItem := True;
        m_rPowerItem := m_rPowerItem + (m_UseItems[i].DuraMax /
          g_Config.nItemPowerRate);
      end;
      if StdItem.Shape = 143 then
        m_boUnMagicShield := True;
      if StdItem.Shape = 144 then
        m_boUnRevival := True;
      if StdItem.Shape = 170 then
        m_boAngryRing := True;
      if StdItem.Shape = 171 then
        m_boNoDropItem := True;
      if StdItem.Shape = 172 then
        m_boNoDropUseItem := True;

      if StdItem.Shape = 150 then
      begin //麻痹护身
        m_boParalysis := True;
        m_boMagicShield := True;
      end;
      if StdItem.Shape = 151 then
      begin //麻痹火球
        m_boParalysis := True;
        m_boFlameRing := True;
      end;
      if StdItem.Shape = 152 then
      begin //麻痹防御
        m_boParalysis := True;
        m_boRecoveryRing := True;
      end;
      if StdItem.Shape = 153 then
      begin //麻痹负载
        m_boParalysis := True;
        m_boMuscleRing := True;
      end;
      if StdItem.Shape = 154 then
      begin //护身火球
        m_boMagicShield := True;
        m_boFlameRing := True;
      end;
      if StdItem.Shape = 155 then
      begin //护身防御
        m_boMagicShield := True;
        m_boRecoveryRing := True;
      end;
      if StdItem.Shape = 156 then
      begin //护身负载
        m_boMagicShield := True;
        m_boMuscleRing := True;
      end;

      if StdItem.Shape = 157 then
      begin //传送麻痹
        m_boTeleport := True;
        m_boParalysis := True;
      end;

      if StdItem.Shape = 158 then
      begin //传送护身
        m_boTeleport := True;
        m_boMagicShield := True;
      end;

      if StdItem.Shape = 159 then
      begin //传送探测
        m_boTeleport := True;
        m_boProbeNecklace := True;
      end;
      if StdItem.Shape = 160 then
      begin //传送复活
        m_boTeleport := True;
        m_boRevival := True;
      end;
      if StdItem.Shape = 161 then
      begin //麻痹复活
        m_boParalysis := True;
        m_boRevival := True;
      end;
      if StdItem.Shape = 162 then
      begin //护身复活
        m_boMagicShield := True;
        m_boRevival := True;
      end;
      if StdItem.Shape = 180 then
      begin //PK 死亡掉经验
        m_dwPKDieLostExp := StdItem.DuraMax *
          LongWord(g_Config.dwPKDieLostExpRate);
        //        m_nPKDieLostLevel:=1;
      end;
      if StdItem.Shape = 181 then
      begin //PK 死亡掉等级
        m_nPKDieLostLevel := StdItem.DuraMax div
          LongWord(g_Config.nPKDieLostLevelRate);
      end;
      //新增结束
    //if (i = U_NECKLACE) then begin
      if StdItem.Shape = 120 then
        m_boFastTrain := True;
      if StdItem.Shape = 121 then
        m_boProbeNecklace := True;
      if StdItem.Shape = 123 then
        boRecallSuite[0] := True;
      if StdItem.Shape = 145 then
        m_boGuildMove := True;
      if StdItem.Shape = 127 then
        boSpirit[0] := True;
      if StdItem.Shape = 135 then
      begin
        boMoXieSuite[0] := True;
        Inc(m_nMoXieSuite, StdItem.AniCount);
      end;
      if StdItem.Shape = 138 then
      begin
        boHongMoSuite1 := True;
        Inc(m_nHongMoSuite, StdItem.AniCount);
      end;
      if StdItem.Shape = 200 then
        boSmash1 := True;
      if StdItem.Shape = 203 then
        boHwanDevil1 := True;
      if StdItem.Shape = 206 then
        boPurity1 := True;
      if StdItem.Shape = 216 then
        boFiveString1 := True;
      //end;
      //if (i = U_RINGR) or (i = U_RINGL) then begin
      if StdItem.Shape = 111 then
      begin
        m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] := 6 * 10 * 1000;
        m_boHideMode := True;
      end;
      if StdItem.Shape = 112 then
        m_boTeleport := True;
      if StdItem.Shape = 113 then
        m_boParalysis := True;
      if StdItem.Shape = 114 then
        m_boRevival := True;
      if StdItem.Shape = 115 then
        m_boFlameRing := True;
      if StdItem.Shape = 116 then
        m_boRecoveryRing := True;
      if StdItem.Shape = 117 then
        m_boAngryRing := True;
      if StdItem.Shape = 118 then
        m_boMagicShield := True;
      if StdItem.Shape = 119 then
        m_boMuscleRing := True;
      if StdItem.Shape = 122 then
        boRecallSuite[1] := True;
      if StdItem.Shape = 128 then
        boSpirit[1] := True;
      if StdItem.Shape = 133 then
      begin
        boMoXieSuite[1] := True;
        Inc(m_nMoXieSuite, StdItem.AniCount);
      end;
      if StdItem.Shape = 136 then
      begin
        boHongMoSuite2 := True;
        Inc(m_nHongMoSuite, StdItem.AniCount);
      end;
      if StdItem.Shape = 201 then
        boSmash2 := True;
      if StdItem.Shape = 204 then
        boHwanDevil2 := True;
      if StdItem.Shape = 207 then
        boPurity2 := True;
      if StdItem.Shape = 210 then
        boMundane1 := True;
      if StdItem.Shape = 212 then
        boNokChi1 := True;
      if StdItem.Shape = 214 then
        boTaoBu1 := True;
      if StdItem.Shape = 217 then
        boFiveString2 := True;
      //end;
      //if (i = U_ARMRINGL) or (i = U_ARMRINGR) then begin
      if (StdItem.Source <= -1) and (StdItem.Source >= -50) then
      begin // -1 to -50
        m_AddAbil.btUndead := m_AddAbil.btUndead + -StdItem.Source; //Holy+
      end;
      if (StdItem.Source <= -51) and (StdItem.Source >= -100) then
      begin // -51 to -100
        m_AddAbil.btUndead := m_AddAbil.btUndead + (StdItem.Source + 50); //Holy-
      end;

      if StdItem.Shape = 124 then
        boRecallSuite[2] := True;
      if StdItem.Shape = 126 then
        boSpirit[2] := True;
      if StdItem.Shape = 145 then
        m_boGuildMove := True;
      if StdItem.Shape = 134 then
      begin
        boMoXieSuite[2] := True;
        Inc(m_nMoXieSuite, StdItem.AniCount);
      end;
      if StdItem.Shape = 137 then
      begin
        boHongMoSuite3 := True;
        Inc(m_nHongMoSuite, StdItem.AniCount);
      end;
      if StdItem.Shape = 202 then
        boSmash3 := True;
      if StdItem.Shape = 205 then
        boHwanDevil3 := True;
      if StdItem.Shape = 208 then
        boPurity3 := True;
      if StdItem.Shape = 211 then
        boMundane2 := True;
      if StdItem.Shape = 213 then
        boNokChi2 := True;
      if StdItem.Shape = 215 then
        boTaoBu2 := True;
      if StdItem.Shape = 218 then
        boFiveString3 := True;
      //end;
      //if (i = U_HELMET) then begin
      if StdItem.Shape = 125 then
        boRecallSuite[3] := True;
      if StdItem.Shape = 129 then
        boSpirit[3] := True;
      //end;
    end;
{$ENDREGION}
{$REGION '处理套装属性'}
    if m_btRaceServer in [RC_PLAYOBJECT] then
    begin //只有人类才处理套装
      for I := 0 to SuitItemList.Count - 1 do
      begin
        SuitItems := SuitItemList.Items[I];
        if I > High(SuitIdx) then
          break;
        if TPlayObject(Self).m_SuitIdx[I] = 0 then
          boShow := True
        else
          boShow := False;
        if SuitIdx[I] >= SuitItems.nCount then
        begin
          TPlayObject(Self).m_SuitIdx[I] := 1;
          m_AddAbil.wHP := m_AddAbil.wHP + SuitItems.nPoint[0];
          m_AddAbil.wMP := m_AddAbil.wMP + SuitItems.nPoint[1];
          Inc(m_nSuitMonExpRate, Trunc(SuitItems.nPoint[2] / 10));
          m_AddAbil.wDC := MakeLong(LoWord(m_AddAbil.wDC) + SuitItems.nPoint[3],
            HiWord(m_AddAbil.wDC) + SuitItems.nPoint[4]);
          m_AddAbil.wMC := MakeLong(LoWord(m_AddAbil.wMC) + SuitItems.nPoint[6],
            HiWord(m_AddAbil.wMC) + SuitItems.nPoint[7]);
          m_AddAbil.wSC := MakeLong(LoWord(m_AddAbil.wSC) + SuitItems.nPoint[9],
            HiWord(m_AddAbil.wSC) + SuitItems.nPoint[10]);
          m_AddAbil.wAC := MakeLong(LoWord(m_AddAbil.wAC) +
            SuitItems.nPoint[12], HiWord(m_AddAbil.wAC) + SuitItems.nPoint[13]);
          m_AddAbil.wMAC := MakeLong(LoWord(m_AddAbil.wMAC) +
            SuitItems.nPoint[15], HiWord(m_AddAbil.wMAC) +
            SuitItems.nPoint[16]);
          Inc(m_AddAbil.wHitPoint, SuitItems.nPoint[18]);
          Inc(m_AddAbil.wSpeedPoint, SuitItems.nPoint[19]);
          Inc(m_AddAbil.wAntiMagic, SuitItems.nPoint[20]);
          Inc(m_AddAbil.wHealthRecover, SuitItems.nPoint[21]);
          Inc(m_AddAbil.wSpellRecover, SuitItems.nPoint[22]);
          Inc(m_AddAbil.wAntiPoison, SuitItems.nPoint[23]);
          Inc(m_AddAbil.wPoisonRecover, SuitItems.nPoint[24]);
          Inc(m_btDiploidRate3, _Min(200 - m_btDiploidRate3,
            SuitItems.nPoint[25]));
          if SuitItems.nPoint[26] > 0 then
            m_boParalysis := True;
          if SuitItems.nPoint[27] > 0 then
            m_boMagicShield := True;
          if SuitItems.nPoint[28] > 0 then
          begin
            m_boRevival := True;
            m_boRevivalnotItem := True;
          end;

          if SuitItems.nPoint[5] > 0 then
          begin
            X := SuitItems.nPoint[5];
            m_AddAbil.wDC := MakeLong(LoWord(m_AddAbil.wDC) + Trunc(X / 10 *
              LoWord(m_AddAbil.wDC)), HiWord(m_AddAbil.wDC) + Trunc(X / 10 *
              HiWord(m_AddAbil.wDC)));
          end;
          if SuitItems.nPoint[8] > 0 then
          begin
            X := SuitItems.nPoint[8];
            m_AddAbil.wMC := MakeLong(LoWord(m_AddAbil.wMC) + Trunc(X / 10 *
              LoWord(m_AddAbil.wMC)), HiWord(m_AddAbil.wMC) + Trunc(X / 10 *
              HiWord(m_AddAbil.wMC)));
          end;
          if SuitItems.nPoint[11] > 0 then
          begin
            X := SuitItems.nPoint[11];
            m_AddAbil.wSC := MakeLong(LoWord(m_AddAbil.wSC) + Trunc(X / 10 *
              LoWord(m_AddAbil.wSC)), HiWord(m_AddAbil.wSC) + Trunc(X / 10 *
              HiWord(m_AddAbil.wSC)));
          end;
          if SuitItems.nPoint[14] > 0 then
          begin
            X := SuitItems.nPoint[14];
            m_AddAbil.wAC := MakeLong(LoWord(m_AddAbil.wAC) + Trunc(X / 10 *
              LoWord(m_AddAbil.wAC)), HiWord(m_AddAbil.wAC) + Trunc(X / 10 *
              HiWord(m_AddAbil.wAC)));
          end;
          if SuitItems.nPoint[17] > 0 then
          begin
            X := SuitItems.nPoint[17];
            m_AddAbil.wMAC := MakeLong(LoWord(m_AddAbil.wMAC) + Trunc(X / 10 *
              LoWord(m_AddAbil.wMAC)), HiWord(m_AddAbil.wMAC) + Trunc(X / 10 *
              HiWord(m_AddAbil.wMAC)));
          end;
          if boShow then
            NpcGotoLable(g_FunctionNpc, '@SuitItem' + IntToStr(I), False);
        end
        else
        begin
          TPlayObject(Self).m_SuitIdx[I] := 0;
          if (not boShow) then
            NpcGotoLable(g_FunctionNpc, '@SuitDownItem' + IntToStr(I), False);
        end;
      end;
    end;
    //m_AddAbil

    if boRecallSuite[0] and
      boRecallSuite[1] and
      boRecallSuite[2] and
      boRecallSuite[3] then
      m_boRecallSuite := True;
    if boMoXieSuite[0] and
      boMoXieSuite[1] and
      boMoXieSuite[2] then
      Inc(m_nMoXieSuite, 50);
    if boHongMoSuite1 and
      boHongMoSuite2 and
      boHongMoSuite3 then
      Inc(m_AddAbil.wHitPoint, 2);

    if boSpirit[0] and
      boSpirit[1] and
      boSpirit[2] and
      boSpirit[3] then
      m_bopirit := True;

    if boSmash1 and boSmash2 and boSmash3 then
      m_boSmashSet := True;
    if boHwanDevil1 and boHwanDevil2 and boHwanDevil3 then
      m_boHwanDevilSet := True;
    if boPurity1 and boPurity2 and boPurity3 then
      m_boPuritySet := True;
    if boMundane1 and boMundane2 then
      m_boMundaneSet := True;
    if boNokChi1 and boNokChi2 then
      m_boNokChiSet := True;
    if boTaoBu1 and boTaoBu2 then
      m_boTaoBuSet := True;
    if boFiveString1 and boFiveString2 and boFiveString3 then
      m_boFiveStringSet := True;

    m_WAbil.Weight := RecalcBagWeight();

    if m_boTransparent and (m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] > 0)
      then //004C08D7
      m_boHideMode := True;

    if m_boHideMode then
    begin //004C08E8
      if not boOldHideMode then
      begin
        m_nCharStatus := GetCharStatus();
        StatusChanged();
      end;
    end
    else
    begin
      if boOldHideMode then
      begin //004C091B
        m_wStatusTimeArr[STATE_TRANSPARENT {8 0x70}] := 0; //0x70
        m_nCharStatus := GetCharStatus();
        StatusChanged();
      end;
    end;

    if m_btRaceServer in [RC_PLAYOBJECT, RC_PLAYCLONE] then
      //01-20 增加此行，只有类型为人物的角色才重新计算攻击敏捷
      RecalcHitSpeed();

    nOldLight := m_nLight;
    if (m_UseItems[U_RIGHTHAND].wIndex > 0) and (m_UseItems[U_RIGHTHAND].Dura >
      0) then
      m_nLight := 3
    else
      m_nLight := 0;
    if nOldLight <> m_nLight then
      SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
{$ENDREGION}
    Inc(m_btSpeedPoint, m_AddAbil.wSpeedPoint); //敏捷度
    Inc(m_btHitPoint, m_AddAbil.wHitPoint); //精确度
    Inc(m_btAntiPoison, m_AddAbil.wAntiPoison);
    Inc(m_nPoisonRecover, m_AddAbil.wPoisonRecover);
    Inc(m_nHealthRecover, m_AddAbil.wHealthRecover);
    Inc(m_nSpellRecover, m_AddAbil.wSpellRecover);
    Inc(m_nAntiMagic, m_AddAbil.wAntiMagic);
    Inc(m_nLuck, m_AddAbil.btLuck);
    Dec(m_nLuck, m_AddAbil.btUnLuck);
    m_nHitSpeed := m_AddAbil.nHitSpeed; //004C0A53

    Inc(m_WAbil.MaxWeight, m_AddAbil.Weight);
    Inc(m_WAbil.MaxWearWeight, m_AddAbil.WearWeight);
    Inc(m_WAbil.MaxHandWeight, m_AddAbil.HandWeight);

    m_WAbil.MaxHP := _MIN(High(Word), m_Abil.MaxHP + m_AddAbil.wHP);
    m_WAbil.MaxMP := _MIN(High(Word), m_Abil.MaxMP + m_AddAbil.wMP);

    m_WAbil.AC := MakeLong(LoWord(m_AddAbil.wAC) + LoWord(m_Abil.AC),
      HiWord(m_AddAbil.wAC) + HiWord(m_Abil.AC));
    m_WAbil.MAC := MakeLong(LoWord(m_AddAbil.wMAC) + LoWord(m_Abil.MAC),
      HiWord(m_AddAbil.wMAC) + HiWord(m_Abil.MAC));
    m_WAbil.DC := MakeLong(LoWord(m_AddAbil.wDC) + LoWord(m_Abil.DC),
      HiWord(m_AddAbil.wDC) + HiWord(m_Abil.DC));
    m_WAbil.MC := MakeLong(LoWord(m_AddAbil.wMC) + LoWord(m_Abil.MC),
      HiWord(m_AddAbil.wMC) + HiWord(m_Abil.MC));
    m_WAbil.SC := MakeLong(LoWord(m_AddAbil.wSC) + LoWord(m_Abil.SC),
      HiWord(m_AddAbil.wSC) + HiWord(m_Abil.SC));

    if m_wStatusTimeArr[STATE_DEFENCEUP {10 0x72}] > 0 then //004C0BCD
      m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC), HiWord(m_WAbil.AC) + 2 +
        (m_Abil.Level div 7));
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP {11 0x74}] > 0 then //004C0C17
      m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC), HiWord(m_WAbil.MAC) + 2 +
        (m_Abil.Level div 7));

    if m_wStatusTimeArr[STATE_ARRAYDC] > 0 then
    begin
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + 2 +
        m_Abil.DC); //070524灵符咒
    end
    else if m_wStatusArrValue[STATE_DC] > 0 then //  if n218 > 0 then
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_WAbil.DC) + 2 +
        m_wStatusArrValue[STATE_DC] {n218});

    if m_wStatusTimeArr[STATE_ARRAYMC] > 0 then
    begin
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) +
        m_Abil.MC);
      //070524灵符咒
    end
    else if m_wStatusArrValue[STATE_MC] > 0 then //  if n219 > 0 then
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC), HiWord(m_WAbil.MC) + 2 +
        m_wStatusArrValue[STATE_MC] {n219});

    if m_wStatusTimeArr[STATE_ARRAYSC] > 0 then
    begin
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + 2 +
        m_Abil.SC); //070524灵符咒
    end
    else if m_wStatusArrValue[STATE_SC] > 0 then //  if n21A > 0 then
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC), HiWord(m_WAbil.SC) + 2 +
        m_wStatusArrValue[STATE_SC] {n21A});

    if m_wStatusArrValue[3] > 0 then //  if n21B > 0 then
      Inc(m_nHitSpeed, m_wStatusArrValue[3] {n21B});

    if m_wStatusArrValue[4] > 0 then
    begin //  if n21C > 0 then
      //Inc(m_WAbil.MaxHP,m_wStatusArrValue[4]{n21C});
      m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_wStatusArrValue[4]);
    end;

    if m_wStatusArrValue[5] > 0 then
    begin //  if n21D > 0 then
      //Inc(m_WAbil.MaxMP,m_wStatusArrValue[5]{n21D});
      m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_wStatusArrValue[5]);
    end;

    if m_boFlameRing then
      AddItemSkill(1)
    else
      DelItemSkill(1);

    if m_boRecoveryRing then
      AddItemSkill(2)
    else
      DelItemSkill(2);

    if m_boMuscleRing then
    begin //活力
      Inc(m_WAbil.MaxWeight, m_WAbil.MaxWeight);
      Inc(m_WAbil.MaxWearWeight, m_WAbil.MaxWearWeight);
      Inc(m_WAbil.MaxHandWeight, m_WAbil.MaxHandWeight);
    end;
    if m_nMoXieSuite > 0 then
    begin //魔血
      if m_WAbil.MaxMP <= m_nMoXieSuite then
        m_nMoXieSuite := m_WAbil.MaxMP - 1;
      Dec(m_WAbil.MaxMP, m_nMoXieSuite);
      //Inc(m_WAbil.MaxHP,m_nMoXieSuite);
      m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_nMoXieSuite);
    end;
    if m_bopirit then
    begin //Bonus DC Min +2,DC Max +5,A.Speed + 2
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + 2, HiWord(m_WAbil.DC) + 2 +
        5);
      Inc(m_nHitSpeed, 2);
    end;
    if m_boSmashSet then
    begin //Attack Speed +1, DC1-3
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + 1, HiWord(m_WAbil.DC) + 2 +
        3);
      Inc(m_nHitSpeed);
    end;
    if m_boHwanDevilSet then
    begin
      //Hand Carrying Weight Increase +5, Bag Weight Limit Increase +20, +MC 1-2
      Inc(m_WAbil.MaxHandWeight, 5);
      Inc(m_WAbil.MaxWeight, 20);
      m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + 1, HiWord(m_WAbil.MC) + 2 +
        2);
    end;
    if m_boPuritySet then
    begin //Holy +3, Sc 1-2
      m_AddAbil.btUndead := m_AddAbil.btUndead + -3;
      m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + 1, HiWord(m_WAbil.SC) + 2 +
        2);
    end;
    if m_boMundaneSet then
    begin //Bonus of Hp+50
      m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + 50);
    end;
    if m_boNokChiSet then
    begin //Bonus of Mp+50
      m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + 50);
    end;
    if m_boTaoBuSet then
    begin //Bonus of Hp+30, Mp+30
      m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + 30);
      m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + 30);
    end;
    if m_boFiveStringSet then
    begin //Bonus of Hp +30%, Ac+2
      m_WAbil.MaxHP := _MIN(High(Word), (m_WAbil.MaxHP div 100) * 30);
      Inc(m_btHitPoint, 2);
    end;
  //处理酒馆附加属性数据
    if (not m_boDeath) and (m_btRaceServer = RC_PLAYOBJECT) then
     begin
        if m_boskill84open and (m_skill84Abil>0) then //酒气护体附加值
          m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_skill84Abil);

        FillChar(m_MedicineAbil,SizeOf(m_MedicineAbil),0);
         if m_MedicineRec.MedicineLevel>0 then
        for i:=0 to m_MedicineRec.MedicineLevel-1 do
          Inc(m_MedicineAbil[i mod 6],g_Config.nMedicineIncAbil); //计算药力等级永久附加值

//处理药酒的临时属性
       if m_MedicineAbilTemp[0]>0 then
       begin
         case m_btJob of
          jWarr:
            begin
              m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC)+ m_MedicineAbilTemp[0]),Round(HiWord(m_WAbil.DC)));
            end;
         jWizard:
           begin
             m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC)+ m_MedicineAbilTemp[0]),Round(HiWord(m_WAbil.MC)));
           end;
         jTaos:
           begin
             m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC)+ m_MedicineAbilTemp[0]),Round(HiWord(m_WAbil.SC)));
           end;
        end;
       end;

       if m_MedicineAbilTemp[1]>0 then
        m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_MedicineAbilTemp[1]);

       if m_MedicineAbilTemp[2]>0 then
         m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_MedicineAbilTemp[2]);

       if m_MedicineAbilTemp[3]>0 then
        m_WAbil.AC := MakeLong(Round(LoWord(m_WAbil.AC)+m_MedicineAbilTemp[3]),Round(HiWord(m_WAbil.AC)));

        if m_MedicineAbilTemp[4]>0 then
         Inc(m_btSpeedPoint,m_MedicineAbilTemp[4]); //敏捷度


       //酒醉了减魔法躲避 体力恢复
      if m_boRUNK then
       begin
        if m_RUNKarray[0]>0 then
        begin
         if m_nHealthRecover>0 then
          Dec(m_nHealthRecover,m_RUNKarray[0]) //体力恢复
         else
          m_RUNKarray[0]:=0;
          m_boRUNK:=False;
        end;
         if m_RUNKarray[1]>0 then
         begin
           if m_nAntiMagic>0 then
            Dec(m_nAntiMagic,m_RUNKarray[1])  //魔法躲避
           else
            m_RUNKarray[1]:=0;
           m_boRUNK:=False;
         end;
       end;
     //   for i:=0 to High(m_MedicineAbilTemp) do
       //   MainOutMessage('m_MedicineAbilTemp['+inttostr(i)+']'+inttostr(m_MedicineAbilTemp[i]));
        // Inc(m_btHitPoint, m_AddAbil.wHitPoint); //精确度
/////////////////////////////////

       if (m_WineRec.Alcoho>0) and (m_SKILL83Rec.skill83Abil>0) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)>=g_Config.nMinDrinkValue83) then //先天元力附加值
         begin
          m_WAbil.MAC := MakeLong(Round(LoWord(m_WAbil.MAC)+m_SKILL83Rec.skill83Abil),Round(HiWord(m_WAbil.MAC)));
          m_WAbil.AC := MakeLong(Round(LoWord(m_WAbil.AC)+m_SKILL83Rec.skill83Abil),Round(HiWord(m_WAbil.AC)));
     //     MainOutMessage('skill83');
         end;

    //     for i:=0 to High(m_MedicineAbil) do
    //      MainOutMessage('m_MedicineAbil['+inttostr(i)+']'+inttostr(m_MedicineAbil[i]));

        m_WAbil.MAC := MakeLong(Round(LoWord(m_WAbil.MAC)+ m_MedicineAbil[0]),Round(HiWord(m_WAbil.MAC)+m_MedicineAbil[3]));
        m_WAbil.AC := MakeLong(Round(LoWord(m_WAbil.AC)+ m_MedicineAbil[1]),Round(HiWord(m_WAbil.AC)+m_MedicineAbil[4]));
       case m_btJob of
        jWarr:
          begin
            m_WAbil.DC := MakeLong(Round(LoWord(m_WAbil.DC)+ m_MedicineAbil[2]),Round(HiWord(m_WAbil.DC)+m_MedicineAbil[5]));
          end;
       jWizard:
         begin
           m_WAbil.MC := MakeLong(Round(LoWord(m_WAbil.MC)+ m_MedicineAbil[2]),Round(HiWord(m_WAbil.MC)+m_MedicineAbil[5]));
        end;
       jTaos:
         begin
           m_WAbil.SC := MakeLong(Round(LoWord(m_WAbil.SC)+ m_MedicineAbil[2]),Round(HiWord(m_WAbil.SC)+m_MedicineAbil[5]));
           end;
      end;
     end;

    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      SendUpdateMsg(Self, RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0,
        0,
        '');
    end;

    if (m_btRaceServer >= RC_ANIMAL) and (m_btRaceServer <> RC_PLAYCLONE) then
    begin //004C0EA0
      MonsterRecalcAbilitys();
    end;

    //限制最高属性
    m_WAbil.AC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.AC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.AC)));
    m_WAbil.MAC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MAC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.MAC)));
    m_WAbil.DC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.DC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.DC)));
    m_WAbil.MC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.MC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.MC)));
    m_WAbil.SC := MakeLong(_MIN(MAXHUMPOWER, LoWord(m_WAbil.SC)),
      _MIN(MAXHUMPOWER, HiWord(m_WAbil.SC)));

  except
    MainOutMessage('[Exception] TBaseObject.RecalcAbilitys');
  end;
end;

procedure TBaseObject.BreakOpenHealth(); //004BDCD0
begin
  try
    if m_boShowHP then
    begin
      m_boShowHP := False;
      m_nCharStatusEx := m_nCharStatusEx xor STATE_OPENHEATH;
      m_nCharStatus := GetCharStatus();
      SendRefMsg(RM_CLOSEHEALTH, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TBaseObject.BreakOpenHealth');
  end;
end;

procedure TBaseObject.MakeOpenHealth(); //004BDC7C
begin
  try
    m_boShowHP := True;
    m_nCharStatusEx := m_nCharStatusEx or STATE_OPENHEATH;
    m_nCharStatus := GetCharStatus();
    SendRefMsg(RM_OPENHEALTH, 0, m_WAbil.HP, m_WAbil.MaxHP, 0, ''); //发送HP
  except
    MainOutMessage('[Exception] TBaseObject.MakeOpenHealth');
  end;
end;

procedure TBaseObject.IncHealthSpell(nHP, nMP: Integer); //004BCAA4
begin
  try
    if (nHP < 0) or (nMP < 0) then
      exit;
    if (m_WAbil.HP + nHP) >= m_WAbil.MaxHP then
      m_WAbil.HP := m_WAbil.MaxHP
    else
      Inc(m_WAbil.HP, nHP);
    if (m_WAbil.MP + nMP) >= m_WAbil.MaxMP then
      m_WAbil.MP := m_WAbil.MaxMP
    else
      Inc(m_WAbil.MP, nMP);
    HealthSpellChanged();
  except
    MainOutMessage('[Exception] TBaseObject.IncHealthSpell');
  end;
end;

procedure TBaseObject.ItemDamageRevivalRing(); //004C022C
var
  i: integer;
  pSItem: TItem;
  nDura, tDura: Integer;
  PlayObject: TPlayObject;
begin
  try
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        pSItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if pSItem <> nil then
        begin
          //        if (i = U_RINGR) or (i = U_RINGL) then begin
          if (pSItem.Shape in [114, 160, 161, 162]) or (((i = U_WEAPON) or (i =
            U_RIGHTHAND)) and (pSItem.AniCount in [114, 160, 161, 162])) then
          begin
            nDura := m_UseItems[i].Dura;
            tDura := Round(nDura / 1000 {1.03});
            Dec(nDura, 1000);
            if nDura <= 0 then
            begin
              nDura := 0;
              m_UseItems[i].Dura := nDura;
              if m_btRaceServer = RC_PLAYOBJECT then
              begin
                PlayObject := TPlayObject(Self);
                PlayObject.SendDelItems(@m_UseItems[i]);
              end; //004C0310
              m_UseItems[i].wIndex := 0;
              RecalcAbilitys();
            end
            else
            begin //004C0331
              m_UseItems[i].Dura := nDura;
            end;
            if tDura <> Round(nDura / 1000 {1.03}) then
            begin
              SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0,
                '');
            end;
            //break;
          end; //004C0397
          //        end;//004C0397
        end; //004C0397 if pSItem <> nil then begin
      end; //if UseItems[i].wIndex > 0 then begin
    end; // for i:=Low(UseItems) to High(UseItems) do begin
  except
    MainOutMessage('[Exception] TBaseObject.ItemDamageRevivalRing');
  end;
end;

procedure TBaseObject.Run; //004C7720
var
  i: integer;
  boChg: Boolean;
  boNeedRecalc,boNeedRecalc1: Boolean;
  nHP, nMP, n18: Integer; //
  dwC, dwInChsTime,dwincTick,dwdecTick: LongWord;
  ProcessMsg: TProcessMessage;
  BaseObject: TBaseObject;
  nCheckCode: Integer;
  dwRunTick: LongWord;
  nInteger: Integer;
  StdItem: TItem;
  nCount, dCount, bCount: Integer;
  Castle: TUserCastle;
resourcestring
  sExceptionMsg0 = '[Exception] TBaseObject::Run 0 code:%d';
  sExceptionMsg1 = '[Exception] TBaseObject::Run 1';
  sExceptionMsg2 = '[Exception] TBaseObject::Run 2';
  sExceptionMsg3 = '[Exception] TBaseObject::Run 3';
  sExceptionMsg4 = '[Exception] TBaseObject::Run 4 Code:%d';
  sExceptionMsg5 = '[Exception] TBaseObject::Run 5';
  sExceptionMsg6 = '[Exception] TBaseObject::Run 6';
  sExceptionMsg7 = '[Exception] TBaseObject::Run 7';
begin
  try
    nCheckCode := 0;
    dwRunTick := GetTickCount();
    try
      while GetMessage(@ProcessMsg) do
      begin
        nCheckCode := 1000;
        Operate(@ProcessMsg);
        nCheckCode := 1001;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(Format(sExceptionMsg0, [nCheckCode]));
        MainOutMessage(E.Message);
      end;
    end;
    //SetProcessName('TBaseObject.Run 1');
    //004C7798
    try
      if m_boSuperMan then
      begin
        m_WAbil.HP := m_WAbil.MaxHP;
        m_WAbil.MP := m_WAbil.MaxMP;
      end;
      //004C77DA
      dwC := (GetTickCount() - m_dwHPMPTick) div 20;
      m_dwHPMPTick := GetTickCount();
      Inc(m_nHealthTick, dwC);
      Inc(m_nSpellTick, dwC);
      //004C781D
      if not m_boDeath then
      begin
        if (m_WAbil.HP < m_WAbil.MaxHP) and (m_nHealthTick >=
          g_Config.nHealthFillTime) then
        begin
          n18 := (m_WAbil.MaxHP div 75) + 1;
          //nPlus = m_WAbility.MaxHP / 15 + 1;
          if (m_WAbil.HP + n18) < m_WAbil.MaxHP then
          begin
            Inc(m_WAbil.HP, n18);
          end
          else
          begin
            m_WAbil.HP := m_WAbil.MaxHP;
          end;
          HealthSpellChanged;
        end;
        //004C78AF
        if (m_WAbil.MP < m_WAbil.MaxMP) and (m_nSpellTick >=
          g_Config.nSpellFillTime) then
        begin
          n18 := (m_WAbil.MaxMP div 18) + 1;
          if (m_WAbil.MP + n18) < m_WAbil.MaxMP then
          begin
            Inc(m_WAbil.MP, n18);
          end
          else
          begin
            m_WAbil.MP := m_WAbil.MaxMP;
          end;
          HealthSpellChanged;
        end;

        //004C7934
        if m_WAbil.HP = 0 then
        begin
          if ((m_LastHiter = nil) or not m_LastHiter.m_boUnRevival {防复活})
            and m_boRevival and (GetTickCount - m_dwRevivalTick >
            g_Config.dwRevivalTime {60 * 1000}) then
          begin
            m_dwRevivalTick := GetTickCount();
            if not m_boRevivalnotItem then
              ItemDamageRevivalRing;
            m_WAbil.HP := m_WAbil.MaxHP;
            HealthSpellChanged;
            SysMsg(g_sRevivalRecoverMsg {'复活戒指生效，体力恢复'},
              c_Green, t_Hint);
          end;
          if m_WAbil.HP = 0 then
            Die;
        end;
        if m_nHealthTick >= g_Config.nHealthFillTime then
          m_nHealthTick := 0;
        if m_nSpellTick >= g_Config.nSpellFillTime then
          m_nSpellTick := 0;
      end
      else
      begin
        if not m_boHero then //把英雄和人物的尸体清理分开处理
        begin
          if ((not m_boSkeleton) and (m_btRaceServer = RC_PLAYCLONE) and (m_CloneHum=nil)) or
          (m_btRaceServer = RC_PLAYOBJECT) or ((not m_boSkeleton) and (m_boAnimal)) then
          //人物 人形怪 可挖类尸体
           begin
              if (GetTickCount() - m_dwDeathTick) > g_Config.dwMakeGhostTime then
                 MakeGhost();
           end else
           begin
             if (GetTickCount() - m_dwDeathTick) > g_Config.dwMakeMonGhostTime then
                 MakeGhost();
           end;
        end else
        begin
          if (GetTickCount() - m_dwDeathTick) > g_Config.nClearHeroGhostTick then
            MakeGhost();
        end;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg1);
        MainOutMessage(E.Message);
      end;
    end;

    //血气石处理开始
    try
      if (not m_boDeath) and (m_btRaceServer in [RC_PLAYOBJECT, RC_PLAYCLONE])
        then
      begin
        //加HP
        if (m_nIncHealth = 0) and
          (m_UseItems[U_CHARM].wIndex > 0) and
          ((GetTickCount - m_nIncHPStoneTime) > g_Config.HPStoneIntervalTime)
          and
          ((m_WAbil.HP / m_WAbil.MaxHP * 100) < g_Config.HPStoneStartRate) then
        begin
          m_nIncHPStoneTime := GetTickCount;
          StdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
          if (StdItem.StdMode = 7) and (StdItem.Shape in [1, 3]) then
          begin
            nCount := m_UseItems[U_CHARM].Dura * 10;
            bCount := Trunc(nCount / g_Config.HPStoneAddRate);
            dCount := m_WAbil.MaxHP - m_WAbil.HP;
            if dCount > bCount then
              dCount := bCount;
            //MainOutMessage(Format('%d/%d',[nCount,dCount]));
            if nCount > dCount then
            begin
              //Dec(nCount,dCount);
              Inc(m_nIncHealth, dCount);
              Dec(m_UseItems[U_CHARM].Dura, Round(dCount / 10));
            end
            else
            begin
              nCount := 0;
              Inc(m_nIncHealth, nCount);
              m_UseItems[U_CHARM].Dura := 0;
            end;
            if m_UseItems[U_CHARM].Dura >= 1000 then
            begin
              if m_btRaceServer = RC_PLAYOBJECT then
                SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura,
                  m_UseItems[U_CHARM].DuraMax, 0, '');
            end
            else
            begin
              m_UseItems[U_CHARM].Dura := 0;
              if m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(Self).SendDelItems(@m_UseItems[U_CHARM]);
              m_UseItems[U_CHARM].wIndex := 0;
            end;
          end;
        end;
        //加MP
        if (m_nIncSpell = 0) and
          (m_UseItems[U_CHARM].wIndex > 0) and
          ((GetTickCount - m_nIncMPStoneTime) > g_Config.MPStoneIntervalTime)
          and
          ((m_WAbil.MP / m_WAbil.MaxMP * 100) < g_Config.MPStoneStartRate) then
        begin
          m_nIncMPStoneTime := GetTickCount;
          StdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
          if (StdItem.StdMode = 7) and (StdItem.Shape in [2, 3]) then
          begin
            nCount := m_UseItems[U_CHARM].Dura * 10;
            bCount := Trunc(nCount / g_Config.MPStoneAddRate);
            dCount := m_WAbil.MaxMP - m_WAbil.MP;
            if dCount > bCount then
              dCount := bCount;
            if nCount > dCount then
            begin
              //Dec(nCount,dCount);
              Inc(m_nIncSpell, dCount);
              Dec(m_UseItems[U_CHARM].Dura, Round(dCount / 10));
            end
            else
            begin
              nCount := 0;
              Inc(m_nIncSpell, nCount);
              m_UseItems[U_CHARM].Dura := 0;
            end;
            if m_UseItems[U_CHARM].Dura >= 1000 then
            begin
              if m_btRaceServer = RC_PLAYOBJECT then
                SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura,
                  m_UseItems[U_CHARM].DuraMax, 0, '');
            end
            else
            begin
              m_UseItems[U_CHARM].Dura := 0;
              if m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(Self).SendDelItems(@m_UseItems[U_CHARM]);
              m_UseItems[U_CHARM].wIndex := 0;
            end;
          end;
        end;

      end;
    except
      MainOutMessage(sExceptionMsg7);
    end;
    //血气石处理结束

    if (m_PEnvir.Flag.boMission) and
      ((not (m_btRaceServer in [RC_PLAYOBJECT, RC_135, RC_136, RC_NPC])) or
      m_boHero) then
    begin
      MakeGhost;
    end;

    if m_boOpenShield and (m_dwOpenShieldTime > 0) and (GetTickCount >
      m_dwOpenShieldTime) then
      ChangeShieldMode(False);

    //004C7A34
    try
      if not m_boDeath and ((m_nIncSpell > 0) or (m_nIncHealth > 0) or
        (m_nIncHealing > 0)) then
      begin
        //004C7A7A
        dwInChsTime := 600 - _MIN(400, m_Abil.Level * 10);

        if ((GetTickCount - m_dwIncHealthSpellTick) >= dwInChsTime) and not
          m_boDeath then
        begin
          dwC := _MIN(200, (GetTickCount - m_dwIncHealthSpellTick -
            dwInChsTime));
          m_dwIncHealthSpellTick := GetTickCount() + dwC;
          if (m_nIncSpell > 0) or (m_nIncHealth > 0) or (m_nPerHealing > 0) then
          begin
            //004C7B1C

            if (m_nPerHealth <= 0) then
              m_nPerHealth := 1;
            if (m_nPerSpell <= 0) then
              m_nPerSpell := 1;
            if (m_nPerHealing <= 0) then
              m_nPerHealing := 1;

            //004C7B67
            if m_nIncHealth < m_nPerHealth then
            begin
              nHP := m_nIncHealth;
              m_nIncHealth := 0;
            end
            else
            begin
              //004C7B94
              nHP := m_nPerHealth;
              Dec(m_nIncHealth, m_nPerHealth);
            end;

            //004C7BB2
            if m_nIncSpell < m_nPerSpell then
            begin
              nMP := m_nIncSpell;
              m_nIncSpell := 0;
            end
            else
            begin
              //004C7BDF
              nMP := m_nPerSpell;
              Dec(m_nIncSpell, m_nPerSpell);
            end;

            //004C7BFD
            if m_nIncHealing < m_nPerHealing then
            begin
              Inc(nHP, m_nIncHealing);
              m_nIncHealing := 0;
            end
            else
            begin
              //004C7C2A
              Inc(nHP, m_nPerHealing);
              Dec(m_nIncHealing, m_nPerHealing);
            end;
            m_nPerHealth := (m_Abil.Level div 10 + 5);
            m_nPerSpell := (m_Abil.Level div 10 + 5);
            m_nPerHealing := 5;
            IncHealthSpell(nHP, nMP);

            //004C7C9B
            if m_WAbil.HP = m_WAbil.MaxHP then
            begin
              m_nIncHealth := 0;
              m_nIncHealing := 0;
            end;
            if m_WAbil.MP = m_WAbil.MaxMP then
            begin
              m_nIncSpell := 0;
            end;
          end;
        end;
      end
      else
      begin //004C7CEA
        m_dwIncHealthSpellTick := GetTickCount();
      end;
      //004C7CF8
      if (m_nHealthTick < -g_Config.nHealthFillTime) and (m_WAbil.HP > 1) then
      begin //Jacky ????
        dec(m_WAbil.HP);
        Inc(m_nHealthTick, g_Config.nHealthFillTime);
        HealthSpellChanged();
      end;
      //检查HP/MP值是否大于最大值，大于则降低到正常大小
      boNeedRecalc := False;

      if m_WAbil.HP > m_WAbil.MaxHP then
      begin
        boNeedRecalc := True;
        m_WAbil.HP := m_WAbil.MaxHP - 1;
      end;
      if m_WAbil.MP > m_WAbil.MaxMP then
      begin
        boNeedRecalc := True;
        m_WAbil.MP := m_WAbil.MaxMP - 1;
      end;
      if boNeedRecalc then
        HealthSpellChanged();

    except
      MainOutMessage(sExceptionMsg2);
    end;

    if (m_boAutoGhost) and (not m_boGhost) and (not m_boDeath) then
    begin
      if (m_Master2 = nil) or
        (m_Master2.m_boGhost) or
        (m_Master2.m_boDeath) or
        (m_Master2.m_PEnvir <> m_PEnvir) then
        MakeGhost;
    end;

    //004C7D59
    //TBaseObject.Run 3 清理目标对象
    try
      if (m_TargetCret <> nil) then
      begin
        if ((GetTickCount() - m_dwTargetFocusTick) > 30000) or
          m_TargetCret.m_boDeath or
          m_TargetCret.m_boGhost or
          (m_TargetCret.m_PEnvir <> m_PEnvir) or
          // 08/06 增加，弓箭卫士在人物进入房间后再出来，还会攻击人物(人物的攻击目标没清除)
        (abs(m_TargetCret.m_nCurrX - m_nCurrX) > 15) or
          (abs(m_TargetCret.m_nCurrY - m_nCurrY) > 15) then
        begin
          //004C7DE4
          m_TargetCret := nil;
        end;
      end;
      //004C7DEF
      if (m_LastHiter <> nil) then
      begin
        if ((GetTickCount() - m_LastHiterTick) > 30000) or
          m_LastHiter.m_boDeath or
          m_LastHiter.m_boGhost then
        begin
          //004C7E34
          m_LastHiter := nil;
        end;
      end;
      //004C7E3F
      //
      if (m_ExpHitter <> nil) then
      begin
        if ((GetTickCount() - m_ExpHitterTick) > 6000) or
          m_ExpHitter.m_boDeath or
          m_ExpHitter.m_boGhost then
        begin
          //004C7E84
          m_ExpHitter := nil;
        end;
      end;
      //004C7E8F
      if (m_Master2 <> nil) then
      begin
        m_boNoItem := True;
        //宝宝变色
        if m_boAutoChangeColor and (GetTickCount - m_dwAutoChangeColorTick >
          LongWord(g_Config.dwBBMonAutoChangeColorTime)) then
        begin
          m_dwAutoChangeColorTick := GetTickCount();
          case m_nAutoChangeIdx of //
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCKSPELL;
            6: nInteger := POISON_DAMAGEARMOR;
          else
            begin
              m_nAutoChangeIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          Inc(m_nAutoChangeIdx);
          m_nCharStatus := LongWord(m_nCharStatusEx and $FFFFF) or (($80000000
            shr nInteger) or 0);
          StatusChanged();
        end;
        if m_boFixColor and (m_nFixStatus <> m_nCharStatus) then
        begin
          case m_nFixColorIdx of //
            0: nInteger := STATE_TRANSPARENT;
            1: nInteger := POISON_STONE;
            2: nInteger := POISON_DONTMOVE;
            3: nInteger := POISON_68;
            4: nInteger := POISON_DECHEALTH;
            5: nInteger := POISON_LOCKSPELL;
            6: nInteger := POISON_DAMAGEARMOR;
          else
            begin
              m_nFixColorIdx := 0;
              nInteger := STATE_TRANSPARENT;
            end;
          end;
          m_nCharStatus := LongWord(m_nCharStatusEx and $FFFFF) or (($80000000
            shr nInteger) or 0);
          m_nFixStatus := m_nCharStatus;
          StatusChanged();
        end;

        // 宝宝在主人死亡后死亡处理
        if (m_Master2.m_boDeath and ((GetTickCount - m_Master2.m_dwDeathTick) >
          1000)) then
        begin
          if g_Config.boMasterDieMutiny and (m_Master2.m_LastHiter <> nil) and
            (Random(g_Config.nMasterDieMutinyRate) = 0) then
          begin
            m_Master2 := nil;
            m_AllMaster := nil;
            m_btSlaveExpLevel := High(g_Config.SlaveColor);
            RecalcAbilitys();
            m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) *
              g_Config.nMasterDieMutinyPower, HiWord(m_WAbil.DC) *
              g_Config.nMasterDieMutinyPower);
            m_nWalkSpeed := m_nWalkSpeed div g_Config.nMasterDieMutinySpeed;
            RefNameColor;
            RefShowName;
          end
          else
          begin
            //004C7EFF
            m_WAbil.HP := 0;
          end;
        end;
        if m_Master2.m_boGhost and ((GetTickCount - m_Master2.m_dwGhostTick) >
          1000) then
        begin
          MakeGhost;
        end;

      end;
      //004C7F0B
      //清除宝宝列表中已经死亡及叛变的宝宝信息
      for i := m_SlaveList.Count - 1 downto 0 do
      begin
        if TBaseObject(m_SlaveList.Items[i]).m_boDeath or
          TBaseObject(m_SlaveList.Items[i]).m_boGhost or
          (TBaseObject(m_SlaveList.Items[i]).m_Master2 <> Self) then

          m_SlaveList.Delete(i);
      end;
      //004C7F8A
      if m_boHolySeize and ((GetTickCount() - m_dwHolySeizeTick) >
        m_dwHolySeizeInterval) then
      begin
        BreakHolySeizeMode();
      end;
      //004C7FB7
      if m_boCrazyMode and ((GetTickCount() - m_dwCrazyModeTick) >
        m_dwCrazyModeInterval) then
      begin
        BreakCrazyMode();
      end;
      if m_boShowHP and ((GetTickCount() - m_dwShowHPTick) > m_dwShowHPInterval)
        then
      begin
        BreakOpenHealth();
      end;
    except
      MainOutMessage(sExceptionMsg3);
    end;

    //SetProcessName('TBaseObject.Run ');
    //004C802F
    try
      nCheckCode := 4;
      // 减少PK值开始
      if (GetTickCount() - m_dwDecPkPointTick) > g_Config.dwDecPkPointTime
        {120000}then
      begin
        m_dwDecPkPointTick := GetTickCount();
        if m_nPkPoint > 0 then
        begin
          DecPKPoint(g_Config.nDecPkPointCount {1});
        end;
      end;
      // 减少PK值结束

      //检查照明物品及PK状态 开始
      nCheckCode := 41;
      if (GetTickCount - m_DecLightItemDrugTick) >
        g_Config.dwDecLightItemDrugTime {500} then
      begin
        Inc(m_DecLightItemDrugTick, g_Config.dwDecLightItemDrugTime {500});
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          UseLamp();
          CheckPKStatus();
        end;
      end;
      //检查照明物品及PK状态 结束

      nCheckCode := 42;
      if (GetTickCount - m_dwCheckRoyaltyTick) > 10000 then
      begin
        m_dwCheckRoyaltyTick := GetTickCount();
        if m_Master2 <> nil then
        begin
          if (g_dwSpiritMutinyTick > GetTickCount) and (m_btSlaveExpLevel < 5)
            then
          begin
            m_dwMasterRoyaltyTick := 0;
          end;

          //宝宝叛变  开始
          nCheckCode := 423;
          if (GetTickCount > m_dwMasterRoyaltyTick) then
          begin
            for I := 0 to m_Master2.m_SlaveList.Count - 1 do
            begin
              nCheckCode := 424;
              if m_Master2.m_SlaveList.Items[i] = Self then
              begin
                nCheckCode := 425;
                m_Master2.m_SlaveList.Delete(i);
                break;
              end;
            end;
            m_Master2 := nil;
            m_AllMaster := nil;
            m_WAbil.HP := m_WAbil.HP div 10;
            nCheckCode := 426;
            RefShowName();
          end;
          //宝宝叛变 结束
          nCheckCode := 427;
          if m_dwMasterTick <> 0 then
          begin
            if (GetTickCount - m_dwMasterTick) > 12 * 60 * 60 * 1000 then
            begin
              m_WAbil.HP := 0;
            end;
          end;
        end; //004C81DB
      end;
      nCheckCode := 43;
      if (GetTickCount - m_dwVerifyTick) > 30 * 1000 then
      begin
        m_dwVerifyTick := GetTickCount();
        // 清组队已死亡成员
        if (m_GroupOwner <> nil) then
        begin
          if m_GroupOwner.m_boDeath or m_GroupOwner.m_boGhost then
          begin
            m_GroupOwner := nil;
          end;
        end;
        nCheckCode := 44;
        if m_GroupOwner = Self then
        begin
          for I := m_GroupMembers.Count - 1 downto 0 do
          begin
            BaseObject := TBaseObject(m_GroupMembers.Objects[i]);
            if BaseObject.m_boDeath or (BaseObject.m_boGhost) then
              m_GroupMembers.Delete(i);
          end;
        end;
        // 清组队已死亡成员 结束
        nCheckCode := 45;
        // 检查交易双方 状态
        if (m_DealCreat <> nil) and (m_DealCreat.m_boGhost) then
          m_DealCreat := nil;
        nCheckCode := 46;
        if not m_boDenyRefStatus then
          m_PEnvir.VerifyMapTime(m_nCurrX, m_nCurrY, Self);
        //刷新在地图上位置的时间
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg4, [nCheckCode]));
        MainOutMessage(E.Message);
      end;
    end;

    //SetProcessName('TBaseObject.Run 5');
    try
      boChg := False;
      boNeedRecalc := False;
      boNeedRecalc1:=False;
      //004C832E
  //    for i:=0 to MAX_STATUS_ATTRIBUTE - 1 do begin
      for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
      begin //004C832E
        if (m_wStatusTimeArr[i] > 0) and (m_wStatusTimeArr[i] < 60000) then
        begin
          if (GetTickCount() - m_dwStatusArrTick[i]) > 1000 then
          begin
            Dec(m_wStatusTimeArr[i]);
            Inc(m_dwStatusArrTick[i], 1000);
            if (m_wStatusTimeArr[i] = 0) then
            begin
              boChg := True;
              case i of
                STATE_TRANSPARENT:
                  begin
                    m_boHideMode := False;
                  end;
                STATE_DEFENCEUP:
                  begin
                    boNeedRecalc := True;
                    SysMsg('防御力恢复正常.', c_Green, t_Hint);
                  end;
                STATE_MAGDEFENCEUP:
                  begin
                    boNeedRecalc := True;
                    SysMsg('魔法防御力恢复正常.', c_Green, t_Hint);
                  end;
                STATE_ARRAYDC:
                  begin
                    boNeedRecalc := True;
                    SysMsg('攻击力恢复正常.', c_Green, t_Hint);
                  end;
                STATE_ARRAYMC:
                  begin
                    boNeedRecalc := True;
                    SysMsg('魔法攻击力恢复正常.', c_Green, t_Hint);
                  end;
                STATE_ARRAYSC:
                  begin
                    boNeedRecalc := True;
                    SysMsg('道术攻击力恢复正常.', c_Green, t_Hint);
                  end;
                STATE_MAGIC57 ,
                STATE_BUBBLEDEFENCEUP:
                  begin
                    m_boAbilMagBubbleDefence := False;
                  end;
              end;
            end;
          end;
        end;
      end;
      //004C8409
      for i := Low(m_wStatusArrValue) to High(m_wStatusArrValue) do
      begin
        if m_wStatusArrValue {218} [i] > 0 then
        begin
          if GetTickCount() > m_dwStatusArrTimeOutTick {220} [i] then
          begin
            m_wStatusArrValue[i] := 0;
            boNeedRecalc := True;
            case i of
              0:
                begin
                  SysMsg('攻击力恢复正常.', c_Green, t_Hint);
                end;
              1:
                begin
                  SysMsg('魔法攻击力恢复正常.', c_Green, t_Hint);
                end;
              2:
                begin
                  SysMsg('道术攻击力恢复正常.', c_Green, t_Hint);
                end;
              3:
                begin
                  SysMsg('攻击速度恢复正常.', c_Green, t_Hint);
                end;
              4:
                begin
                  SysMsg('生命值恢复正常.', c_Green, t_Hint);
                end;
              5:
                begin
                  SysMsg('魔法值恢复正常.', c_Green, t_Hint);
                end;
              {6: begin  //New
                SysMsg('Removed temporarily decreased attack ability.',c_Green,t_Hint);
              end;}
            end;
          end;
        end;
      end;

  //处理酒馆数据
{$REGION '处理酒馆'}
   if (not m_boDeath) and (m_btRaceServer = RC_PLAYOBJECT) then
     begin
          if (m_WineRec.Alcoho>0) and (GetTickCount>(m_dwdecDrunkScale+(g_Config.nDesDrinkTick*1000))) then
          begin
           if m_WineRec.Alcoho<(m_WineRec.WineValue div 100) then
                 m_WineRec.Alcoho:=0
             else
              Dec(m_WineRec.Alcoho,m_WineRec.WineValue div 100);
           if m_WineRec.Alcoho=0 then
           begin
             SysMsg('酒劲终于消失了,身体也恢复平常的状态',c_Green,t_Hint);
             FillChar(m_MedicineAbilTemp,SizeOf(m_MedicineAbilTemp),0);//药酒的临时属性
             m_boskill84open:=False;
             m_dwSpeedupAlcoholTick:=0;
             m_skill84Abil:=0;
             m_SKILL83Rec.skill83Abil:=0;
             boNeedRecalc:=True;
             if m_RUNKarray[0]>0 then
              inc(m_nHealthRecover,m_RUNKarray[0]);
             if m_RUNKarray[1]>0 then
               inc(m_nAntiMagic,m_RUNKarray[1]);
             FillChar(m_RUNKarray, Sizeof(m_RUNKarray), 0);//酒醒了把醉酒减少的魔法躲避 体力恢复还原
             m_boRUNK:=False;
           end else
           begin
            if (m_SKILL83Rec.skill83Abil<>0) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)<g_Config.nMinDrinkValue83) then //先天元力失效
            begin
             m_SKILL83Rec.skill83Abil:=0;
             boNeedRecalc:=True;
            end;
            if (m_skill84Abil<>0) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)<g_Config.nMinDrinkValue84) then //酒气护体失效
             begin
              m_boskill84open:=False;
              m_skill84Abil:=0;
              boNeedRecalc:=True;
             end;
           end;
           SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
           m_dwdecDrunkScale:=GetTickCount();
          end;

         if (m_dtMedicineAlcohoTime<>0) and (Now>IncSecond(m_dtMedicineAlcohoTime,g_Config.nDesMedicineValue)) then //超过指定时间没有饮药酒下降药力值
         begin
           if g_Config.nDesMedicineTick>m_MedicineRec.MedicineValue then
           begin
            if m_MedicineRec.MedicineLevel>1 then
            Dec(m_MedicineRec.MedicineLevel);
            m_MedicineRec.MaxMedicineValue:=GetMedicineLevelExp(m_MedicineRec.MedicineLevel);//药力值升级值
            m_MedicineRec.MedicineValue:=m_MedicineRec.MaxMedicineValue-(g_Config.nDesMedicineTick-m_MedicineRec.MedicineValue);
            boNeedRecalc:=True;
           end else
           begin
            Dec(m_MedicineRec.MedicineValue,g_Config.nDesMedicineTick);
           end;
           m_dtMedicineAlcohoTime:=now;
           SendMsg(Self, RM_MedicineValue, 0,0, 0,0,'');
         end;
          if (m_dtAlcohoTime<>0) and (Now>IncSecond(m_dtAlcohoTime,g_Config.nDecMaxAlcoholTime)) then //超过指定时间没有饮酒下降酒量
         begin
           if (m_WineRec.WineValue-g_Config.nDecAlcoholValue)<=g_Config.nMaxAlcoholValue then //下降后小于初始值的则等于初始值
           begin
            m_WineRec.WineValue:=g_Config.nMaxAlcoholValue;
            if m_WineRec.Alcoho>m_WineRec.WineValue then
            m_WineRec.Alcoho:=m_WineRec.WineValue;
            GetSkill83LevelAbil();//重新计算先天元力等级
            boNeedRecalc:=True;
           end else
           begin
            Dec(m_WineRec.WineValue,g_Config.nDecAlcoholValue);
            if m_WineRec.Alcoho>m_WineRec.WineValue then
            m_WineRec.Alcoho:=m_WineRec.WineValue;
            GetSkill83LevelAbil();//重新计算先天元力等级
            boNeedRecalc:=True;
           end;
           m_dtAlcohoTime:=Now;
           SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
           SendMsg(Self, RM_SKILL83Value, 0,0, 0,0,'');
         end;

         if (m_WineRec.Alcoho>0) and (GetTickCount>(m_dwnDRUNKTick+(g_Config.nDRUNKTick*1000))) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)>=g_Config.nRUNKValue) then //酒醉状态动画
          begin
             SendRefMsg(RM_DRUNK, 0,0, 0,0,'');//发送酒醉状态动画消息
             m_dwnDRUNKTick:=GetTickCount();
          end;

         if m_WineRec.Alcoho>0 then // 酒量提升进度
         begin
           //处理不同酒醉状态酒量提升进度
            dwincTick:=0;
            dwdecTick:=0;
           if (m_WineRec.Alcoho / m_WineRec.WineValue*100)>=g_Config.nHighDRUNKTick then //高于指定值
             begin
               dwincTick:=(m_dwSpeedupAlcoholTick+g_Config.nHighAlcoholTick)*1000;
               if  m_dwLiquorProgressTime<dwincTick then
                 dwincTick:=0;
             end;

           if (m_WineRec.Alcoho / m_WineRec.WineValue*100)<=g_Config.nlowDRUNKTick then //低于指定值
                dwdecTick:=g_Config.nlowAlcoholTick*1000;

           if GetTickCount>(m_dwLiquorProgressTime+dwdecTick+(g_Config.nIncAlcoholTick*1000)-dwincTick) then
           begin
            Inc(m_bLiquorProgress);
            if m_bLiquorProgress>=100 then
             begin
               Inc(m_WineRec.WineValue,g_Config.nIncAlcoholValue);
               m_bLiquorProgress:=0;
               GetSkill83LevelAbil();//重新计算先天元力等级
                boNeedRecalc:=True;
               SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
               SendMsg(Self, RM_ADDLiquor, 0,0, 0,0,'');//发送酒量提升动画消息
               SendMsg(Self, RM_SKILL83Value, 0,0, 0,0,'');
             end;
             SendMsg(Self, RM_bLiquorProgress, 0,0, 0,0,'');
             m_dwLiquorProgressTime:=GetTickCount();
           end;
        end;

        for i:=0 to High(m_MedicineAbilTemp) do //喝酒药的临时属性
        if  m_MedicineAbilTemp[i]>0 then
         if GetTickCount>(m_MedicineAbilArrTimeOutTick[i]+600000) then
          begin
           m_MedicineAbilTemp[i]:=0;
           if i=4 then boNeedRecalc1:=True;
           boNeedRecalc:=True;
          end;

         if m_MagicSkill84<>nil then //酒气护体
         begin
          if (m_boskill84open) and (GetTickCount>=m_dwskill84Time+(g_Config.nHPUpUseTime*1000)) then
          begin
             m_boskill84open:=False;
             boNeedRecalc:=True;
             m_skill84Abil:=0;
          end;
         end;
    end;
{$ENDREGION}
  //处理泉水喷发
{$REGION '处理泉水喷发'}
  try
      if (not m_boDeath) and (m_btRaceServer = RC_PLAYOBJECT) and (m_bomapFOUNTAIN) and (FOUNTAINEvent<>nil) and (TEvent(FOUNTAINEvent).m_Envir.sMapName=m_sMapName) and (TEvent(FOUNTAINEvent).m_nX=m_nCurrX) and (TEvent(FOUNTAINEvent).m_nY=m_nCurrY) and (GetTickCount>(m_GetfountainTick+(g_Config.nInFountainTime*1000))) then
     begin
       if (m_UseItems[U_BUJUK].wIndex<>0) and (m_UseItems[U_BUJUK].Dura<m_UseItems[U_BUJUK].DuraMax) then
       begin
          StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
          if (StdItem.StdMode=2) and (StdItem.Reserved=56) then//是不是泉水罐
          begin
         //   if g_EventManager.GetEventEx(m_sMapName,m_nCurrX,m_nCurrY,ET_FOUNTAIN) then
          //  begin
              Inc(m_UseItems[U_BUJUK].Dura,100);
              if m_MyGuild<>nil then
              begin
                 TGuild(m_MyGuild).nGuildFountain:=TGuild(m_MyGuild).nGuildFountain+1;
                 Castle := g_CastleManager.IsCastleMember(Self); //是沙成员加沙的泉水
                 if (Castle<>nil) then
                      Castle.nCastleFountain:=Castle.nCastleFountain+1;
              end;
              if m_UseItems[U_BUJUK].Dura>m_UseItems[U_BUJUK].DuraMax then
                 m_UseItems[U_BUJUK].Dura:=m_UseItems[U_BUJUK].DuraMax;
               SendMsg(Self, RM_DURACHANGE,U_BUJUK, m_UseItems[U_BUJUK].Dura,
                  m_UseItems[U_BUJUK].DuraMax, 0, '');
               SendRefMsg(RM_SHOWEFFECT, Effect_100, Integer(Self), m_nCurrX, m_nCurrY,'');
         //   end;
          end;
       end;
      m_GetfountainTick:=GetTickCount;
     end;
  except
  end;
 {$ENDREGION}
      //004C84F5
      if boChg then
      begin
        m_nCharStatus := GetCharStatus();
        StatusChanged();
      end;
      //004C8511
      if boNeedRecalc then
      begin
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      end;
      if boNeedRecalc1 then
         SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    except
      MainOutMessage(sExceptionMsg5);
    end;

    //SetProcessName('TBaseObject.Run 6');
    //004C855A
    try
      if (GetTickCount - m_dwPoisoningTick) > g_Config.dwPosionDecHealthTime
        {2500}then
      begin
        m_dwPoisoningTick := GetTickCount();
        if m_wStatusTimeArr[POISON_DECHEALTH {0 0x60}] > 0 then
        begin
          if m_boAnimal then
            Dec(m_nMeatQuality, 1000);
          DamageHealth(m_btGreenPoisoningPoint + 1);
          m_nHealthTick := 0;
          m_nSpellTick := 0;
          HealthSpellChanged();
        end;
      end;
    except
      MainOutMessage(sExceptionMsg6);
    end;
    {
    if boOpenHealth then begin
      if (GetTickCount() - dwOpenHealthStart) > dwOpenHealthTime then begin
        BreakOpenHealth();
      end;
    end;
    }
    g_nBaseObjTimeMin := GetTickCount - dwRunTick;
    if g_nBaseObjTimeMax < g_nBaseObjTimeMin then
      g_nBaseObjTimeMax := g_nBaseObjTimeMin;

  except
    MainOutMessage('[Exception] TBaseObject.Run');
  end;
end;

function TPlayObject.DayBright: Byte;
begin
  if m_PEnvir.Flag.boDarkness then
    Result := 1
  else if (m_btBright = 1) then
    Result := 0
  else if (m_btBright = 3) then
    Result := 1
  else
    Result := 2;

  if m_PEnvir.Flag.boDayLight then
    Result := 0;
end;

function TBaseObject.GetFrontPosition(var nX: Integer; var nY: Integer):
  Boolean;
//004B2790
var
  Envir: TEnvirnoment;
begin
  Result := True;
  try
    Envir := m_PEnvir;
    nX := m_nCurrX;
    nY := m_nCurrY;
    case m_btDirection of //
      DR_UP:
        begin
          if nY > 0 then
            Dec(nY);
        end;
      DR_UPRIGHT:
        begin
          if (nX < (Envir.Header.wWidth - 1)) and (nY > 0) then
          begin
            Inc(nX);
            Dec(nY);
          end;
        end;
      DR_RIGHT:
        begin
          if nX < (Envir.Header.wWidth - 1) then
            Inc(nX);
        end;
      DR_DOWNRIGHT:
        begin
          if (nX < (Envir.Header.wWidth - 1)) and (nY < (Envir.Header.wHeight -
            1)) then
          begin
            Inc(nX);
            Inc(nY);
          end;
        end;
      DR_DOWN:
        begin
          if nY < (Envir.Header.wHeight - 1) then
            Inc(nY);
        end;
      DR_DOWNLEFT:
        begin
          if (nX > 0) and (nY < (Envir.Header.wHeight - 1)) then
          begin
            Dec(nX);
            Inc(nY);
          end;
        end;
      DR_LEFT:
        begin
          if nX > 0 then
            Dec(nX);
        end;
      DR_UPLEFT:
        begin
          if (nX > 0) and (nY > 0) then
          begin
            Dec(nX);
            Dec(nY);
          end;
        end;
    end;

  except
    MainOutMessage('[Exception] TBaseObject.GetFrontPosition');
  end;
end;

function TBaseObject.GetRandXY(Envir: TEnvirnoment; var nX: Integer; var nY: Integer):
    Boolean;
var
  n14, n18, n1C: Integer;
begin
  Result := False;
  if Envir.Header.wWidth < 80 then
    n18 := 3
  else
    n18 := 10;
  if Envir.Header.wHeight < 150 then
  begin
    if Envir.Header.wHeight < 50 then
      n1C := 2
    else
      n1C := 15;
  end
  else
    n1C := 50;
  n14 := 0;
  while (True) do
  begin
    if Envir.CanWalk(nX, nY, True) then
    begin
      Result := True;
      break;
    end;
    if nX < (Envir.Header.wWidth - n1C - 1) then
      Inc(nX, n18)
    else
    begin
      nX := Random(Envir.Header.wWidth);
      if nY < (Envir.Header.wHeight - n1C - 1) then
        Inc(nY, n18)
      else
        nY := Random(Envir.Header.wHeight);
    end;
    Inc(n14);
    if n14 >= 201 then
      break;
  end;
end;

procedure TBaseObject.SpaceMove(sMap: string; nX, nY: Integer; nInt: Integer);
//004BCD1C
var
  I: Integer;
  Envir, OldEnvir: TEnvirnoment;
  nOldX, nOldY: Integer;
  bo21: Boolean;
  PlayObject: TPlayObject;
begin
  try
    try
      if (m_btRaceServer = RC_PLAYOBJECT) and
        (Assigned(m_HookChangeCurrMap)) and
        (not m_HookChangeCurrMap(Self)) then
        exit;
    except
      MainOutMessage('[Exception] TBaseObject.SpaceMove->ApiHook');
    end;
    Envir := g_MapManager.FindMap(sMap);
    if Envir <> nil then
    begin
      if nServerIndex = Envir.nServerIndex then
      begin
        OldEnvir := m_PEnvir;
        nOldX := m_nCurrX;
        nOldY := m_nCurrY;
        bo21 := False;

        m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        m_VisibleHumanList.Clear;
        for I := 0 to m_VisibleItems.Count - 1 do
        begin
          Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
        end;
        m_VisibleItems.Clear;
        for I := 0 to m_VisibleActors.Count - 1 do
        begin
          Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
        end;
        m_VisibleActors.Clear;
        m_VisibleEvents.Clear; //01/21 移动时清除列表
        m_PEnvir := Envir;
        m_sMapName := Envir.sMapName;
        m_nCurrX := nX;
        m_nCurrY := nY;
        if GetRandXY(m_PEnvir, m_nCurrX, m_nCurrY) then
        begin
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
          SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
          SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, Envir.sMapFile);
          if nInt = 1 then
          begin
            SendRefMsg(RM_SPACEMOVE_SHOW2, m_btDirection, m_nCurrX, m_nCurrY, 0,
              '');
          end
          else
            SendRefMsg(RM_SPACEMOVE_SHOW, m_btDirection, m_nCurrX, m_nCurrY, 0,
              '');
          m_dwMapMoveTick := GetTickCount();
          m_bo316 := True;
          bo21 := True;
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            PlayObject := TPlayObject(Self);
            if PlayObject.m_nChangeMap < 100 then
              Inc(PlayObject.m_nChangeMap);
          end;
        end; //004BCFA9
        if not bo21 then
        begin
          m_PEnvir := OldEnvir;
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
          m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
        end;
        if m_btRaceServer = RC_PLAYOBJECT then
          TPlayObject(Self).ShopCancel; //取消个人商店
      end
      else
      begin //004BCFF6
        if GetRandXY(Envir, nX, nY) then
        begin
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            DisappearA();
            m_bo316 := True;
            PlayObject := TPlayObject(Self);
            PlayObject.m_sSwitchMapName := Envir.sMapName;
            PlayObject.m_nSwitchMapX := nX;
            PlayObject.m_nSwitchMapY := nY;
            PlayObject.m_boSwitchData := True;
            PlayObject.m_nServerIndex := Envir.nServerIndex;
            PlayObject.m_boEmergencyClose := True;
            PlayObject.m_boReconnection := True;
          end
          else
            KickException();
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SpaceMove');
  end;
end;

procedure TPlayObject.RefUserState(); //004D6870
var
  n8: Integer;
begin
  try
    n8 := 0;
    if m_PEnvir.Flag.boFightZone or m_PEnvir.Flag.boFight2Zone then
      n8 := n8 or 1;
    if m_PEnvir.Flag.boSAFE then
      n8 := n8 or 2;
    if m_boInFreePKArea then
      n8 := n8 or 4;
    SendDefMessage(SM_AREASTATE, n8, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.RefUserState');
  end;
end;

procedure TBaseObject.RefShowName(); //004BF0C4
begin
  try
    SendRefMsg(RM_USERNAME, 0, 0, 0, 0, GetShowName);
  except
    MainOutMessage('[Exception] TBaseObject.RefShowName');
  end;
end;

procedure TPlayObject.RefDiamondGird(); //004BF0C4
begin
  try
    SendDefMessage(SM_DIAMONDGIRD, m_nGameDiamond, LoWord(m_nGameGird),
      HiWord(m_nGameGird), 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.RefDiamondGird');
  end;
end;

procedure TPlayObject.RefMyStatus();
begin
  try
    RecalcAbilitys();
    SendMsg(Self, RM_MYSTATUS, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.RefMyStatus');
  end;
end;

function TBaseObject.Operate(ProcessMsg: pTProcessMessage): Boolean; //004C716C
var
  nDamage: Integer;
  nTargetX: Integer;
  nTargetY: Integer;
  nPower: Integer;
  nRage: Integer;
  TargetBaseObject: TBaseObject;
  //nAttackPoint     :Integer;
  //nAttackDamage    :Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::Operate ';
begin
  try
    Result := False;
    try
      case ProcessMsg.wIdent of
        RM_MAGSTRUCK,
          RM_MAGSTRUCK_MINE:
          begin //10025
            if (ProcessMsg.wIdent = RM_MAGSTRUCK) and
              (m_btRaceServer >= RC_ANIMAL) and
              (not bo2BF2) and (m_Abil.Level < 50) then
            begin
              m_dwWalkTick := m_dwWalkTick + 800 + LongWord(Random(1000));
            end;
            {nAttackPoint:=ProcessMsg.nParam1;
            nAttackDamage:=5;
            //MainOutMessage(TBaseObject(ProcessMsg.BaseObject).m_sCharName);
            if (ProcessMsg.BaseObject<>nil) and
               (TBaseObject(ProcessMsg.BaseObject).m_btDiploidRate > 0) and
               ((Random(200)-TBaseObject(ProcessMsg.BaseObject).m_btDiploidRate) < 0)  then begin
              nAttackPoint:=nAttackPoint*2;
              nAttackDamage:=10;
            end; }
            nDamage := GetMagStruckDamage(nil, ProcessMsg.nParam1);
            if nDamage > 0 then
            begin
              StruckDamage(nDamage, TBaseObject(ProcessMsg.BaseObject));
              //设置攻击
              HealthSpellChanged();
              //nDamage:=1;
              SendRefMsg(RM_STRUCK_MAG, nDamage, m_WAbil.HP, m_WAbil.MaxHP,
                Integer(ProcessMsg.BaseObject), '');
              if m_btRaceServer <> RC_PLAYOBJECT then
              begin
                if m_boAnimal then
                  Dec(m_nMeatQuality, nDamage * 1000);
                SendMsg(Self, RM_STRUCK, nDamage, m_WAbil.HP, m_WAbil.MaxHP,
                  Integer(ProcessMsg.BaseObject) {AttackBaseObject}, '');
              end;
            end;
            if m_boFastParalysis then
            begin
              m_wStatusTimeArr[POISON_STONE] := 1;
              m_boFastParalysis := False;
            end;
          end;
        RM_MAGHEALING:
          begin //10026
            if (m_nIncHealing + ProcessMsg.nParam1) < 300 then
            begin
              if m_btRaceServer = RC_PLAYOBJECT then
              begin
                Inc(m_nIncHealing, ProcessMsg.nParam1);
                m_nPerHealing := 5;
              end
              else
              begin
                Inc(m_nIncHealing, ProcessMsg.nParam1);
                m_nPerHealing := 5;
              end;
            end
            else
              m_nIncHealing := 300;
          end;
        RM_10101:
          begin //10101
            SendRefMsg(Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam {nPower},
              ProcessMsg.nParam1 {HP},
              ProcessMsg.nParam2 {MaxHP},
              ProcessMsg.nParam3 {AttackSrc},
              ProcessMsg.sMsg);
            if (Integer(ProcessMsg.BaseObject) = RM_STRUCK) and (m_btRaceServer
              <> RC_PLAYOBJECT) then
            begin
              SendMsg(Self, Integer(ProcessMsg.BaseObject),
                ProcessMsg.wParam,
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                ProcessMsg.nParam3 {AttackBaseObject},
                ProcessMsg.sMsg);
            end;
            if m_boFastParalysis then
            begin
              m_wStatusTimeArr[POISON_STONE] := 1;
              m_boFastParalysis := False;
            end;
          end;
        RM_DELAYMAGIC:
          begin //10154 004C726E
            nPower := ProcessMsg.wParam;
            nTargetX := LoWord(ProcessMsg.nParam1);
            nTargetY := HiWord(ProcessMsg.nParam1);
            nRage := ProcessMsg.nParam2;
            TargetBaseObject := TBaseObject(ProcessMsg.nParam3);
            if (TargetBaseObject <> nil) and
              (TargetBaseObject.GetMagStruckDamage(Self, nPower) > 0) then
            begin

              SetTargetCreat {0FFF2}(TargetBaseObject);
              if TargetBaseObject.m_btRaceServer >= RC_ANIMAL then
                nPower := ROUND(nPower / 1.2);
              if (abs(nTargetX - TargetBaseObject.m_nCurrX) <= nRage) and
                (abs(nTargetY - TargetBaseObject.m_nCurrY) <= nRage) then
                TargetBaseObject.SendMsg(Self, RM_MAGSTRUCK, 0, nPower, 0, 0,
                  '');
            end;
          end;
        RM_10155:
          begin //10155
            MapRandomMove(ProcessMsg.sMsg, ProcessMsg.wParam);
          end;
        RM_DELAYPUSHED:
          begin
            nPower := ProcessMsg.wParam;
            //      nTargetX:=LoWord(ProcessMsg.nParam1);
            //      nTargetY:=HiWord(ProcessMsg.nParam1);
            nRage := ProcessMsg.nParam2;
            TargetBaseObject := TBaseObject(ProcessMsg.nParam3);
            if (TargetBaseObject <> nil) then
            begin
              TargetBaseObject.CharPushed(nPower, nRage);
            end;
          end;
        RM_POISON:
          begin //10300 004C74AB
            TargetBaseObject := TBaseObject(ProcessMsg.nParam2);
            if TargetBaseObject <> nil then
            begin
              if IsProperTarget {FFF4}(TargetBaseObject) then
              begin
                SetTargetCreat {0FFF2}(TargetBaseObject);
                if (m_btRaceServer = RC_PLAYOBJECT) and
                  (TargetBaseObject.m_btRaceServer = RC_PLAYOBJECT) then
                begin
                  SetPKFlag(TargetBaseObject);
                end;
                SetLastHiter(TargetBaseObject);

              end;
              MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1
                {nPower}, ProcessMsg.nParam3 {});
            end
            else
              MakePosion(ProcessMsg.wParam {中毒类型}, ProcessMsg.nParam1
                {nPower}, ProcessMsg.nParam3);

          end;
        RM_TRANSPARENT:
          begin //10308
            MagicManager.MagMakePrivateTransparent(Self, ProcessMsg.nParam1);
          end;
        RM_DOOPENHEALTH:
          begin //10412
            MakeOpenHealth();
          end;
{$IF CHECKNEWMSG = 1}
      else
        begin
          MainOutMessage(format('人物: %s 消息: Ident %d Param %d P1 %d P2 %d P3 %d Msg %s',
            [m_sCharName,
            ProcessMsg.wIdent,
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3,
              ProcessMsg.sMsg]));
        end;
{$IFEND}
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg);
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.Operate');
  end;
end;

//英雄消息处理
function TPlayObject.HeroOperate(ProcessMsg: pTProcessMessage): Boolean;
var
  m_DefMsg: TDefaultMessage;
  CharDesc: THeroCharDesc;
  s1C: string;
  OAbility: TOAbility;
  nCheckCode: Byte;
begin
  try
    Result := True;
    nCheckCode := 0;
    try
      case ProcessMsg.wIdent of
        RM_10055:
          begin
            HeroAllowJointAttac();
          end;
        RM_HEROCHANGEGLORY:
          begin
            TPlayObject(m_HeroHuman).SendDefMessage(SM_HEROCHANGEGLORY,
              Integer(Self), 0, 0, m_nGloryPoint, '');
          end;
        {RM_CHANGENAMECOLOR : begin  //刷新人物名称颜色
          nCheckCode:=1; m_nGloryPoint
        end;}
        RM_HEROLOGIN:
          begin //英雄首次登录
            nCheckCode := 2;
            m_DefMsg := MakeDefaultMsg(SM_899, Integer(Self), m_nCurrX,
              m_nCurrY, m_btDirection);
            CharDesc.feature := GetFeature(Self);
            CharDesc.Status := m_nCharStatus;
            CharDesc.m_btSex := m_btGender;
            CharDesc.m_btJob := m_btJob;
            CharDesc.Not1 := m_nGloryPoint;
            CharDesc.Not2 := 0;
            s1C := EncodeBuffer(@CharDesc, SizeOf(CharDesc));
            TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, s1C);

            m_DefMsg := MakeDefaultMsg(SM_898, 0, 0, 0, 0);
            s1C := EncodeString(m_sCharName);
            TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, s1C);

            TPlayObject(m_HeroHuman).SendDefMessage(SM_917, Integer(Self),
              GetHeroBagCount, 0, 0, '');
            ClientQueryBagItems;
          end;
        RM_ABILITY:
          begin
            nCheckCode := 3;
            m_DefMsg := MakeDefaultMsg(SM_900,
              0,
              MakeWord(m_btJob, 99),
              0,
              0);
            if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
            begin
              GetOldAbil(OAbility);
              TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,
                EncodeBuffer(@OAbility, SizeOf(TOAbility)));
            end
            else
            begin
              TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,
                EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
            end;
          end;
        RM_SUBABILITY:
          begin
            nCheckCode := 4;
            TPlayObject(m_HeroHuman).SendDefMessage(SM_901,
              MakeLong(MakeWord(m_nAntiMagic, 0), 0),
              MakeWord(m_btHitPoint, m_btSpeedPoint),
              MakeWord(m_btAntiPoison, m_nPoisonRecover),
              MakeWord(m_nHealthRecover, m_nSpellRecover),
              '');
          end;
        RM_SENDMYMAGIC:
          begin
            SendUseMagic;
          end;
        RM_HEROLOGINEX:
          begin
            nCheckCode := 5;
            SendUseitems;
            //      SendUseMagic;
            case m_btAttatckMode of
              0: s1C := sHeroAttack;
              1: s1C := sHeroFollow;
              2: s1C := sHeroRest;
            else
              begin
                m_btAttatckMode := 0;
                s1C := sHeroAttack;
              end;
            end;
            SysMsg(s1C, c_Green, t_Hint);
            SysMsg(sHeroHit, c_Green, t_Hint);
          end;
        RM_LEVELUP:
          begin
            nCheckCode := 6;
            RecalcHeroBagCount();
            m_DefMsg := MakeDefaultMsg(SM_914, m_Abil.Exp, m_Abil.Level, 0, 0);
            TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, '');
            m_DefMsg := MakeDefaultMsg(SM_900, 0, m_btJob, 0, 0);
            if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
            begin
              GetOldAbil(OAbility);
              TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,
                EncodeBuffer(@OAbility, SizeOf(TOAbility)));
            end
            else
              TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,
                EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
            TPlayObject(m_HeroHuman).SendDefMessage(SM_901,
              MakeLong(MakeWord(m_nAntiMagic, 0), 0),
              MakeWord(m_btHitPoint, m_btSpeedPoint),
              MakeWord(m_btAntiPoison, m_nPoisonRecover),
              MakeWord(m_nHealthRecover, m_nSpellRecover),
              '');
            TPlayObject(m_HeroHuman).SendDefMessage(SM_917, Integer(Self),
              GetHeroBagCount, 0, 0, '');
            SendRefMsg(RM_SHOWEFFECT, Effect_85, Integer(Self), m_nCurrX,
              m_nCurrY, '');
          end;
        RM_WINEXP:
          begin //10044 004D95FE
            nCheckCode := 7;
            m_DefMsg := MakeDefaultMsg(SM_915, m_Abil.Exp,
              LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0);
            TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, '');
          end;
        RM_CLOSEHERO:
          begin
            if (g_Config.nHeroFealtyCallDel > 0) then
              Dec(m_nGloryPoint, _MIN(m_nGloryPoint,
                g_Config.nHeroFealtyCallDel));
            nCheckCode := 8;
            MakeGhost;
            Result :=False;
            m_HeroHuman.m_Hero := nil;
          end;
        RM_HEALTHSPELLCHANGED:
          begin //10052
            nCheckCode := 9;
            if ProcessMsg.BaseObject = self then
            begin
              m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
                Integer(Self),
                m_WAbil.HP,
                m_WAbil.MP,
                m_WAbil.MaxHP);
              TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, '');
            end;
          end;
        RM_MAGIC_LVEXP:
          begin //10123 004D9E8D
            nCheckCode := 10;
            TPlayObject(m_HeroHuman).SendDefMessage(SM_916,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              LoWord(ProcessMsg.nParam3),
              HiWord(ProcessMsg.nParam3),
              '');
          end;
        RM_DURACHANGE:
          begin //10125 持久改变
            nCheckCode := 11;
            TPlayObject(m_HeroHuman).SendDefMessage(SM_919,
              ProcessMsg.nParam1,
              ProcessMsg.wParam,
              LoWord(ProcessMsg.nParam2),
              HiWord(ProcessMsg.nParam2),
              '');
          end;
        RM_BAG_DURACHANGE2:
          begin //背包物品持久改变
            nCheckCode := 12;
            TPlayObject(m_HeroHuman).SendDefMessage(SM_922,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              LoWord(ProcessMsg.nParam3),
              HiWord(ProcessMsg.nParam3),
              '');
          end;
        RM_DANDERCHANG:
          begin
            {nCheckCode:=13;
            TPlayObject(m_HeroHuman).SendDefMessage(SM_923,
                                     ProcessMsg.nParam1,
                                     ProcessMsg.wParam,
                                     ProcessMsg.nParam2,
                                     0,
                                     ''); }
          end;
           RM_WineValue:
           BEGIN
               m_DefMsg := MakeDefaultMsg(SM_HeroWineValue, 0,0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, EncodeBuffer(@m_WineRec, SizeOf(TWineRec)));
           END;
           RM_MedicineValue:
           BEGIN
               m_DefMsg := MakeDefaultMsg(SM_HeroMedicineValue, 0,0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, EncodeBuffer(@m_MedicineRec, SizeOf(TMedicineRec)));
           END;
           RM_SKILL84Exp:
           begin
               m_DefMsg := MakeDefaultMsg(SM_HeroSKILL84Exp, 0,0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, EncodeBuffer(@m_SKILL84Rec, SizeOf(TSKILL84Rec)));
           end;
           RM_bLiquorProgress:
           begin
               m_DefMsg := MakeDefaultMsg(SM_HerobLiquorProgress,integer(m_bLiquorProgress),0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,'');
           end;
           RM_DRINK:
           begin
               m_DefMsg := MakeDefaultMsg(SM_HeroDRINK,Integer(ProcessMsg.BaseObject),0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,'');
           end;
           RM_ADDLiquor:
           begin
               m_DefMsg := MakeDefaultMsg(SM_HeroADDLiquor,Integer(ProcessMsg.BaseObject),0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,'');
           end;
           RM_DRUNK:
           begin
               m_DefMsg := MakeDefaultMsg(SM_HeroDRUNK,Integer(ProcessMsg.BaseObject),0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,'');
           end;
           RM_SKILL83Value:
           begin
               m_DefMsg := MakeDefaultMsg(SM_HeroSKILL83Value, 0,0,0,0);
               TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, EncodeBuffer(@m_SKILL83Rec, SizeOf(TSKILL83Rec)));
           end;
      else
        nCheckCode := 12;
        //inherited Operate(ProcessMsg);
        Result := inherited Operate(ProcessMsg);
      end;
    except
      Mainoutmessage('[Exception] TPlayObject->HeroOperate nCode=' +
        IntToStr(nCheckCode));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroOperate');
  end;
end;

function TPlayObject.Operate(ProcessMsg: pTProcessMessage): Boolean;
resourcestring
  sExceptionMsg2 =
    '[Exception] TPlayObject.Operate # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s';
var
  CharDesc: TCharDesc;
  nObjCount: integer;
  s1C: string;
  MessageBodyWL: TMessageBodyWL;
  MessageBodyW: TMessageBodyW;
  ShortMessage: TShortMessage;
  OAbility: TOAbility;
  dwDelayTime: LongWord;
  nMsgCount: Integer;
  m_DefMsg: TDefaultMessage;
  //  str :String;
  I: Integer;
begin
  if m_boHero then
  begin
    Result := HeroOperate(ProcessMsg);
    exit;
  end;
  try
    Result := True;
    case ProcessMsg.wIdent of
      CM_QUERYUSERNAME:
        begin //80
          ClientQueryUserName(TBaseObject(ProcessMsg.nParam1),
            ProcessMsg.nParam2, ProcessMsg.nParam3); //004D7931
        end;
      CM_QUERYBAGITEMS:
        begin //0x81
          ClientQueryBagItems(); //004D793E
        end;
      CM_QUERYUSERSTATE:
        begin //82
          ClientQueryUserState(TBaseObject(ProcessMsg.nParam1),
            ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_QUERYUSERSET:
        begin
          ClientQueryUserSet(ProcessMsg);
        end;
      CM_DROPITEM:
        begin //1000
          if ClientDropItem(ProcessMsg.sMsg, ProcessMsg.nParam1) then
            SendDefMessage(SM_DROPITEM_SUCCESS, ProcessMsg.nParam1, 0, 0, 0,
              ProcessMsg.sMsg)
          else
            SendDefMessage(SM_DROPITEM_FAIL, ProcessMsg.nParam1, 0, 0, 0,
              ProcessMsg.sMsg);
        end;
      CM_PICKUP:
        begin //1001  004D78F9
          if (m_nCurrX = ProcessMsg.nParam2) and (m_nCurrY = ProcessMsg.nParam3)
            then
            ClientPickUpItem();
        end;
      CM_OPENDOOR:
        begin //1002
          ClientOpenDoor(ProcessMsg.nParam2, ProcessMsg.nParam3);
        end;
      CM_TAKEONITEM:
        begin //1003
          ClientTakeOnItems(ProcessMsg.nParam2, ProcessMsg.nParam1,
            ProcessMsg.sMsg);
        end;
      CM_TAKEOFFITEM:
        begin //1004
          ClientTakeOffItems(ProcessMsg.nParam2, ProcessMsg.nParam1,
            ProcessMsg.sMsg);
        end;
     CM_ITEMFOLD:
        begin
          ClientItemFold(ProcessMsg.nParam1,ProcessMsg.sMsg);
        end;   
      CM_EAT:
        begin //1006
          ClientUseItems(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_BUTCH:
        begin //1007
          //挖物品
          ShopCancel;
          if not ClientGetButchItem(TBaseObject(ProcessMsg.nParam1),
            ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.wParam,
            dwDelayTime) then
          begin
            if dwDelayTime <> 0 then
            begin
              nMsgCount := GetDigUpMsgCount();
              if nMsgCount >= g_Config.nMaxDigUpMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sBunOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
              end
              else
              begin
                if dwDelayTime < g_Config.dwDropOverSpeed then
                begin
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendActionGood;
                end
                else
                begin
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                    '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_MAGICKEYCHANGE:
        begin //1008
          ClientChangeMagicKey(ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.nParam3);
        end;
      CM_SOFTCLOSE:
        begin //1009  004D79CB
          NpcGotoLable(g_FunctionNPC, '@PlayReconnection', False);
          m_boReconnection := True;
          m_boSoftClose := True;
        end;
      CM_OPENBOOKS: NpcGotoLable(g_FunctionNPC, '@OpenBooks', False);
      CM_CLICKNPC: //1010  004D79E4
        ClientClickNPC(ProcessMsg.nParam1);
      CM_MERCHANTDLGSELECT: //1011      点击NPC
        ClientMerchantDlgSelect(ProcessMsg.nParam1, ProcessMsg.sMsg);
      CM_MERCHANTQUERYSELLPRICE: //1012
        ClientMerchantQuerySellPrice(ProcessMsg.nParam1,
          MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
      CM_USERSELLITEM: //1013
        ClientUserSellItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
          ProcessMsg.nParam3), ProcessMsg.sMsg);

      CM_USERBUYITEM: //1014  004D7AD4
        ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1,
          MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), 0, ProcessMsg.sMsg);

      CM_USERGETDETAILITEM: //1015 004D7AB6
        ClientUserBuyItem(ProcessMsg.wIdent, ProcessMsg.nParam1, 0,
          ProcessMsg.nParam2, ProcessMsg.sMsg);

      CM_DROPGOLD: //1016  004D7AFC
        if ProcessMsg.nParam1 > 0 then
          ClientDropGold(ProcessMsg.nParam1);

      CM_1017: //1017
        SendDefMessage(1, 0, 0, 0, 0, '');

      CM_GROUPMODE:
        begin //1019
          if ProcessMsg.nParam2 = 0 then
            ClientGroupClose()
          else
            m_boAllowGroup := True;
          if m_boAllowGroup then
            SendDefMessage(SM_GROUPMODECHANGED, 0, 1, 0, 0, '')
          else
            SendDefMessage(SM_GROUPMODECHANGED, 0, 0, 0, 0, '');
        end;
      CM_AUTOGROUP:
        begin //1020
          ClientAutoGroup(ProcessMsg.nParam1 = 1);
        end;
      CM_AUTOADDGROUP:
        begin //1020
          ClientAutoAddGroup(ProcessMsg.sMsg);
        end;
      CM_CREATEGROUP:
        begin //1020
          ClientCreateGroup(Trim(ProcessMsg.sMsg), ProcessMsg.nParam1 = 1);
        end;
      CM_ADDGROUPMEMBER:
        begin //1021
          ClientAddGroupMember(Trim(ProcessMsg.sMsg));
        end;
      CM_DELGROUPMEMBER:
        begin //1022
          ClientDelGroupMember(Trim(ProcessMsg.sMsg));
        end;
      CM_USERREPAIRITEM:
        begin //1023 004D7A70
          ClientRepairItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
            ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_MERCHANTQUERYREPAIRCOST:
        begin //1024 004D7A2A
          ClientQueryRepairCost(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
            ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_DEALTRY:
        begin //1025
          ClientDealTry(Trim(ProcessMsg.sMsg));
        end;
      CM_DEALADDITEM:
        begin //1026
          ClientAddDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_DEALDELITEM:
        begin //1027
          ClientDelDealItem(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_DEALCANCEL:
        begin //1028
          ClientCancelDeal();
        end;
      CM_DEALCHGGOLD:
        begin //1029
          ClientChangeDealGold(ProcessMsg.nParam1);
        end;
      CM_DEALEND:
        begin //1030
          ClientDealEnd();
        end;
      CM_PLAYDRINKSEND:
        begin
          ClientPlayDrinkSend(ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.nParam3);
        end;
      CM_PLAYDRINKGAME:
        begin
          ClientPlayDrinkGame(ProcessMsg.nParam1, ProcessMsg.nParam2);
        end;
      CM_PLAYDRINKSELL:
        begin
          ClientPlayDrink(TObject(ProcessMsg.nParam1),
            MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3));
        end;
      CM_USERSTORAGEITEM:
        begin //1031
          ClientStorageItem(TObject(ProcessMsg.nParam1),
            MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_USERTAKEBACKSTORAGEITEM:
        begin //1032
          ClientTakeBackStorageItem(TObject(ProcessMsg.nParam1),
            MakeLong(ProcessMsg.nParam2, ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_WANTMINIMAP:
        begin //1033
          ClientGetMinMap();
        end;
      CM_USERMAKEDRUGITEM:
        begin //1034
          ClientMakeDrugItem(TObject(ProcessMsg.nParam1), ProcessMsg.sMsg);
        end;
      CM_OPENGUILDDLG:
        begin //1035
          ClientOpenGuildDlg();
        end;
      CM_GUILDHOME:
        begin //1036
          ClientGuildHome();
        end;
      CM_GUILDMEMBERLIST:
        begin
          ClientGuildMemberList();
        end;
      CM_GUILDADDMEMBER:
        begin
          ClientGuildAddMember(ProcessMsg.sMsg);
        end;
      CM_GUILDDELMEMBER:
        begin
          ClientGuildDelMember(ProcessMsg.sMsg);
        end;
      CM_GUILDUPDATENOTICE:
        begin
          if ProcessMsg.nParam1 > 0 then
            ClientGuildUpdateMsg(ProcessMsg.nParam1, ProcessMsg.sMsg)
          else
            ClientGuildUpdateNotice(ProcessMsg.sMsg);
        end;
      CM_GUILDUPDATERANKINFO:
        begin //1041
          ClientGuildUpdateRankInfo(ProcessMsg.sMsg);
        end;
      CM_1042:
        begin
          MainOutMessage('[非法数据] ' + m_sCharName);
        end;
      CM_ADJUST_BONUS:
        begin
          ClientAdjustBonus(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_GUILDALLY:
        begin //1044
          ClientGuildAlly();
        end;
      CM_GUILDBREAKALLY:
        begin //1045
          ClientGuildBreakAlly(ProcessMsg.sMsg);
        end;
{$IF CHECKNEWMSG = 1}
      CM_1046:
        begin
          MainOutMessage(format('%s/%d/%d/%d/%d/%d/%s',
            [m_sCharName,
            ProcessMsg.wIdent,
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3,
              DecodeString(ProcessMsg.sMsg)]));
        end;
      CM_1056:
        begin
          MainOutMessage(format('%s/%d/%d/%d/%d/%d/%s',
            [m_sCharName,
            ProcessMsg.wIdent,
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3,
              DecodeString(ProcessMsg.sMsg)]));
        end;
{$IFEND}
      CM_TURN:
        begin //3010    004D73DD
          ShopCancel;
          if ClientChangeDir(ProcessMsg.wIdent, ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir}, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendActionGood;
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetTurnMsgCount();
              if nMsgCount >= g_Config.nMaxTurnMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sBunOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
              end
              else
              begin
                if dwDelayTime < g_Config.dwDropOverSpeed then
                begin
                  SendActionGood;
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                    '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_WALK:
        begin //3011
          ShopCancel; //取消个人商店
          if ClientWalkXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendActionGood;
            Inc(n5F8);
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetWalkMsgCount();
              if nMsgCount >= g_Config.nMaxWalkMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[行走超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sWalkOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d',
                    [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and
                  (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
                begin
                  SendActionFail;
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin

                  if m_boTestSpeedMode then
                    SysMsg(format('操作延迟 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                    '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;

      CM_HORSERUN:
        begin //3009
          ShopCancel; //取消个人商店
          if ClientHorseRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y}, ProcessMsg.boLateDelivery, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendActionGood;
            Inc(n5F8);
          end
          else
          begin

            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetRunMsgCount();
              if nMsgCount >= g_Config.nMaxRunMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[跑步超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sRunOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;

                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
                if m_boTestSpeedMode then
                  SysMsg(format('速度异常 Ident: %d Time: %d',
                    [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
              end
              else
              begin
                if m_boTestSpeedMode then
                  SysMsg(format('操作延迟 Ident: %d Time: %d',
                    [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                  ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                  '',
                  dwDelayTime);
                Result := False;
              end;
            end;

          end;
        end;
      CM_RUN:
        begin //3013
          ShopCancel; //取消个人商店
          if ClientRunXY(ProcessMsg.wIdent, ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y}, ProcessMsg.nParam3, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendActionGood;
            Inc(n5F8);
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetRunMsgCount();
              if nMsgCount >= g_Config.nMaxRunMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[跑步超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sRunOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
              end
              else
              begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and
                  (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
                begin
                  SendActionFail;
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin
                  if m_boTestSpeedMode then
                    SysMsg(format('操作延迟 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, CM_RUN, '',
                    dwDelayTime);
                  Result := False;
                end;
              end;
            end;

          end;
        end;
      CM_HIT, //3014
      CM_HEAVYHIT, //3015
      CM_BIGHIT, //3016
      CM_POWERHIT, //3018
      CM_LONGHIT, //3019
      CM_WIDEHIT, //3024
      CM_CRSHIT,
        CM_TWINHIT,
        CM_LONGSWORD1,
        CM_LONGSWORD2,
        CM_LONGFIRESWORD,
        CM_FIREHIT:
        begin //3025  :004D75BC
          ShopCancel; //取消个人商店
          if ClientHitXY(ProcessMsg.wIdent {ident}, ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y}, ProcessMsg.wParam {dir},
            ProcessMsg.boLateDelivery, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendActionGood;
            Inc(n5F8);
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetHitMsgCount();
              if nMsgCount >= g_Config.nMaxHitMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[攻击超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sHitOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
              end
              else
              begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and
                  (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
                begin
                  SendActionGood;
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin
                  if m_boTestSpeedMode then
                  begin
                    //SysMsg(format('操作延迟 Ident: %d Time: %d',[ProcessMsg.wIdent,dwDelayTime]),c_Red,t_Hint);
                    SysMsg('操作延迟 Ident: ' + IntToStr(ProcessMsg.wIdent)
                      +
                      ' Time: ' + IntToStr(dwDelayTime), c_Red, t_Hint);
                  end;
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                    '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_SITDOWN:
        begin //3012      //挖物品
          ShopCancel; //取消个人商店
          if ClientSitDownHit(ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.wParam, dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount();
            SendActionGood;
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetSiteDownMsgCount();
              if nMsgCount >= g_Config.nMaxSitDonwMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[游戏超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sBunOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
              end
              else
              begin
                if dwDelayTime < g_Config.dwDropOverSpeed then
                begin
                  SendActionGood;
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin
                  if m_boTestSpeedMode then
                    SysMsg(format('操作延迟 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                    '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;
      CM_SPELL:
        begin //3017  004D76FD
          ShopCancel; //取消个人商店 CM_SELFSHOPITEMS
          if m_boOnHorse then
          begin
            m_boOnHorse := False;
            FeatureChanged();
          end;
          if ClientSpellXY(ProcessMsg.wIdent, ProcessMsg.wParam,
            ProcessMsg.nParam1, ProcessMsg.nParam2,
            TBaseObject(ProcessMsg.nParam3), ProcessMsg.boLateDelivery,
            dwDelayTime) then
          begin
            m_dwActionTick := GetTickCount;
            SendActionGood;
            Inc(n5F8);
          end
          else
          begin
            if dwDelayTime = 0 then
            begin
              SendActionFail;
            end
            else
            begin
              nMsgCount := GetSpellMsgCount();
              if nMsgCount >= g_Config.nMaxSpellMsgCount then
              begin
                Inc(m_nOverSpeedCount);
                if m_nOverSpeedCount > g_Config.nOverSpeedKickCount then
                begin
                  if g_Config.boKickOverSpeed then
                  begin
                    SysMsg(g_sKickClientUserMsg
                      {'请勿使用非法软件！！！'}, c_Red, t_Hint);
                    m_boEmergencyClose := True;
                  end;
                  if g_Config.boViewHackMessage then
                  begin
                    //MainOutMessage('[魔法超速] ' + m_sCharName + ' Time: ' + IntToStr(dwDelayTime) + ' Count: '+ IntToStr(nMsgCount));
                    MainOutMessage(format(g_sSpellOverSpeed, [m_sCharName,
                      dwDelayTime, nMsgCount]));
                  end;
                end;
                //如果超速则发送攻击失败信息
                SendActionFail;
              end
              else
              begin
                if (dwDelayTime > g_Config.dwDropOverSpeed) and
                  (g_Config.btSpeedControlMode = 1) and m_boFilterAction then
                begin
                  SendActionFail;
                  if m_boTestSpeedMode then
                    SysMsg(format('速度异常 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                end
                else
                begin
                  if m_boTestSpeedMode then
                    SysMsg(format('操作延迟 Ident: %d Time: %d',
                      [ProcessMsg.wIdent, dwDelayTime]), c_Red, t_Hint);
                  SendDelayMsg(Self, ProcessMsg.wIdent, ProcessMsg.wParam,
                    ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.nParam3,
                    '', dwDelayTime);
                  Result := False;
                end;
              end;
            end;
          end;
        end;

      CM_SAY:
        begin //3030
          if ProcessMsg.sMsg <> '' then
          begin
            ProcessUserLineMsg(ProcessMsg.sMsg);
          end;
        end;
      CM_PASSWORD:
        begin
          ProcessClientPassword(ProcessMsg);
        end;

      CM_SHOPVIEW:
        begin
          case ProcessMsg.nParam1 of
            0:
              begin
                if not m_ShopSend[ProcessMsg.nParam1] then
                begin
                  m_DefMsg := MakeDefaultMsg(SM_SHOPLIST, Integer(Self), 0, 0,
                    0);
                  SendSocket(@m_DefMsg, Shop.GetMsg(Self, ProcessMsg.nParam1));
                  m_ShopSend[ProcessMsg.nParam1] := True;
                end;
                if not m_ShopSend[5] then
                begin
                  m_DefMsg := MakeDefaultMsg(SM_SHOPTOP, Integer(Self), 0, 0,
                    0);
                  SendSocket(@m_DefMsg, Shop.GetMsg(Self, 5));
                  m_ShopSend[5] := True;
                end;
              end;
            1..4:
              begin
                if not m_ShopSend[ProcessMsg.nParam1] then
                begin
                  m_DefMsg := MakeDefaultMsg(SM_SHOPLIST, Integer(Self), 0, 0,
                    0);
                  SendSocket(@m_DefMsg, Shop.GetMsg(Self, ProcessMsg.nParam1));
                  m_ShopSend[ProcessMsg.nParam1] := True;
                end;
              end;
          end;
        end;
      CM_SHOPLINGFU:
        begin
          //MainOutMessage(IntToStr(ProcessMsg.nParam1));
          if m_nGameGold>=1 then
          begin
           m_ServerIntVal[2] := ProcessMsg.nParam1;
           NpcGotoLable(g_FunctionNPC, '@ShopLingfu', False);
          end;
        end;
      CM_SHOPPAY:
        begin
          NpcGotoLable(g_FunctionNPC, '@ShopPAY', False);
        end;
      CM_PLAYDRINK:
        begin
          ClientGetPlayDrink(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
            ProcessMsg.nParam3), ProcessMsg.sMsg);
        end;
      CM_GETHERO:
        begin
          ClientGetHero(ProcessMsg.nParam1);
        end;
      CM_SHOPSEND:
        begin
          if (GetTickCount - m_ShopTickTime) > SHOPTICKTIME then
          begin
            m_ShopTickTime := GetTickCount;
            I := Shop.ShopSendItems(Self, ProcessMsg.sMsg);
            if I > 0 then
              GoldChanged
            else
              SendDefMessage(SM_SHOPERROR, I, 0, 0, 0, '');
          end
          else
          begin
            SendDefMessage(SM_SHOPERROR, -6, 0, 0, 0, '');
            m_ShopTickTime := GetTickCount;
          end;
        end;
      CM_SHOPBUY:
        begin
          if (GetTickCount - m_ShopTickTime) > SHOPTICKTIME then
          begin
            m_ShopTickTime := GetTickCount;
            I := Shop.ShopItems(Self, ProcessMsg.sMsg);
            if I > 0 then
            begin
              //m_DefMsg:=MakeDefaultMsg(SM_MENU_OK,0,0,0,0);
              //Str:='成功购买物品 '+ProcessMsg.sMsg+'\';
              //Str:=Str+'您当前剩余元宝数量为: '+IntToStr(m_nGameGold);
              //SendSocket(@m_DefMsg,EncodeString(Str));
              GoldChanged
            end
            else
              SendDefMessage(SM_SHOPERROR, I, 0, 0, 0, '');
          end
          else
          begin
            SendDefMessage(SM_SHOPERROR, -6, 0, 0, 0, '');
            m_ShopTickTime := GetTickCount;
          end;
          //Shop.ShopMsg(ProcessMsg);
          //SendDefMessage(SM_SHOPERROR,-2,0,0,0,''); //元宝不足
          //SendDefMessage(SM_SHOPERROR,0,0,0,0,''); //非法物品名
          //SendDefMessage(SM_SHOPERROR,-1,0,0,0,''); //不存在你想购买的物品
          //SendDefMessage(SM_SHOPERROR,-3,0,0,0,''); //你账号中的无宝数不够
          //SendDefMessage(SM_SHOPERROR,-4,0,0,0,''); //无法携带更多物品
          //SendDefMessage(SM_SHOPERROR,-5,0,0,0,''); //购买物品不在商城中
          //SendDefMessage(SM_SHOPERROR,-6,0,0,0,''); //您的购买速度过快

        end;
      CM_GHOSTHERO:
        begin
          if (m_Hero <> nil) and (not m_Hero.m_boDeath) and (not m_Hero.m_boGhost)
            then
            m_Hero.SendMsg(m_Hero, RM_CLOSEHERO, 0, 0, 0, 0, '');
        end;

      CM_MAKEHERO:
        begin //召唤英雄
          if (m_Hero = nil) and (m_HeroName <> '') then
          begin
            if (GetTickCount - m_HeroCallTime) > g_Config.nHeroCallTick then
            begin
              if m_PEnvir.Flag.boNOCALLHERO then
              begin
                SysMsg('本地图禁止召唤英雄。', c_Green, t_Hint);
              end
              else
              begin
                m_HeroCallTime := GetTickCount;
                FrontEngine.AddToLoadRcdList(m_sUserID,
                  m_HeroName,
                  m_sIPaddr,
                  false,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  True,
                  0,
                  0,
                  False, Self);
              end;
            end
            else
            begin
              I := GetTickCount - m_HeroCallTime;
              I := g_Config.nHeroCallTick - LongWord(I);
              I := _MAX(I div 1000, 1); {Trunc(I/1000)}
              ;
              SysMsg(Format(sCallHeroTime, [I]), c_Green, t_Hint);
            end;
          end;
        end;
      CM_1100:
        begin //主人背包到英雄
          HeroItemToMasterBag(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
     CM_HeroMinHPTail:
     begin
      try
       if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not m_Hero.m_boDeath) then
         TPlayObject(m_Hero).m_HeroMinHPTail:=Word(ProcessMsg.nParam1);
      except

      end;
     end;
      CM_1101:
        begin
          MasterItemToHeroBag(ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;

      CM_1102:
        begin
          if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not
            m_Hero.m_boDeath) then
            TPlayObject(m_Hero).ClientTakeOnItems(ProcessMsg.nParam2,
              ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;
      CM_IncFireDrakeHeartDander:
        begin
          if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not m_Hero.m_boDeath) then
            TPlayObject(m_Hero).ClientIncFireDrakeHeartDander(ProcessMsg.nParam1);
        end;
      CM_1103:
        begin
          if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not
            m_Hero.m_boDeath) then
            TPlayObject(m_Hero).ClientTakeOffItems(ProcessMsg.nParam2,
              ProcessMsg.nParam1, ProcessMsg.sMsg);
        end;

      CM_1104:
        begin
          if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not
            m_Hero.m_boDeath) then
            TPlayObject(m_Hero).HeroEatItems(ProcessMsg.nParam1,
              ProcessMsg.sMsg);
        end;

      CM_1105:
        begin //守护
          if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not
            m_Hero.m_boDeath) then
            TPlayObject(m_Hero).HeroLockedObject(ProcessMsg.wParam,
              ProcessMsg.nParam2, ProcessMsg.nParam3,
              TBaseObject(ProcessMsg.nParam1));
        end;

      CM_1106:
        begin
          if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not
            m_Hero.m_boDeath) then
          begin
            if TPlayObject(m_Hero).ClientDropItem(ProcessMsg.sMsg,
              ProcessMsg.nParam1) then
              SendDefMessage(SM_920, ProcessMsg.nParam1, 0, 0, 0,
                ProcessMsg.sMsg)
            else
              SendDefMessage(SM_921, ProcessMsg.nParam1, 0, 0, 0,
                ProcessMsg.sMsg);
          end;
        end;

      CM_1107:
        begin
          HeroFunction(ProcessMsg.nParam2, ProcessMsg.nParam1);
        end;

      CM_1108:
        begin //使用合技
          if (m_Hero <> nil) and (m_Hero.m_HeroDanderOk) and (not
            m_Hero.m_HeroboDanderDel) then
            //m_Hero.HeroAllowJointAttac;
            //m_Hero.SendUpDateMsg(Self,RM_10055,0,0,0,0,'');
            m_Hero.m_HeroboDanderDel := True;
        end;

      CM_1109:
        begin
          HeroCallMob(ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.nParam3, ProcessMsg.wParam);
        end;
      CM_SELLOFFITEMLIST:
        begin
          //if ProcessMsg.sMsg='' then g_PlacingItem.ClientGetItemList(Self,ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.wParam,'')
          //else  g_PlacingItem.ClientGetItemList(Self,ProcessMsg.nParam2,ProcessMsg.nParam3,ProcessMsg.wParam,DecodeString(ProcessMsg.sMsg));
        end;
      CM_SELLOFFITEM: ;
      // g_PlacingItem.ClientAddItemToList(Self,ProcessMsg.nParam1,MakeLong(ProcessMsg.nParam2,ProcessMsg.nParam3),ProcessMsg.wParam,DecodeString(ProcessMsg.sMsg));
      CM_SELLOFFBUY: ; // g_PlacingItem.ClientBuyItem(Self,ProcessMsg.nParam1);

      CM_LEVELITEM:
        begin
          ClientLevelItem(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
            ProcessMsg.nParam3), Str_ToInt(ProcessMsg.sMsg, 0));
        end;

      CM_OPENARK:
        begin
          ClientOpenArk(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
            ProcessMsg.nParam3));
        end;

      CM_OPENARKEX:
        begin
          ClientOpenArkEX(ProcessMsg.nParam1, MakeLong(ProcessMsg.nParam2,
            ProcessMsg.nParam3));
        end;
      CM_OPENARKMOVE: ClientOpenMove();
      CM_OPENARKITEM: ClientOpenItem();
      CM_TAXIS:
        begin
          ClientGetTaxisList(ProcessMsg.nParam1, ProcessMsg.nParam2,
            ProcessMsg.nParam3);
        end;
      CM_SELFSHOPITEMS:
        begin
          ClientGetShopItems(ProcessMsg.sMsg);
        end;
      CM_MakeWineItems://酿酒
      begin
        ClientGetWineitems(ProcessMsg.sMsg,ProcessMsg.nParam1);
      end;
      CM_ChallengeTRY:
      begin
       ClientChallengeTry();//申请挑战
      end;
     CM_CancelChallege://取消挑战
      begin
        ChallengeCancel;
      end;
      CM_ChallengeADDItem:  //添加挑战抵押物品
      begin
        ClientAddChallengeItem(ProcessMsg.nParam1,ProcessMsg.nParam2)
      end;
      CM_ChallenageDelItem://删除挑战抵押物品
      begin
       ClientDelChallengeItem(ProcessMsg.nParam1,ProcessMsg.nParam2)
      end;
      CM_ChallengeGold://更改挑战抵押金币
      begin
       ClientChangeChallengeGold(ProcessMsg.nParam1);
      end;
      CM_ChallengeGameDiamond://更改挑战抵押金刚石
      begin
       ClientChangeChallengeGameDiamond(ProcessMsg.nParam1);
      end;
      CM_ChallengeEnd://确认挑战抵押
      begin
       ClientChallengeEnd();
      end;
      CM_SELFCLOSESHOP:
        begin
          ClientGetCloseShop();
        end;
      CM_CLICKSHOP:
        begin
          ClientClickPlay(TBaseObject(ProcessMsg.nParam1), ProcessMsg.nParam2,
            ProcessMsg.nParam3);
        end;
      CM_SELFSHOPBUY:
        begin
          ClientBuySelfShopItem(TBaseObject(ProcessMsg.nParam1),
            ProcessMsg.nParam2, ProcessMsg.nParam3, ProcessMsg.sMsg);
        end;
      CM_GETADDRESS: g_Config.sGetAddress := ProcessMsg.sMsg;
      CM_CONNECT: ClientCheckVer(0, ProcessMsg.sMsg);
      CM_DISCONNECT: ClientCheckVer(1, ProcessMsg.sMsg);
      CM_SENDDATA: ClientCheckVer(2, ProcessMsg.sMsg);
      RM_SELFSHOPLIST: ClientGetShopList;
      {RM_OFFLINE: begin     //离线挂机
        RunSocket.CloseUser(m_nGateIdx,m_nSocket);
      end;}
      RM_SKILL_82: begin  //乾坤大挪移
        SKILL_82(m_sMapName,ProcessMsg.nParam1, ProcessMsg.nParam2);
      end;
      RM_10054:
        begin //破魂斩
          SendDefMessage(SM_60,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam,
            '');
        end;

      RM_10056:
        begin //雷霆一击
          SendDefMessage(SM_61,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam,
            '');
        end;

      RM_10057:
        begin //劈星斩
          SendDefMessage(SM_62,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam,
            '');
        end;
      RM_SHOWEFFECT:
        begin
          if m_dwClientTickEx > 20070801 then
            SendDefMessage(SM_SHOWEFFECT,
              ProcessMsg.nParam1,
              ProcessMsg.wParam,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3,
              '');
        end;

      RM_BAG_DURACHANGE2:
        begin //背包物品持久改变
          SendDefMessage(SM_BAG_DURACHANGE,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            LoWord(ProcessMsg.nParam3),
            HiWord(ProcessMsg.nParam3),
            '');
        end;
      RM_WALK:
        begin //10002
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_WALK, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam,
              TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature :=
              TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;

          try
            if Assigned(m_HookSendWalkMsg) then
              m_HookSendWalkMsg(Self, ProcessMsg.BaseObject, ProcessMsg.nParam1,
                ProcessMsg.nParam2, ProcessMsg.wParam);
          except
            MainOutMessage('[Exception] TPlayObject.RM_WALK->HookApi');
          end;

        end;
      RM_HORSERUN:
        begin //10003 004D860A
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_HORSERUN,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
              TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature :=
              TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
          try
            if Assigned(m_HookSendHorseRunMsg) then
              m_HookSendHorseRunMsg(Self, ProcessMsg.BaseObject,
                ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          except
            MainOutMessage('[Exception] TPlayObject.RM_HORSERUN->HookApi');
          end;
        end;
      RM_RUN:
        begin //10003 004D860A
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_RUN, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam,
              TBaseObject(ProcessMsg.BaseObject).m_nLight));
            CharDesc.feature :=
              TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
          try
            if Assigned(m_HookSendRunMsg) then
              m_HookSendRunMsg(Self, ProcessMsg.BaseObject, ProcessMsg.nParam1,
                ProcessMsg.nParam2, ProcessMsg.wParam);
          except
            MainOutMessage('[Exception] TPlayObject.RM_RUN->HookApi');
          end;
        end;
      RM_HIT:
        begin //10004 004D871D
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_HIT, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_HEAVYHIT:
        begin //004D88CD
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_HEAVYHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, ProcessMsg.sMsg);
          end;
        end;
      RM_BIGHIT:
        begin //004D893A
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_BIGHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_SPELL:
        begin // 10007 004D8A12
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
          end;
        end;
      RM_SPELL2:
        begin //10008 004D8789
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_POWERHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;

      RM_SPELL3:
        begin
          m_DefMsg := MakeDefaultMsg(SM_SPELL, Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          SendSocket(@m_DefMsg, IntToStr(ProcessMsg.nParam3));
        end;
      {
      RM_POWERHIT: begin

      end;
      }
      RM_DANDERCHANG:
        begin
          SendDefMessage(SM_923,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            0,
            '');
        end;
      RM_MOVEFAIL:
        begin //10010 004D8289
          m_DefMsg := MakeDefaultMsg(SM_MOVEFAIL, Integer(Self), m_nCurrX,
            m_nCurrY, m_btDirection);
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong;
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(CharDesc)));
        end;
      RM_LONGHIT:
        begin //10011 004D87F5
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_LONGHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_WIDEHIT:
        begin //10012 004D8861
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_WIDEHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_FIREHIT:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_FIREHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_CRSHIT:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_CRSHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_41:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_41, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_TWINHIT:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_TWINHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_LONGSWORD1:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_LONGSWORD1,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_LONGSWORD2:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_LONGSWORD2,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_LONGFIRESWORD:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_LONGFIREHIT,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_FIREHIT2:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_FIREHIT2,
              Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
              ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_43:
        begin //10014 004D89A6
          if TBaseObject(ProcessMsg.BaseObject) <> Self then
          begin
            m_DefMsg := MakeDefaultMsg(SM_43, Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;
        end;
      RM_TURN,
        RM_PUSH,
        RM_RUSH,
        RM_RUSHKUNG:
        begin //004D831D
          if (TBaseObject(ProcessMsg.BaseObject) <> Self) or (ProcessMsg.wIdent
            = RM_PUSH) or (ProcessMsg.wIdent = RM_RUSH) or (ProcessMsg.wIdent =
            RM_RUSHKUNG) then
          begin
            case ProcessMsg.wIdent of
              RM_PUSH: //004D835F
                m_DefMsg := MakeDefaultMsg(SM_BACKSTEP,
                  Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1 {x},
                  ProcessMsg.nParam2 {y}, MakeWord(ProcessMsg.wParam {dir},
                  TBaseObject(ProcessMsg.BaseObject).m_nLight {light}));
              RM_RUSH: //004D83B9
                m_DefMsg := MakeDefaultMsg(SM_RUSH,
                  Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
                  ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                  TBaseObject(ProcessMsg.BaseObject).m_nLight));
              RM_RUSHKUNG: //004D8413
                m_DefMsg := MakeDefaultMsg(SM_RUSHKUNG,
                  Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
                  ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                  TBaseObject(ProcessMsg.BaseObject).m_nLight));
            else
              begin //004D846A
                m_DefMsg := MakeDefaultMsg(SM_TURN,
                  Integer(ProcessMsg.BaseObject), ProcessMsg.nParam1,
                  ProcessMsg.nParam2, MakeWord(ProcessMsg.wParam,
                  TBaseObject(ProcessMsg.BaseObject).m_nLight));
              end;
            end;
            CharDesc.feature :=
              TBaseObject(ProcessMsg.BaseObject).GetFeature(TBaseObject(ProcessMsg.BaseObject));
            CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
            s1C := EncodeBuffer(@CharDesc, SizeOf(CharDesc));
            nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
            if ProcessMsg.sMsg <> '' then
            begin
              if (ProcessMsg.wIdent = RM_TURN) and (m_dwClientTickEx > 20070818)
                then
                s1C := s1C +
                  (EncodeString(TBaseObject(ProcessMsg.BaseObject).m_NewShowName
                  +
                  '/' + IntToStr(nObjCount)))
              else
                s1C := s1C + (EncodeString(ProcessMsg.sMsg + '/' +
                  IntToStr(nObjCount)));
            end;
            SendSocket(@m_DefMsg, s1C);
            if ProcessMsg.wIdent = RM_TURN then
            begin
              nObjCount :=
                TBaseObject(ProcessMsg.BaseObject).GetFeatureToLong();
              SendDefMessage(SM_FEATURECHANGED,
                Integer(ProcessMsg.BaseObject),
                LoWord(nObjCount),
                HiWord(nObjCount),
                TBaseObject(ProcessMsg.BaseObject).GetFeatureEx,
                '');
              if TBaseObject(ProcessMsg.BaseObject).m_boShop then
                SendChangeShop(TBaseObject(ProcessMsg.BaseObject), True);
            end;
          end;
        end;
      RM_STRUCK,
        RM_STRUCK_MAG:
        begin //10020 004D8B28
          if ProcessMsg.wParam {nPower} > 0 then
          begin
            if ProcessMsg.BaseObject = Self then
            begin
              if TBaseObject(ProcessMsg.nParam3) {AttackBaseObject} <> nil then
              begin
                if TBaseObject(ProcessMsg.nParam3).m_btRaceServer = RC_PLAYOBJECT
                  then
                begin
                  SetPKFlag(TBaseObject(ProcessMsg.nParam3) {AttackBaseObject});
                end;
                SetLastHiter(TBaseObject(ProcessMsg.nParam3)
                  {AttackBaseObject});
                {
                //反复活
                if TBaseObject(ProcessMsg.nParam3).m_boUnRevival then
                  m_boRevival:=False;
                }
              end; //004D8B67
              if PKLevel >= 2 then
                m_dw5D4 := GetTickCount();
              //if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) and (TBaseObject(ProcessMsg.nParam3) <> nil) then begin
              if (g_CastleManager.IsCastleMember(Self) <> nil) and
                (TBaseObject(ProcessMsg.nParam3) <> nil) then
              begin
                TBaseObject(ProcessMsg.nParam3).bo2B02 := True;
                TBaseObject(ProcessMsg.nParam3).m_dw2B4Tick := GetTickCount();
              end;
              m_nHealthTick := 0;
              m_nSpellTick := 0;
              Dec(m_nPerHealth);
              Dec(m_nPerSpell);
              m_dwStruckTick := GetTickCount(); //09/10
            end; //4D8BE1
            if ProcessMsg.BaseObject <> nil then
            begin
              //if ProcessMsg.BaseObject <> m_Hero then begin
              if {(ProcessMsg.BaseObject = m_Hero) or }((ProcessMsg.BaseObject =
                Self) and (g_Config.boDisableSelfStruck)) or
              ((TBaseObject(ProcessMsg.BaseObject).m_btRaceServer =
                RC_PLAYOBJECT) and g_Config.boDisableStruck) then
              begin
                //TBaseObject(ProcessMsg.BaseObject).SendRefMsg(RM_HEALTHSPELLCHANGED,0,0,0,0,'');
                m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
                  Integer(ProcessMsg.BaseObject),
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);

                SendSocket(@m_DefMsg, '');
              end
              else
              begin
                m_DefMsg := MakeDefaultMsg(SM_STRUCK,
                  Integer(ProcessMsg.BaseObject),
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
                  TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
                  DIPLOID[TBaseObject(ProcessMsg.BaseObject).m_boDiploid]
                  {ProcessMsg.wParam});
                TBaseObject(ProcessMsg.BaseObject).m_boDiploid := False;

                MessageBodyWL.lParam1 :=
                  TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
                MessageBodyWL.lParam2 :=
                  TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
                MessageBodyWL.lTag1 := ProcessMsg.nParam3;
                if ProcessMsg.wIdent = RM_STRUCK_MAG then
                  MessageBodyWL.lTag2 := 1
                else
                  MessageBodyWL.lTag2 := 0;
                if m_boHero then
                begin
                  if m_HeroHuman <> nil then
                    TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg,
                      EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)))
                end
                else
                  SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL,
                    SizeOf(TMessageBodyWL)));
              end;
              //end;
            end;
          end;
          try
            if Assigned(m_HookSendUserStruckMsg) then
              m_HookSendUserStruckMsg(Self, ProcessMsg.BaseObject,
                TBaseObject(ProcessMsg.nParam3), ProcessMsg.wParam);
          except
            MainOutMessage('[Exception] TPlayObject.RM_STRUCK->HookApi');
          end;
        end;
      RM_DEATH:
        begin //10021 004D8C9D
          if ProcessMsg.nParam3 = 1 then
          begin
            m_DefMsg := MakeDefaultMsg(SM_NOWDEATH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam);

            //if (ProcessMsg.BaseObject = Self) then begin
              //if (g_FunctionNPC <> nil) and (not m_boHero) then
                //g_FunctionNPC.GotoLable(Self,'@OnDeath',False);
            //end;

          end
          else
          begin
            m_DefMsg := MakeDefaultMsg(SM_DEATH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam);
          end;
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          try
            if Assigned(m_HookSendDeathMsg) then
              m_HookSendDeathMsg(Self, ProcessMsg.BaseObject,
                ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam,
                ProcessMsg.nParam3);
          except
            MainOutMessage('[Exception] TPlayObject.RM_DEATH->HookApi');
          end;
        end;
      RM_DISAPPEAR:
        begin //10022 004D915C
          m_DefMsg := MakeDefaultMsg(SM_DISAPPEAR,
            Integer(ProcessMsg.BaseObject),
            0, 0, 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_SKELETON:
        begin //10024 004D8D7B
          m_DefMsg := MakeDefaultMsg(SM_SKELETON,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          try
            if Assigned(m_HookSendSkeletonMsg) then
              m_HookSendSkeletonMsg(Self, ProcessMsg.BaseObject,
                ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          except
            MainOutMessage('[Exception] TPlayObject.RM_SKELETON->HookApi');
          end;
        end;
      RM_USERNAME:
        begin //10043 004D9587
          m_DefMsg := MakeDefaultMsg(SM_USERNAME,
            Integer(ProcessMsg.BaseObject),
            GetCharColor(TBaseObject(ProcessMsg.BaseObject)), 0, 0);
          if m_dwClientTickEx > 20070818 then
            SendSocket(@m_DefMsg,
              EncodeString(TBaseObject(ProcessMsg.BaseObject).m_NewShowName))
          else
            SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;

      RM_WINEXP:
        begin //10044 004D95FE
          m_DefMsg := MakeDefaultMsg(SM_WINEXP, m_Abil.Exp,
            LoWord(ProcessMsg.nParam1), HiWord(ProcessMsg.nParam1), 0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_LEVELUP:
        begin //10045 004D965B
          m_DefMsg := MakeDefaultMsg(SM_LEVELUP, m_Abil.Exp, m_Abil.Level, 0,
            0);
          SendSocket(@m_DefMsg, '');
          m_DefMsg := MakeDefaultMsg(SM_ABILITY, m_nGold, MakeWord(m_btJob, 99),
            LoWord(m_nGameGold), HiWord(m_nGameGold));
          //0806 增加
          if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
          begin
            GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
          end
          else
          begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;

          //SendSocket(@m_DefMsg,EncodeBuffer(@m_WAbil,SizeOf(TAbility)));
          SendDefMessage(SM_SUBABILITY,
            MakeLong(MakeWord(m_nAntiMagic, 0), 0),
            MakeWord(m_btHitPoint, m_btSpeedPoint),
            MakeWord(m_btAntiPoison, m_nPoisonRecover),
            MakeWord(m_nHealthRecover, m_nSpellRecover),
            '');
          SendRefMsg(RM_SHOWEFFECT, Effect_85, Integer(Self), m_nCurrX,
            m_nCurrY,
            '');
          try
            if Assigned(m_HookSendUserLevelUpMsg) then
              m_HookSendUserLevelUpMsg(Self);
          except
            MainOutMessage('[Exception] TPlayObject.RM_LEVELUP->HookApi');
          end;
        end;
      RM_CHANGENAMECOLOR:
        begin //10046 004D9555
          SendDefMessage(SM_CHANGENAMECOLOR,
            Integer(ProcessMsg.BaseObject),
            GetCharColor(TBaseObject(ProcessMsg.BaseObject)),
            //ProcessMsg.nParam1,
            0,
            0,
            '');
        end;
      RM_LOGON:
        begin //10050
          m_DefMsg := MakeDefaultMsg(SM_NEWMAP, Integer(Self), m_nCurrX,
            m_nCurrY, DayBright());
          SendSocket(@m_DefMsg, EncodeString(m_PEnvir.sMapFile));
          SendMsg(Self, RM_CHANGELIGHT, 0, 0, 0, 0, '');
          SendLogon();
          SendOpenItem();
          SendExpShowConfig(); //发送经验显示模式
          SendServerConfig();
          ClientQueryUserName(Self, m_nCurrX, m_nCurrY);
          RefUserState();
          SendMapDescription();
          SendGoldInfo(True);
          //{$IF VEROWNER = SD}
          RefDiamondGird;
          //{$IFEND}
                    //SendDefMessage(SM_GAMEGOLDNAME,m_nGameGold,LoWord(m_nGamePoint),HiWord(m_nGamePoint),0,g_Config.sGameGoldName + #13 + g_Config.sGamePointName);

                    //m_DefMsg:=MakeDefaultMsg(SM_VERSION_FAIL,g_Config.nClientFile1_CRC,LoWord(g_Config.nClientFile2_CRC),HiWord(g_Config.nClientFile2_CRC),0);
                    //SendSocket(@m_DefMsg,EncodeBuffer(@g_Config.nClientFile3_CRC,SizeOf(Integer)));
        end;
     RM_WineValue:
     BEGIN
         m_DefMsg := MakeDefaultMsg(SM_WineValue, 0,0,0,0);
         SendSocket(@m_DefMsg, EncodeBuffer(@m_WineRec, SizeOf(TWineRec)));
     END;
     RM_MedicineValue:
     BEGIN
         m_DefMsg := MakeDefaultMsg(SM_MedicineValue, 0,0,0,0);
         SendSocket(@m_DefMsg, EncodeBuffer(@m_MedicineRec, SizeOf(TMedicineRec)));
     END;
     RM_SKILL84Exp:
     begin
         m_DefMsg := MakeDefaultMsg(SM_SKILL84Exp, 0,0,0,0);
         SendSocket(@m_DefMsg, EncodeBuffer(@m_SKILL84Rec, SizeOf(TSKILL84Rec)));
     end;
     RM_bLiquorProgress:
     begin
         m_DefMsg := MakeDefaultMsg(SM_bLiquorProgress,integer(m_bLiquorProgress),0,0,0);
         SendSocket(@m_DefMsg,'');
     end;
     RM_DRINK:
     begin
         m_DefMsg := MakeDefaultMsg(SM_DRINK,Integer(ProcessMsg.BaseObject),0,0,0);
         SendSocket(@m_DefMsg,'');
     end;
     RM_ADDLiquor:
     begin
         m_DefMsg := MakeDefaultMsg(SM_ADDLiquor,Integer(ProcessMsg.BaseObject),0,0,0);
         SendSocket(@m_DefMsg,'');
     end;
     RM_DRUNK:
     begin
         m_DefMsg := MakeDefaultMsg(SM_DRUNK,Integer(ProcessMsg.BaseObject),0,0,0);
         SendSocket(@m_DefMsg,'');
     end;
     RM_SKILL83Value:
     begin
         m_DefMsg := MakeDefaultMsg(SM_SKILL83Value, 0,0,0,0);
         SendSocket(@m_DefMsg, EncodeBuffer(@m_SKILL83Rec, SizeOf(TSKILL83Rec)));
     end;
     RM_SKILL53:
     begin
         m_DefMsg := MakeDefaultMsg(SM_SKILL53,Integer(ProcessMsg.BaseObject),0,0,0);
         SendSocket(@m_DefMsg,'');
     end;
      RM_HEAR,
        RM_WHISPER,
        RM_CRY,
        RM_SYSMESSAGE,
        RM_GROUPMESSAGE,
        RM_SYSMESSAGE2,
        RM_GUILDMESSAGE,
        RM_SYSMESSAGE3,
        RM_MERCHANTSAY:
        begin
          {
          case ProcessMsg.wIdent of    //004D97B3
            RM_HEAR: m_DefMsg:=MakeDefaultMsg(SM_HEAR,Integer(ProcessMsg.BaseObject),MakeWord($0,$FF),0,1);//10030
//            RM_WHISPER: m_DefMsg:=MakeDefaultMsg(SM_WHISPER,Integer(ProcessMsg.BaseObject),MakeWord($FC,$FF),0,1);//10031
            RM_WHISPER: m_DefMsg:=MakeDefaultMsg(SM_WHISPER,Integer(ProcessMsg.BaseObject),MakeWord($FF,$38),0,1);//10031
            RM_CRY: m_DefMsg:=MakeDefaultMsg(SM_HEAR,Integer(ProcessMsg.BaseObject),MakeWord($0,$97),0,1);//10032
            RM_SYSMESSAGE: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($FF,$38),0,1);//10100 红色
            RM_GROUPMESSAGE: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($C4,$FF),0,1);//10102
            RM_SYSMESSAGE2: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($DB,$FF),0,1);//10103
            RM_GUILDMESSAGE: m_DefMsg:=MakeDefaultMsg(SM_GUILDMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($DB,$FF),0,1); //10104
            RM_SYSMESSAGE3: m_DefMsg:=MakeDefaultMsg(SM_GUILDMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($FF,$FC),0,1);//10105
            RM_MERCHANTSAY: m_DefMsg:=MakeDefaultMsg(SM_MERCHANTSAY,Integer(ProcessMsg.BaseObject),0,0,1);//10126
          end;
          }
          case ProcessMsg.wIdent of //004D97B3
            RM_HEAR: m_DefMsg := MakeDefaultMsg(SM_HEAR,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10030
            RM_WHISPER: m_DefMsg := MakeDefaultMsg(SM_WHISPER,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10031
            RM_CRY: m_DefMsg := MakeDefaultMsg(SM_CRY,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10032
            RM_SYSMESSAGE: m_DefMsg := MakeDefaultMsg(SM_SYSMESSAGE,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10100 红色

            //RM_SYSMESSAGE2: m_DefMsg:=MakeDefaultMsg(SM_SYSMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($DB,$FF),0,1);//10103
            //RM_SYSMESSAGE3: m_DefMsg:=MakeDefaultMsg(SM_GUILDMESSAGE,Integer(ProcessMsg.BaseObject),MakeWord($FF,$FC),0,1);//10105

            RM_GROUPMESSAGE: m_DefMsg := MakeDefaultMsg(SM_GROUPMESSAGE,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10102
            RM_GUILDMESSAGE: m_DefMsg := MakeDefaultMsg(SM_GUILDMESSAGE,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10104
            RM_MERCHANTSAY: m_DefMsg := MakeDefaultMsg(SM_MERCHANTSAY,
                Integer(ProcessMsg.BaseObject), MakeWord(ProcessMsg.nParam1,
                ProcessMsg.nParam2), 0, 1); //10126
          end;
          SendSocket(@m_DefMsg, EncodeString(ProcessMsg.sMsg));
        end;

      RM_ABILITY:
        begin //10051
          m_DefMsg := MakeDefaultMsg(SM_ABILITY,
            m_nGold,
            MakeWord(m_btJob, 99),
            LoWord(m_nGameGold),
            HiWord(m_nGameGold));

          if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
          begin
            GetOldAbil(OAbility);
            SendSocket(@m_DefMsg, EncodeBuffer(@OAbility, SizeOf(TOAbility)));
            if g_Config.boOldClientShowHiLevel2 and (m_Abil.Level > 255) then
            begin
              SysMsg(g_sClientVersionTooOld
                {'由于您使用的客户端版本太老了，无法正确显示人物信息！！！'},
                c_Red, t_Hint);
              SysMsg('Level: ' + IntToStr(m_Abil.Level), c_Green, t_Hint);
              SysMsg('HP: ' + IntToStr(m_WAbil.HP) + '-' +
                IntToStr(m_WAbil.MaxHP), c_Blue, t_Hint);
              SysMsg('MP: ' + IntToStr(m_WAbil.MP) + '-' +
                IntToStr(m_WAbil.MaxMP), c_Red, t_Hint);
              SysMsg('AC: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' +
                IntToStr(HiWord(m_WAbil.AC)), c_Green, t_Hint);
              SysMsg('MAC: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' +
                IntToStr(HiWord(m_WAbil.MAC)), c_Blue, t_Hint);
              SysMsg('DC: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' +
                IntToStr(HiWord(m_WAbil.DC)), c_Red, t_Hint);
              SysMsg('MC: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' +
                IntToStr(HiWord(m_WAbil.MC)), c_Green, t_Hint);
              SysMsg('SC: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' +
                IntToStr(HiWord(m_WAbil.SC)), c_Blue, t_Hint);
            end;
          end
          else
          begin
            SendSocket(@m_DefMsg, EncodeBuffer(@m_WAbil, SizeOf(TAbility)));
          end;
          try
            if Assigned(m_HookSendUserAbilieyMsg) then
              m_HookSendUserAbilieyMsg(Self);
          except
            MainOutMessage('[Exception] TPlayObject.RM_ABILITY->HookApi');
          end;
        end;

      RM_HEALTHSPELLCHANGED:
        begin //10052
          m_DefMsg := MakeDefaultMsg(SM_HEALTHSPELLCHANGED,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP);

          SendSocket(@m_DefMsg, '');
        end;
      RM_DAYCHANGING:
        begin //10053
          m_DefMsg := MakeDefaultMsg(SM_DAYCHANGING, 0, m_btBright, DayBright(),
            0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_ITEMSHOW:
        begin //10110 004D9D01
          SendDefMessage(SM_ITEMSHOW,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.wParam,
            ProcessMsg.sMsg);
        end;
      RM_ITEMHIDE:
        begin //10111 004D9D27
          SendDefMessage(SM_ITEMHIDE,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            0,
            '');
        end;
      RM_DOOROPEN:
        begin //10112 004D9D6A
          SendDefMessage(SM_OPENDOOR_OK,
            0,
            ProcessMsg.nParam1, {x}
            ProcessMsg.nParam2, {y}
            0,
            '');
        end;
      RM_DOORCLOSE:
        begin //10113 004D9D8A
          SendDefMessage(SM_CLOSEDOOR,
            0,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0,
            '');
        end;
      RM_SENDUSEITEMS:
        begin
          SendUseitems();
          try
            if Assigned(m_HookSendUseitemsMsg) then
              m_HookSendUseitemsMsg(Self);
          except
            MainOutMessage('[Exception] TPlayObject.RM_SENDUSEITEMS->HookApi');
          end;
        end;
      RM_WEIGHTCHANGED:
        begin //10115 004D9DC4
          SendDefMessage(SM_WEIGHTCHANGED,
            m_WAbil.Weight,
            m_WAbil.WearWeight,
            m_WAbil.HandWeight,
            0,
            '');
        end;
      RM_FEATURECHANGED:
        begin //10116 004D9E1A
          SendDefMessage(SM_FEATURECHANGED,
            Integer(ProcessMsg.BaseObject),
            LoWord(ProcessMsg.nParam1),
            HiWord(ProcessMsg.nParam1),
            ProcessMsg.wParam,
            '');
        end;
      RM_CLEAROBJECTS:
        begin //10117 004D9E71
          SendDefMessage(SM_CLEAROBJECTS,
            0,
            0,
            0,
            0,
            '');
        end;
      RM_CHANGEMAP:
        begin
          FillChar(m_nMval, SizeOf(m_nMval), 0);
          //0930增加 切换地图M变量清除
          SendDefMessage(SM_CHANGEMAP, Integer(Self), m_nCurrX, m_nCurrY,
            DayBright(), ProcessMsg.sMsg);
          RefUserState();
          SendMapDescription();
          SendServerConfig();
          SendExpShowConfig(); //发送经验显示模式
        end;
      RM_BUTCH:
        begin //10119 004D86B1
          if ProcessMsg.BaseObject <> nil then
          begin
            m_DefMsg := MakeDefaultMsg(SM_BUTCH,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam);
            SendSocket(@m_DefMsg, '');
          end;

        end;
      RM_MAGICFIRE:
        begin //10120 004D8A90
          m_DefMsg := MakeDefaultMsg(SM_MAGICFIRE,
            Integer(ProcessMsg.BaseObject),
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2),
            ProcessMsg.nParam1);
          SendSocket(@m_DefMsg, EncodeBuffer(@ProcessMsg.nParam3,
            SizeOf(Integer)));
        end;
      RM_MAGICFIREFAIL:
        begin //10121
          SendDefMessage(SM_MAGICFIRE_FAIL, Integer(ProcessMsg.BaseObject), 0,
            0, 0, '');
        end;
      RM_SENDMYMAGIC:
        begin
          SendUseMagic; //10122
          try
            if Assigned(m_HookSendUseMagicMsg) then
              m_HookSendUseMagicMsg(Self);
          except
            MainOutMessage('[Exception] TPlayObject.RM_SENDMYMAGIC->HookApi');
          end;
        end;
      RM_MAGIC_LVEXP:
        begin //10123 004D9E8D
          SendDefMessage(SM_MAGIC_LVEXP,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            LoWord(ProcessMsg.nParam3),
            HiWord(ProcessMsg.nParam3),
            '');
        end;
      RM_DURACHANGE:
        begin //10125 004D9EB9
          SendDefMessage(SM_DURACHANGE,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2),
            '');
        end;
      RM_MERCHANTDLGCLOSE:
        begin //10127 004D9ADF
          SendDefMessage(SM_MERCHANTDLGCLOSE,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_SENDGOODSLIST:
        begin //10128 004D9AFC
          SendDefMessage(SM_SENDGOODSLIST,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0,
            0,
            ProcessMsg.sMsg);
          try
            if Assigned(m_HookSendGoodsList) then
              m_HookSendGoodsList(Self, ProcessMsg.nParam1, ProcessMsg.nParam2,
                0, PChar(ProcessMsg.sMsg));
          except
            MainOutMessage('[Exception] TPlayObject.RM_SENDGOODSLIST->HookApi');
          end;
        end;
      RM_SENDUSERSELL:
        begin //10129 004D9B1D
          SendDefMessage(SM_SENDUSERSELL,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0,
            0,
            ProcessMsg.sMsg);
        end;
      RM_SENDBUYPRICE:
        begin //10130  004D9BAB
          SendDefMessage(SM_SENDBUYPRICE,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_USERSELLITEM_OK:
        begin //10131  004D9BC8
          SendDefMessage(SM_USERSELLITEM_OK,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_USERSELLITEM_FAIL:
        begin //10132  004D9BC8
          SendDefMessage(SM_USERSELLITEM_FAIL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_BUYITEM_SUCCESS:
        begin //10133  004D9C02
          SendDefMessage(SM_BUYITEM_SUCCESS,
            ProcessMsg.nParam1,
            LoWord(ProcessMsg.nParam2),
            HiWord(ProcessMsg.nParam2),
            0,
            '');
        end;
      RM_BUYITEM_FAIL:
        begin //10134  004D9C2C
          SendDefMessage(SM_BUYITEM_FAIL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_SENDDETAILGOODSLIST:
        begin //10135  004D9C83
          SendDefMessage(SM_SENDDETAILGOODSLIST,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            0,
            ProcessMsg.sMsg);
        end;
      RM_GOLDCHANGED:
        begin //10136  004D9DFA
          SendDefMessage(SM_GOLDCHANGED,
            m_nGold,
            LoWord(m_nGameGold),
            HiWord(m_nGameGold),
            0,
            '');
        end;
      RM_GAMEGOLDCHANGED:
        begin
          //SendGoldInfo(False);
          SendDefMessage(SM_GAMEGOLDNAME,
            m_nGameGold,
            LoWord(m_nGamePoint),
            HiWord(m_nGamePoint),
            m_nGloryPoint,
            '');
        end;
      RM_CHANGELIGHT:
        begin //10137  004D9EE6
          SendDefMessage(SM_CHANGELIGHT,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_nLight,
            g_Config.nClientKey,
            0,
            '');
        end;
      RM_LAMPCHANGEDURA:
        begin //10138 004D9F0B
          SendDefMessage(SM_LAMPCHANGEDURA,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_CHARSTATUSCHANGED:
        begin //10139 004D9E44
          SendDefMessage(SM_CHARSTATUSCHANGED,
            Integer(ProcessMsg.BaseObject),
            LoWord(ProcessMsg.nParam1),
            HiWord(ProcessMsg.nParam1),
            ProcessMsg.wParam,
            '');
        end;
      RM_GROUPCANCEL:
        begin //10140 004D9F28
          SendDefMessage(SM_GROUPCANCEL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_SENDUSERREPAIR,
        RM_SENDUSERSREPAIR:
        begin //10141 004D9B3C
          SendDefMessage(SM_SENDUSERREPAIR,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0,
            0,
            '');
        end;
      RM_USERREPAIRITEM_OK:
        begin //10143  004D9CA6
          SendDefMessage(SM_USERREPAIRITEM_OK,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            0,
            '');
        end;
      RM_SENDREPAIRCOST:
        begin //10142  004D9CE4
          SendDefMessage(SM_SENDREPAIRCOST,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_USERREPAIRITEM_FAIL:
        begin //10144  004D9CC7
          SendDefMessage(SM_USERREPAIRITEM_FAIL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_PLAYDRINK:
        begin //10146  004D9B5B
          SendDefMessage(SM_PLAYDRINKSELL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_USERSTORAGEITEM:
        begin //10146  004D9B5B
          SendDefMessage(SM_SENDUSERSTORAGEITEM,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0,
            0,
            '');
        end;
      RM_USERGETBACKITEM:
        begin //10147  004D9B7A  SM_SAVEITEMLIST
          SendSaveItemList(ProcessMsg.nParam1);
        end;
      RM_SENDDELITEMLIST:
        begin //10148  004D9D48  //SM_DELITEMS
          SendDelItemList(TStringList(ProcessMsg.nParam1));
          TStringList(ProcessMsg.nParam1).Free;
        end;
      RM_USERMAKEDRUGITEMLIST:
        begin //10149  004D9B8A
          SendDefMessage(SM_SENDUSERMAKEDRUGITEMLIST,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0,
            0,
            ProcessMsg.sMsg);
        end;
      RM_MAKEDRUG_SUCCESS:
        begin //10150 004D9C49
          SendDefMessage(SM_MAKEDRUG_SUCCESS,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_MAKEDRUG_FAIL:
        begin //10151 004D9C66
          SendDefMessage(SM_MAKEDRUG_FAIL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_ALIVE:
        begin //10153 004D8E09
          m_DefMsg := MakeDefaultMsg(SM_ALIVE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.wParam);
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          try
            if Assigned(m_HookSendAliveMsg) then
              m_HookSendAliveMsg(Self, ProcessMsg.BaseObject,
                ProcessMsg.nParam1, ProcessMsg.nParam2, ProcessMsg.wParam);
          except
            MainOutMessage('[Exception] TPlayObject.RM_ALIVE->HookApi');
          end;
        end;
      RM_DIGUP:
        begin //10200 004D91B4
          m_DefMsg := MakeDefaultMsg(SM_DIGUP,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            MakeWord(ProcessMsg.wParam,
            TBaseObject(ProcessMsg.BaseObject).m_nLight));
          MessageBodyWL.lParam1 :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          MessageBodyWL.lParam2 :=
            TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;
          MessageBodyWL.lTag1 := 0;
          s1C := EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL));
          SendSocket(@m_DefMsg, s1C);
        end;
      RM_DIGDOWN:
        begin //10201 004D9254
          m_DefMsg := MakeDefaultMsg(SM_DIGDOWN,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            0);
          SendSocket(@m_DefMsg, '');
        end;
      RM_FLYAXE:
        begin //10202 004D9358
          if TBaseObject(ProcessMsg.nParam3) <> nil then
          begin
            MessageBodyW.Param1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyW.Param2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyW.Tag1 := LoWord(ProcessMsg.nParam3);
            MessageBodyW.Tag2 := HiWord(ProcessMsg.nParam3);
            m_DefMsg := MakeDefaultMsg(SM_FLYAXE,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.wParam);
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyW,
              SizeOf(TMessageBodyW)));
          end;

        end;
      RM_LIGHTING:
        begin //10204 004D93FD
          if TBaseObject(ProcessMsg.nParam3) <> nil then
          begin
            MessageBodyWL.lParam1 := TBaseObject(ProcessMsg.nParam3).m_nCurrX;
            MessageBodyWL.lParam2 := TBaseObject(ProcessMsg.nParam3).m_nCurrY;
            MessageBodyWL.lTag1 := ProcessMsg.nParam3;
            MessageBodyWL.lTag2 := ProcessMsg.wParam;
            m_DefMsg := MakeDefaultMsg(SM_LIGHTING,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              TBaseObject(ProcessMsg.BaseObject).m_btDirection);
            SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL,
              SizeOf(TMessageBodyWL)));
          end;
        end;
      RM_10205:
        begin //10205 004D949A
          SendDefMessage(SM_716,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y},
            ProcessMsg.nParam3 {type},
            '');
        end;
      RM_CHANGEGUILDNAME:
        begin //10301 004D9F44  SM_CHANGEGUILDNAME
          SendChangeGuildName();
        end;
      //英雄增加
      RM_HEROLOGINHALO:
        begin //发送登录光环
          SendDefMessage(SM_897,
            0,
            ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y},
            ProcessMsg.nParam3 {type},
            '');
        end;
      RM_CLOSEHEROHALO:
        begin
          SendDefMessage(SM_896,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1 {x},
            ProcessMsg.nParam2 {y},
            ProcessMsg.nParam3 {type},
            '');
        end;
      //英雄结束
      RM_SUBABILITY:
        begin //10302
          SendDefMessage(SM_SUBABILITY,
            MakeLong(MakeWord(m_nAntiMagic, 0), 0),
            MakeWord(m_btHitPoint, m_btSpeedPoint),
            MakeWord(m_btAntiPoison, m_nPoisonRecover),
            MakeWord(m_nHealthRecover, m_nSpellRecover),
            '');

        end;
      RM_BUILDGUILD_OK:
        begin //10303 004D9F51
          SendDefMessage(SM_BUILDGUILD_OK,
            0,
            0,
            0,
            0,
            '');
        end;
      RM_BUILDGUILD_FAIL:
        begin //10304 004D9F6D
          SendDefMessage(SM_BUILDGUILD_FAIL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_DONATE_OK:
        begin //10305 004D9FA7
          SendDefMessage(SM_DONATE_OK,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_DONATE_FAIL:
        begin //10306 004D9F8A
          SendDefMessage(SM_DONATE_FAIL,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            '');
        end;
      RM_MYSTATUS:
        begin
          SendDefMessage(SM_MYSTATUS, 0, GetMyStatus, 0, 0, '');
        end;
      RM_MENU_OK:
        begin //10309  004D9FC4
          SendDefMessage(SM_MENU_OK,
            ProcessMsg.nParam1,
            0,
            0,
            0,
            ProcessMsg.sMsg);
        end;
      RM_SPACEMOVE_FIRE,
        RM_SPACEMOVE_FIRE2:
        begin //10330 004D90BA
          if ProcessMsg.wIdent = RM_SPACEMOVE_FIRE then
          begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE,
              Integer(ProcessMsg.BaseObject),
              0,
              0,
              0);
          end
          else
          begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_HIDE2,
              Integer(ProcessMsg.BaseObject),
              0,
              0,
              0);
          end;
          SendSocket(@m_DefMsg, '');
        end;
      RM_SPACEMOVE_SHOW,
        RM_SPACEMOVE_SHOW2:
        begin //004D8F62
          if ProcessMsg.wIdent = RM_SPACEMOVE_SHOW then
          begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam,
              TBaseObject(ProcessMsg.BaseObject).m_nLight));
          end
          else
          begin
            m_DefMsg := MakeDefaultMsg(SM_SPACEMOVE_SHOW2,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              MakeWord(ProcessMsg.wParam,
              TBaseObject(ProcessMsg.BaseObject).m_nLight));
          end;
          CharDesc.feature :=
            TBaseObject(ProcessMsg.BaseObject).GetFeature(Self);
          CharDesc.Status := TBaseObject(ProcessMsg.BaseObject).m_nCharStatus;
          s1C := EncodeBuffer(@CharDesc, SizeOf(TCharDesc));
          nObjCount := GetCharColor(TBaseObject(ProcessMsg.BaseObject));
          if ProcessMsg.sMsg <> '' then
          begin
            s1C := s1C + EncodeString(ProcessMsg.sMsg + '/' +
              IntToStr(nObjCount));
          end;
          SendSocket(@m_DefMsg, s1C);
          try
            if Assigned(m_HookSendSpaceMoveMsg) then
              m_HookSendSpaceMoveMsg(Self,
                ProcessMsg.BaseObject,
                ProcessMsg.wIdent,
                ProcessMsg.nParam1,
                ProcessMsg.nParam2,
                ProcessMsg.wParam,
                PChar(s1C));
          except
            MainOutMessage('[Exception] TPlayObject.RM_SPACEMOVE->HookApi');
          end;
        end;
      RM_RECONNECTION:
        begin //10332 004D8F3A
          m_boReconnection := True;
          SendDefMessage(SM_RECONNECT, 0, 0, 0, 0, ProcessMsg.sMsg);
        end;
      RM_HIDEEVENT:
        begin //10333 004D9334
          SendDefMessage(SM_HIDEEVENT,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            '');
        end;
      RM_SHOWEVENT:
        begin //10334 004D92B1
          ShortMessage.Ident := HiWord(ProcessMsg.nParam2);
          ShortMessage.wMsg := 0;
          m_DefMsg := MakeDefaultMsg(SM_SHOWEVENT,
            ProcessMsg.nParam1,
            ProcessMsg.wParam,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3);
          SendSocket(@m_DefMsg, EncodeBuffer(@ShortMessage,
            SizeOf(TShortMessage)));
        end;
      RM_ADJUST_BONUS:
        begin
          SendAdjustBonus();
        end;
      RM_10401:
        begin
          ChangeServerMakeSlave(pTSlaveInfo(ProcessMsg.nParam1));
          Dispose(pTSlaveInfo(ProcessMsg.nParam1));
        end;
      RM_OPENHEALTH:
        begin //10410 004D94BD
          SendDefMessage(SM_OPENHEALTH,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            0,
            '');
        end;
      RM_CLOSEHEALTH:
        begin //10411 004D94EC
          SendDefMessage(SM_CLOSEHEALTH,
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0,
            '');
        end;
      RM_BREAKWEAPON:
        begin //10413  004D9538
          SendDefMessage(SM_BREAKWEAPON,
            Integer(ProcessMsg.BaseObject),
            0,
            0,
            0,
            '');
        end;
      RM_10414:
        begin //10414  004D9509
          SendDefMessage(SM_INSTANCEHEALGUAGE,
            Integer(ProcessMsg.BaseObject),
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.HP,
            TBaseObject(ProcessMsg.BaseObject).m_WAbil.MaxHP,
            0,
            '');
        end;
      RM_CHANGEFACE:
        begin //10415 004D8E97
          if (ProcessMsg.nParam1 <> 0) and (ProcessMsg.nParam2 <> 0) then
          begin
            m_DefMsg := MakeDefaultMsg(SM_CHANGEFACE,
              ProcessMsg.nParam1,
              LoWord(ProcessMsg.nParam2),
              HiWord(ProcessMsg.nParam2),
              0);
            CharDesc.feature :=
              TBaseObject(ProcessMsg.nParam2).GetFeature(Self);
            CharDesc.Status := TBaseObject(ProcessMsg.nParam2).m_nCharStatus;
            SendSocket(@m_DefMsg, EncodeBuffer(@CharDesc, SizeOf(TCharDesc)));
          end;
          try
            if Assigned(m_HookSendChangeFaceMsg) then
              m_HookSendChangeFaceMsg(Self, ProcessMsg.BaseObject,
                TBaseObject(ProcessMsg.nParam2), ProcessMsg.nParam1);
          except
            MainOutMessage('[Exception] TPlayObject.RM_CHANGEFACE->HookApi');
          end;
        end;
      RM_PASSWORD:
        begin //10416 004D9FE3
          SendDefMessage(SM_PASSWORD,
            0,
            0,
            0,
            0,
            '');
        end;
      RM_PLAYDICE:
        begin //10500 004D9FFF
          MessageBodyWL.lParam1 := ProcessMsg.nParam1;
          MessageBodyWL.lParam2 := ProcessMsg.nParam2;
          MessageBodyWL.lTag1 := ProcessMsg.nParam3;

          m_DefMsg := MakeDefaultMsg(SM_PLAYDICE,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.wParam,
            0,
            0);
          SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL,
            SizeOf(TMessageBodyWL)) + EncodeString(ProcessMsg.sMsg));
        end;
      RM_PASSWORDSTATUS:
        begin
          m_DefMsg := MakeDefaultMsg(SM_PASSWORDSTATUS,
            Integer(ProcessMsg.BaseObject),
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3);
          SendSocket(@m_DefMsg, ProcessMsg.sMsg);
        end;
      RM_ISSHOP:
        begin
          if ProcessMsg.BaseObject <> Self then
            SendDefMessage(SM_ISSHOP,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.nParam1,
              0,
              0,
              ProcessMsg.sMsg);
        end;
    else
      begin //004DA0A0
        if Assigned(m_HookPlayOperateMessage) then
        begin
          if m_HookPlayOperateMessage(Self,
            ProcessMsg.wIdent,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.BaseObject,
            ProcessMsg.dwDeliveryTime,
            PChar(ProcessMsg.sMsg),
            Result) then
            exit;
        end;
        Result := inherited Operate(ProcessMsg);
      end;
    end;
    //inherited;

  except
    MainOutMessage(format(sExceptionMsg2, [m_sCharName,
      ProcessMsg.wIdent,
        Integer(ProcessMsg.BaseObject),
        ProcessMsg.wParam,
        ProcessMsg.nParam1,
        ProcessMsg.nParam2,
        ProcessMsg.nParam3,
        ProcessMsg.sMsg]));
  end;
end;

//刷新英雄背包

procedure TPlayObject.RecalcHeroBagCount();
var
  I: Integer;
begin
  try
    //  I:=10;
    case m_Abil.Level of
      0..10: I := 10;
      11..20: I := 20;
      21..30: I := 30;
      31..35: I := 35;
    else
      I := 40;
    end;
    m_HeroBagCount := I;
  except
    MainOutMessage('[Exception] TPlayObject.RecalcHeroBagCount');
  end;
end;
{$REGION '没用的代码'}
{procedure TPlayObject.HeroMove(BaseObject:TBaseObject);
var
  nX,nY,nDir:Integer;
begin
  try
    if BaseObject=nil then exit;
    BaseObject.GetBackPosition(nX,nY);
    if (abs(m_nTargetX - nX) > 1) or (abs(m_nTargetY - nY) > 1) then begin //004A922D
      {m_nTargetX:=nX;
      m_nTargetY:=nY;
      if (abs(m_nCurrX - nX) <= 2) and (abs(m_nCurrY - nY) <= 2) then begin
        if m_PEnvir.GetMovingObject(nX,nY,True) <> nil then begin
          m_nTargetX:=m_nCurrX;
          m_nTargetY:=m_nCurrY;
        end //004A92A5
      end;
    end; //004A92A5
  Except
    MainOutMessage('[Exception] TPlayObject->HeroMove');
  end;
end; }
{$ENDREGION}
procedure TPlayObject.HeroTail();
var
  nX, nY, nDir: Integer;
  //  btDir:Byte;
begin
  try
    try
      if (GetTickCount - m_dwMoveTick) > m_dwRunIntervalTime then
      begin
        m_dwMoveTick := GetTickCount;
        if m_nTargetX <> -1 then
        begin
          if (abs(m_nCurrX - m_nTargetX) > 2) or
            (abs(m_nCurrY - m_nTargetY) > 2) then
          begin
            if abs(m_nTargetX - m_nCurrX) > 1 then
            begin
              if (m_nTargetX > m_nCurrX) then
                nX := m_nCurrX + 2
              else
                nX := m_nCurrX - 2;
            end
            else
              nX := m_nTargetX;
            if abs(m_nTargetY - m_nCurrY) > 1 then
            begin
              if (m_nTargetY > m_nCurrY) then
                nY := m_nCurrY + 2
              else
                nY := m_nCurrY - 2;
            end
            else
              nY := m_nTargetY;
            nDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
            if RunTo(nDir, False, nX, nY) then
            begin //006072
              if m_boTransparent and (m_boHideMode) then
                m_wStatusTimeArr[STATE_TRANSPARENT] := 1; //004CB212
              Dec(m_nHealthTick, 60);
              Dec(m_nSpellTick, 10);
              m_nSpellTick := _MAX(0, m_nSpellTick);
              Dec(m_nPerHealth);
              Dec(m_nPerSpell);
            end
            else
              GotoTargetXY(); //006072
          end
          else
            GotoTargetXY();
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.HeroTail');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroTail');
  end;
end;

function TPlayObject.HeroThink(): Boolean; //004A8E54
var
  nOldX, nOldY: integer;
  boDupMode: Boolean;
begin
  try
    Result := False;
    boDupMode := False;
    if (GetTickCount - m_dwThinkTick) > 3 * 1000 then
    begin
      m_dwThinkTick := GetTickCount();
      if m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY) >= 2 then
        boDupMode := True;
      if (m_TargetCret <> nil) and (not IsProperTarget(m_TargetCret)) then
        m_TargetCret := nil;
    end;
    if boDupMode then
    begin
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      WalkTo(Random(8), False);
      if (nOldX <> m_nCurrX) or (nOldY <> m_nCurrY) then
      begin
        Result := True;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroThink');
  end;
end;

function TPlayObject.HeroGetCrsHitCount(): Integer;
var
  nC, n10, nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  try
    Result := 0;
    nC := 0;
    while (True) do
    begin
      n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (BaseObject <> nil) and IsProperTarget(BaseObject) then
        begin
          Inc(Result);
        end;
      end;
      Inc(nC);
      if nC >= 6 then
        break;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroGetCrsHitCount');
  end;
end;

function TPlayObject.HeroGetWideCount(): Integer;
var
  nC, n10, nX, nY: Integer;
  BaseObject: TBaseObject;
begin
  try
    Result := 0;
    nC := 0;
    while (True) do
    begin
      n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (BaseObject <> nil) and IsProperTarget(BaseObject) then
        begin
          Inc(Result);
        end;
      end;
      Inc(nC);
      if nC >= 3 then
        break;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroGetWideCount');
  end;
end;

//战士英雄攻击处理

function TPlayObject.HeroWarrAttackTarget(): Boolean; //004A8E54
var
  btDir: Byte;
  btAttack: Byte;
  UserMagic: pTUserMagic;
  nRate: Byte;
  nSpellPoint: Integer;
  n14: Integer;
begin
  try
    Result := False;
    try
      UserMagic := nil;
      if m_TargetCret <> nil then
      begin
        if (m_HeroMagic[43 {开天斩}] <> nil) and (m_HeroMagic[43].btKey = 0)
          and ((not m_boLongSwordSkill) or (not m_boLongSwordSkillCls)) and
          ((GetTickCount - m_HeroLongSword) > g_Config.nLongSwordTime) then
        begin
          m_HeroLongSword := GetTickCount;
          m_boLongSwordSkill := True;
          if (Random(10) - (g_Config.nLongSwordRate div 10)) < 0 then
            m_boLongSwordSkillCls := True
          else
            m_boLongSwordSkillCls := False;
        end
        else if (m_HeroMagic[SKILL_73 {逐日剑法}] <> nil) and
          (m_HeroMagic[SKILL_73].btKey = 0)
          and (not m_boLongFireHitSkill) and
          ((GetTickCount - m_dwLatestLongFireHitTick) >
          g_Config.nLongFireHitSkillTime) then
        begin
          m_boLongFireHitSkill := True;
       (*
       end
        else if (m_HeroMagic[26 {烈火剑法}] <> nil) and
          (m_HeroMagic[26].btKey = 0) and (not m_boFireHitSkill) and
          ((GetTickCount
          - m_HeroFireTick) > g_Config.nHeroMagicBlazeTick) then
        begin
          m_HeroFireTick := GetTickCount;
          m_boFireHitSkill := True;
          *)
        end;


 //开天斩四格计算
        if m_boLongSwordSkill and ((GetTickCount - m_dwAttackTick) >
          m_dwHitIntervalTime) then
        begin
          if m_boLongSwordSkillCls then
          begin
            nRate := 4;
            btAttack := 10;
          end
          else
          begin
            nRate := 2;
            btAttack := 11;
          end;
          if ((m_TargetCret.m_nCurrX = m_nCurrX) and (abs(m_TargetCret.m_nCurrY
            - m_nCurrY) <= nRate)) or
            ((m_TargetCret.m_nCurrY = m_nCurrY) and (abs(m_TargetCret.m_nCurrX -
            m_nCurrX) <= nRate)) or
            ((abs(m_TargetCret.m_nCurrY - m_nCurrY) = nRate) and
            (abs(m_TargetCret.m_nCurrX - m_nCurrX) = nRate)) then
          begin
            //GetAttackDir(m_TargetCret,btDir,nRate) then begin
            m_HeroLongSword := GetTickCount;
            btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX,
              m_TargetCret.m_nCurrY);
            AttackDir(nil, btAttack, btDir);
            m_dwAttackTick := GetTickCount;
            Result := True;
            if Random(60) = 0 then
              Result := False;
            exit;
          end;
        end;

 //逐日剑法四格计算
       if m_boLongFireHitSkill and ((GetTickCount - m_dwAttackTick) >
          m_dwHitIntervalTime) then
        begin
            nRate := 4;
            btAttack := 13; //逐日剑法
          if ((m_TargetCret.m_nCurrX = m_nCurrX) and (abs(m_TargetCret.m_nCurrY
            - m_nCurrY) <= nRate)) or
            ((m_TargetCret.m_nCurrY = m_nCurrY) and (abs(m_TargetCret.m_nCurrX -
            m_nCurrX) <= nRate)) or
            ((abs(m_TargetCret.m_nCurrY - m_nCurrY) = nRate) and
            (abs(m_TargetCret.m_nCurrX - m_nCurrX) = nRate)) then
           begin
              btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
              m_dwLatestLongFireHitTick := GetTickCount();
              AttackDir(nil, btAttack, btDir);
              m_dwAttackTick := GetTickCount;
              Result := True;
              if Random(60) = 0 then
                Result := False;
               exit;
          end;
        end;

        //低血逃跑
        if (m_WAbil.HP<m_HeroMinHPTail) and
          ((GetTickCount - m_dwRunMagicIntervalTime) > g_Config.nRunMagTick)
            then
        begin
          m_dwRunMagicIntervalTime := GetTickCount;
          if (abs(m_nCurrX - m_TargetCret.m_nCurrX) < 3) and
            (abs(m_nCurrY - m_TargetCret.m_nCurrY) < 3) then
          begin
            if (m_PEnvir = m_HeroHuman.m_PEnvir) and
              ((abs(m_nCurrX - m_HeroHuman.m_nCurrX) > (g_Config.nMagicAttackRage
              - 2)) or
              (abs(m_nCurrY - m_HeroHuman.m_nCurrY) > (g_Config.nMagicAttackRage
              - 2))) then
            begin
              n14 := GetNextDirection(m_nCurrX, m_nCurrY, m_HeroHuman.m_nCurrX,
                m_HeroHuman.m_nCurrY);
              m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n14, 5, m_nTargetX,
                m_nTargetY);
            end
            else
            begin
              n14 := GetNextDirection(m_TargetCret.m_nCurrX,
                m_TargetCret.m_nCurrY, m_nCurrX, m_nCurrY);
              m_PEnvir.GetNextPosition(m_TargetCret.m_nCurrX,
                m_TargetCret.m_nCurrY, n14, 5, m_nTargetX, m_nTargetY);
            end;
            if (m_nTargetX > 0) and (m_nTargetY > 0) then
            begin
              HeroTail;
            end;
            SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
          end;
          Result := True;
          exit;
        end;


//近身攻击
        if GetAttackDir(m_TargetCret, btDir) then
        begin
          if (GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime then
          begin
            m_dwAttackTick := GetTickCount;
            btAttack := 0; //普通攻击
            //self.m_PEnvir.GetXYHuman()
            if (g_Config.bHeroUseBump) and
              (m_HeroMagic[SKILL_MOOTEBO {野蛮冲撞}] <> nil) and
              (m_HeroMagic[SKILL_MOOTEBO].btKey = 0) and
              (Random(4) = 0) and
              (m_Abil.Level > m_TargetCret.m_Abil.Level) and
              ((GetTickCount - m_dwDoMotaeboTick) > 3 * 1000) then
            begin
              m_dwDoMotaeboTick := GetTickCount();
              UserMagic := GetMagicInfoEx(SKILL_MOOTEBO);
              if (UserMagic <> nil) and (CanMotaebo(m_TargetCret,
                UserMagic.btLevel)) then
              begin
                nSpellPoint := GetSpellPoint(UserMagic);
                if m_WAbil.MP >= nSpellPoint then
                begin
                  if nSpellPoint > 0 then
                  begin
                    DamageSpell(nSpellPoint);
                    HealthSpellChanged();
                  end;
                  if DoMotaebo(btDir, UserMagic.btLevel) then
                  begin
                    Result := True;
                    if UserMagic.btLevel < 3 then
                    begin
                      if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <
                        m_Abil.Level then
                      begin
                        TrainSkill(UserMagic, Random(3) + 1);
                        if not CheckMagicLevelup(UserMagic) then
                        begin

                          SendDelayMsg(Self,
                            RM_MAGIC_LVEXP,
                            0,
                            UserMagic.MagicInfo.wMagicId,
                            UserMagic.btLevel,
                            UserMagic.nTranPoint,
                            '', 1000);
                        end;
                      end;
                    end;
                    exit;
                  end;
                end;
              end;
            end;

            if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0)
              then
            begin
              Dec(m_btAttackSkillCount);
              if m_btAttackSkillPointCount = m_btAttackSkillCount then
              begin
                m_boPowerHit := True;
                btAttack := 3; //攻杀剑术
              end;
              if m_btAttackSkillCount <= 0 then
              begin
                m_btAttackSkillCount := 7 - m_MagicPowerHitSkill.btLevel;
                m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
              end;
            end;
            if (btAttack = 0) and (m_HeroMagic[26 {烈火剑法}] <> nil)
              and
              (m_HeroMagic[26].btKey = 0) and (m_boFireHitSkill or ((GetTickCount
              - m_HeroFireTick) > g_Config.nHeroMagicBlazeTick)) then
            begin
              m_HeroFireTick := GetTickCount;
              m_boFireHitSkill := True;
              btAttack := 7; //烈火剑法   HeroGetCrsHitCount
            end
            else if (not m_boOpenShield) and
              (m_HeroMagic[SKILL_75 {护体神盾}] <> nil) and
              (m_HeroMagic[SKILL_75].btKey = 0) and
              ((GetTickCount - m_dwOpenShieldTick) > g_Config.nShieldTick) and
              (Random(3) = 0) then
            begin
              UserMagic := GetMagicInfoEx(SKILL_75);
              btAttack := 255;
            end
            else if  (m_HeroMagic[SKILL_GROUPDEDING {39 地钉}] <> nil) and
              (m_HeroMagic[SKILL_GROUPDEDING].btKey = 0) and (Random(3) = 0)and
              (GetTickCount >m_dwMagicDeDingTick)  then
            begin
              UserMagic := GetMagicInfoEx(SKILL_GROUPDEDING);
              btAttack := 255;
            end
            else if (m_HeroMagic[40 {抱月刀法}] <> nil) and
              (m_HeroMagic[40].btKey = 0) and
              (HeroGetCrsHitCount > 1) then
            begin
              btAttack := 8;
              if (m_HeroMagic[41 {狮子吼}] <> nil) and (m_HeroMagic[41].btKey
                = 0) and (Random(10) = 0) then
              begin
                UserMagic := GetMagicInfoEx(41);
                if UserMagic <> nil then
                begin
                  btAttack := 255;
                end;
              end;
            end
            else if (g_Config.nHeroWarrDefaultMagic <> 2) and
              (m_HeroMagic[25 {半月弯刀}] <> nil) and (m_HeroMagic[25].btKey
              = 0) and
              (HeroGetWideCount > 0) then
            begin
              btAttack := 5;
              if (m_HeroMagic[41 {狮子吼}] <> nil) and (m_HeroMagic[41].btKey
                = 0) and (Random(10) = 1) then
              begin
                UserMagic := Self.GetMagicInfoEx(41);
                if UserMagic <> nil then
                begin
                  btAttack := 255;
                end;
              end;
            end
            else
            begin
              case g_Config.nHeroWarrDefaultMagic of
                1: if (m_HeroMagic[12] <> nil) and (m_HeroMagic[12].btKey = 0)
                  and (btAttack = 0) then
                    btAttack := 4; //刺杀剑术
                2: if (m_HeroMagic[25] <> nil) and (m_HeroMagic[25].btKey = 0)
                  and (btAttack = 0) then
                    btAttack := 5; //半月弯刀
              end;
            end;
            if btAttack = 255 then
              DoSpell(UserMagic, m_nCurrX, m_nCurrY, nil)
            else
              AttackDir(nil, btAttack, btDir);
          end;
          Result := True;
          if Random(70) = 0 then
            Result := False;
        end else
        begin
           if (not m_boFireHitSkill) and (m_HeroMagic[12] <> nil) and
             (m_UseItems[U_WEAPON].Dura > 0) and (m_HeroMagic[12].btKey = 0) and //刺杀剑术
            (((m_TargetCret.m_nCurrX = m_nCurrX) and (abs(m_TargetCret.m_nCurrY- m_nCurrY) <= 2)) or
            ((m_TargetCret.m_nCurrY = m_nCurrY) and (abs(m_TargetCret.m_nCurrX -m_nCurrX) <= 2)) or
            ((abs(m_TargetCret.m_nCurrY - m_nCurrY) = 2) and (abs(m_TargetCret.m_nCurrX - m_nCurrX) = 2))) then
               begin
                if (Integer(GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime) then
                 begin
                       m_dwAttackTick := GetTickCount;
                       btAttack := 4;
                       btDir := GetNextDirection(m_nCurrX, m_nCurrY, m_TargetCret.m_nCurrX,m_TargetCret.m_nCurrY);
                       AttackDir(nil, btAttack, btDir);
                       m_dwHitTick := GetTickCount();
                       m_dwTargetFocusTick := GetTickCount();
                  end;
                Result := True;
               end;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.HeroWarrAttackTarget');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroWarrAttackTarget');
  end;
end;

//法师英雄攻击处理

function TPlayObject.HeroWizardAttackTarget(): Boolean; //004A8E54
var
  //  btDir:Byte;
  n14: Integer;
  UserMagic: pTUserMagic;
  MySideCount: Integer;
  AttackSideCount: Integer;
  boMove: Boolean;
  //  nX,nY:Integer;
    //BaseObjectList   :TList;
begin
  try
    Result := False;
    try
      if m_TargetCret <> nil then
      begin
        if (abs(m_nCurrX - m_TargetCret.m_nCurrX) < g_Config.nMagicAttackRage)
          and
          (abs(m_nCurrY - m_TargetCret.m_nCurrY) < g_Config.nMagicAttackRage)
          and
          (m_TargetCret.m_PEnvir = m_PEnvir) then
        begin //006329
          boMove := True;
          if ((GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime) then
          begin
            m_dwAttackTick := GetTickCount;
            if (m_WAbil.MP > 30) and (m_WAbil.HP>m_HeroMinHPTail)
              then
            begin //006279
              MySideCount := GetMapBaseObjectCount(m_PEnvir, m_nCurrX, m_nCurrY,
                1);
              AttackSideCount := GetMapBaseObjectCount(m_TargetCret.m_PEnvir,
                m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY, 1);
              UserMagic := nil;
              if (m_HeroMagic[46 {分身术}] <> nil) and (m_HeroMagic[46].btKey
                = 0) and
                (m_Clone = nil) and
                ((GetTickCount - m_CallCloneTick) > g_Config.nCallCloneTime)
                  then
              begin
                UserMagic := GetMagicInfoEx(46);
              end
              else if (not m_boOpenShield) and
                (m_HeroMagic[SKILL_75 {护体神盾}] <> nil) and
                (m_HeroMagic[SKILL_75].btKey = 0) and
                ((GetTickCount - m_dwOpenShieldTick) > g_Config.nShieldTick) and
                (Random(3) = 0) then
              begin
                UserMagic := GetMagicInfoEx(SKILL_75);
              end
              else if (m_HeroMagic[31 {魔法盾}] <> nil) and
                (m_HeroMagic[31].btKey = 0) and
                (m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] = 0) then
              begin
                UserMagic := GetMagicInfoEx(31);
              end
              else if (m_HeroMagic[SKILL_57 {四级魔法盾}] <> nil) and
                (m_HeroMagic[SKILL_57 {四级魔法盾}].btKey = 0) and
                (m_wStatusTimeArr[STATE_MAGIC57] = 0) then
              begin
                UserMagic := GetMagicInfoEx(SKILL_57 {四级魔法盾});
              end
              else if (m_HeroMagic[8] {抗拒火环} <> nil) and
                (m_HeroMagic[8].btKey = 0) and
                (m_Abil.Level > m_TargetCret.m_Abil.Level) and
                (MySideCount > 0) and
                (Random(3) = 0) then
              begin
                UserMagic := GetMagicInfoEx(8);
              end
              else if (m_HeroMagic[24] {地狱雷光} <> nil) and
                (m_HeroMagic[24].btKey = 0) and
                (MySideCount > 4) and
                (Random(3) = 0) then
              begin
                UserMagic := GetMagicInfoEx(24);
              end
              else if (m_HeroMagic[47] {火龙烈焰} <> nil) and
                (m_HeroMagic[47].btKey = 0) and
                (AttackSideCount > 1) and
                (Random(3) = 0) then
              begin
                UserMagic := GetMagicInfoEx(47);
              end
              else if (m_HeroMagic[33] {冰咆哮} <> nil) and
                (m_HeroMagic[33].btKey = 0) and
                (AttackSideCount > 1) and
                (Random(3) = 0) then
              begin
                UserMagic := GetMagicInfoEx(33);
              end
              else if (m_HeroMagic[23] {爆裂火焰} <> nil) and
                (m_HeroMagic[23].btKey = 0) and
                (AttackSideCount > 1) and
                (Random(3) = 0) then
              begin
                UserMagic := GetMagicInfoEx(23);
              end
              else if (m_HeroMagic[45] {灭天火} <> nil) and
                (m_HeroMagic[45].btKey = 0) and
                ((Random(2) = 0) or (m_HeroMagic[11] = nil)) then
              begin
                UserMagic := GetMagicInfoEx(45);
              end
              else if (m_HeroMagic[SKILL_74] {流星火雨} <> nil) and
                (m_HeroMagic[SKILL_74].btKey = 0) and
               ((GetTickCount - m_MeteorRainTime) > g_Config.nMeteorRainPower) and
                (Random(2) = 0) and (AttackSideCount > 1) then
              begin
                UserMagic := GetMagicInfoEx(SKILL_74);
              end
              else if (m_HeroMagic[11] {雷电术} <> nil) and
                (m_HeroMagic[11].btKey = 0) then
              begin
                UserMagic := GetMagicInfoEx(11);
              end
              else if (m_HeroMagic[1] {火球术} <> nil) and
                (m_HeroMagic[1].btKey = 0) then
              begin
                UserMagic := GetMagicInfoEx(1);
              end;
              if UserMagic <> nil then
              begin
                DoSpell(UserMagic, m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY,
                  m_TargetCret);
                boMove := False;
              end;
            end; //006279
          end; //Jason 1210更改
          if boMove and ((GetTickCount - m_dwRunMagicIntervalTime) >
            g_Config.nRunMagTick) then
          begin
            m_dwRunMagicIntervalTime := GetTickCount;
            if (abs(m_nCurrX - m_TargetCret.m_nCurrX) < 3) and
              (abs(m_nCurrY - m_TargetCret.m_nCurrY) < 3) then
            begin
              if (m_PEnvir = m_HeroHuman.m_PEnvir) and
                ((abs(m_nCurrX - m_HeroHuman.m_nCurrX) >
                (g_Config.nMagicAttackRage - 2)) or
                (abs(m_nCurrY - m_HeroHuman.m_nCurrY) >
                (g_Config.nMagicAttackRage - 2))) then
              begin
                n14 := GetNextDirection(m_nCurrX, m_nCurrY,
                  m_HeroHuman.m_nCurrX, m_HeroHuman.m_nCurrY);
                m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n14, 5, m_nTargetX,
                  m_nTargetY);
              end
              else
              begin
                n14 := GetNextDirection(m_TargetCret.m_nCurrX,
                  m_TargetCret.m_nCurrY, m_nCurrX, m_nCurrY);
                m_PEnvir.GetNextPosition(m_TargetCret.m_nCurrX,
                  m_TargetCret.m_nCurrY, n14, 5, m_nTargetX, m_nTargetY);
              end;
              //SetTargetXY(nX,nY);
              //self.SysMsg(format('%d/%d',[m_nTargetX,m_nTargetY]),c_Red,t_Hint,True);
              if (m_nTargetX > 0) and (m_nTargetY > 0) then
              begin
                HeroTail;
              end;
              SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
            end;
          end;
          Result := True;
          {   end else begin
               if (m_TargetCret2.m_PEnvir = m_PEnvir) then begin
                 SetTargetXY(m_TargetCret2.m_nCurrX,m_TargetCret2.m_nCurrY);
               end else begin
                 DelTargetCreat();
               end; }
        end; //006329
      end
      else if m_HeroAutoDong then
      begin
        if (GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime then
        begin
          m_dwAttackTick := GetTickCount;
          //      UserMagic:=Nil;
          if (m_HeroMagic[31 {魔法盾}] <> nil) and (m_HeroMagic[31].btKey = 0)
            and
            (m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP] = 0) then
          begin
            UserMagic := GetMagicInfoEx(31);
            DoSpell(UserMagic, m_nCurrX, m_nCurrY, nil);
            Result := True;
          end;
          if (m_HeroMagic[SKILL_57 {四级魔法盾}] <> nil) and (m_HeroMagic[SKILL_57].btKey = 0)
            and (m_wStatusTimeArr[STATE_MAGIC57] = 0) then
          begin
            UserMagic := GetMagicInfoEx(SKILL_57);
            DoSpell(UserMagic, m_nCurrX, m_nCurrY, nil);
            Result := True;
          end;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.HeroWizardAttackTarget');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroWizardAttackTarget');
  end;
end;

//道士英雄攻击处理

function TPlayObject.HeroTaosAttackTarget(): Boolean; //004A8E54
var
  btDir: Byte;
  //  boSet:Boolean;
  UserMagic: pTUserMagic;
  nCheckCode: Integer;
  TargeTBaseObject: TBaseObject;
  TargeX, TargeY: Integer;
  MySideCount, AttackSideCount: Integer;
  n14: Byte;
  boMove: Boolean;

  procedure RefTaosCorpsItem();
  var
    DruaCount: Integer;
    AmuletStdItem: TItem;
    I: Integer;
    UserItem: pTUserItem;
    StdItem: TItem;
    nCode: Integer;
  begin
    nCode := 0;
    try
      m_HeroAmu51Porc := nil;
      m_HeroAmu55Porc := nil;
      m_HeroAmu11Porc := nil;
      m_HeroAmu21Porc := nil;
      m_HeroAttackAmuPorc := nil;
      nCode := 1;
      if m_Abil.Level > 13 then
      begin
        for I := 0 to m_ItemList.Count - 1 do
        begin
          nCode := 2;
          UserItem := m_ItemList.Items[I];
          nCode := 3;
          if (UserItem <> nil) then
          begin
            nCode := 4;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            nCode := 5;
            if StdItem.StdMode = 25 then
            begin
              DruaCount := ROUND(UserItem.Dura / 100);
              case StdItem.Shape of
                5:
                  begin //护身符
                    if DruaCount > 0 then
                      m_HeroAmu51Porc := UserItem;
                    if DruaCount > 4 then
                      m_HeroAmu55Porc := UserItem;
                  end;
                1:
                  begin //灰色药粉
                    if DruaCount > 0 then
                      m_HeroAmu11Porc := UserItem;
                  end;
                2:
                  begin //黄色药粉
                    if DruaCount > 0 then
                      m_HeroAmu21Porc := UserItem;
                  end;
              end;
            end;
          end;
        end;
        nCode := 6;
        if m_UseItems[U_ARMRINGL].wIndex > 0 then
        begin
          nCode := 7;
          AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_ARMRINGL].wIndex);
          nCode := 8;
          if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 25) then
          begin
            nCode := 9;
            DruaCount := ROUND(m_UseItems[U_ARMRINGL].Dura / 100);
            case AmuletStdItem.Shape of
              5:
                begin //护身符
                  if DruaCount > 0 then
                    m_HeroAmu51Porc := @m_UseItems[U_ARMRINGL];
                  if DruaCount > 4 then
                    m_HeroAmu55Porc := @m_UseItems[U_ARMRINGL];
                end;
              1:
                begin //灰色药粉
                  if DruaCount > 0 then
                    m_HeroAmu11Porc := @m_UseItems[U_ARMRINGL];
                end;
              2:
                begin //黄色药粉
                  if DruaCount > 0 then
                    m_HeroAmu21Porc := @m_UseItems[U_ARMRINGL];
                end;
            end;
          end;
        end;
        nCode := 10;
        if m_UseItems[U_BUJUK].wIndex > 0 then
        begin
          nCode := 11;
          AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
          nCode := 12;
          if (AmuletStdItem <> nil) and (AmuletStdItem.StdMode = 25) then
          begin
            nCode := 13;
            DruaCount := ROUND(m_UseItems[U_BUJUK].Dura / 100);
            case AmuletStdItem.Shape of
              5:
                begin //护身符
                  if DruaCount > 0 then
                    m_HeroAmu51Porc := @m_UseItems[U_BUJUK];
                  if DruaCount > 4 then
                    m_HeroAmu55Porc := @m_UseItems[U_BUJUK];
                end;
              1:
                begin //灰色药粉
                  if DruaCount > 0 then
                    m_HeroAmu11Porc := @m_UseItems[U_BUJUK];
                end;
              2:
                begin //黄色药粉
                  if DruaCount > 0 then
                    m_HeroAmu21Porc := @m_UseItems[U_BUJUK];
                end;
            end;
          end;
        end;
        nCode := 14;
        if (m_HeroAmu51Porc = nil) or
          (m_HeroAmu11Porc = nil) or
          (m_HeroAmu21Porc = nil) then
        begin
          nCode := 15;
          if (GetTickCount - m_HeroAmuHintTime) > 10000 then
          begin
            nCode := 16;
            m_HeroAmuHintTime := GetTickCount;
            if (m_Abil.Level > 17) and (m_HeroAmu51Porc = nil) then
            begin
              SysMsg('(护身符)已经用完！！！', c_Blue, t_Hint);
            end;
            nCode := 17;
            if m_Abil.Level > 13 then
            begin
              if m_HeroAmu11Porc = nil then
                SysMsg('(灰色药粉)已经用完！！！', c_Blue, t_Hint);
              if m_HeroAmu21Porc = nil then
                SysMsg('(黄色药粉)已经用完！！！', c_Blue, t_Hint);
            end;
          end;
        end;

      end;
    except
      MainOutMessage('[Exception] RefTaosCorpsItem Code=' + IntToStr(nCode));
    end;
  end;

  procedure CheckAttack(btBy: Byte);
  begin
    if (TargeTBaseObject = nil) or (UserMagic <> nil) then
      exit;
    if (m_HeroAutoDong) then
    begin
      if (m_SlaveList.Count < g_Config.nFairyCount) and
        (m_HeroMagic[72 {召唤月灵}] <> nil) and (m_HeroMagic[72].btKey = 0)
        and
        (m_HeroHuman.m_HeroCallMob in [2, 32, 42, 52, 62]) and
        (m_HeroAmu55Porc <> nil) then
      begin
        UserMagic := GetMagicInfoEx(72);
      end
      else if (m_SlaveList.Count < g_Config.nDragonCount) and
        (m_HeroMagic[30 {召唤神兽}] <> nil) and (m_HeroMagic[30].btKey = 0)
        and
        (m_HeroHuman.m_HeroCallMob in [1, 21, 31, 52, 62]) and
        (m_HeroAmu55Porc <> nil) then
      begin
        UserMagic := GetMagicInfoEx(30);
      end
      else if (m_SlaveList.Count < g_Config.nSkeletonCount) and
        (m_HeroMagic[17 {召唤骷髅}] <> nil) and (m_HeroMagic[17].btKey = 0)
        and
        (m_HeroHuman.m_HeroCallMob in [0, 10, 31, 42, 62]) and
        (m_HeroAmu51Porc <> nil) then
      begin
        UserMagic := GetMagicInfoEx(17);
      end;
    end;
    if (UserMagic <> nil) then
      exit;
    if (not m_boOpenShield) and
      (m_HeroMagic[SKILL_75 {护体神盾}] <> nil) and
      (m_HeroMagic[SKILL_75].btKey = 0) and
      ((GetTickCount - m_dwOpenShieldTick) > g_Config.nShieldTick) and
      (Random(3) = 0) then
    begin
      UserMagic := GetMagicInfoEx(SKILL_75);
    end
    else if (m_HeroMagic[34 {解毒术}] <> nil) and (m_HeroMagic[34].btKey = 0)
      and
      ((TargeTBaseObject.m_wStatusTimeArr[POISON_DECHEALTH] <> 0) or
      (TargeTBaseObject.m_wStatusTimeArr[POISON_DAMAGEARMOR] <> 0) or
      (TargeTBaseObject.m_wStatusTimeArr[POISON_STONE] <> 0)) and
      (Random(btBy) = 0) then
    begin
      UserMagic := GetMagicInfoEx(34);
    end
    else if (m_HeroMagic[2 {治愈术}] <> nil) and (m_HeroMagic[2].btKey = 0)
      and
      (TargeTBaseObject.m_WAbil.HP < TargeTBaseObject.m_WAbil.MaxHP) and
      (Random(btBy) = 0) then
    begin
      UserMagic := GetMagicInfoEx(2);
    end
    else if (m_HeroMagic[52 {诅咒术}] <> nil) and (m_HeroMagic[52].btKey = 0)
      and
      (TargeTBaseObject.m_wStatusTimeArr[STATE_ARRAYDC] = 0) and
      (TargeTBaseObject.m_wStatusTimeArr[STATE_ARRAYMC] = 0) and
      (TargeTBaseObject.m_wStatusTimeArr[STATE_ARRAYSC] = 0) and
      (m_HeroAmu51Porc <> nil) then
    begin
      UserMagic := GetMagicInfoEx(52);
    end
    else if (m_HeroMagic[15 {神圣战甲术}] <> nil) and (m_HeroMagic[15].btKey
      = 0) and
      (TargeTBaseObject.m_wStatusTimeArr[STATE_DEFENCEUP] = 0) and
      (m_HeroAmu51Porc <> nil) then
    begin
      UserMagic := GetMagicInfoEx(15);
    end
    else if (m_HeroMagic[14 {幽灵盾}] <> nil) and (m_HeroMagic[14].btKey = 0)
      and
      (TargeTBaseObject.m_wStatusTimeArr[STATE_MAGDEFENCEUP] = 0) and
      (m_HeroAmu51Porc <> nil) then
    begin
      UserMagic := GetMagicInfoEx(14);
    end;
  end;

  procedure ProtectHuman(btBy: Byte);
  begin
    if (m_HeroHuman = nil) or (UserMagic <> nil) then
      exit;
    TargeTBaseObject := m_HeroHuman;
    TargeX := m_HeroHuman.m_nCurrX;
    TargeY := m_HeroHuman.m_nCurrY;
    CheckAttack(btBy);
  end;

  procedure ProtectSelf(btBy: Byte);
  begin
    if UserMagic <> nil then
      exit;
    TargeTBaseObject := Self;
    TargeX := m_nCurrX;
    TargeY := m_nCurrY;
    CheckAttack(btBy);
  end;

  procedure AttackMonster(btBy: Byte);
  begin
    if (UserMagic <> nil) or (m_TargetCret = nil) then
      exit;
    TargeTBaseObject := m_TargetCret;
    TargeX := m_TargetCret.m_nCurrX;
    TargeY := m_TargetCret.m_nCurrY;
    if (m_HeroMagic[50 {无极真气}] <> nil) and (m_HeroMagic[50].btKey = 0)
      and
      (m_wStatusArrValue[STATE_SC] = 0) and
      (Random(btBy) = 0) then
    begin
      UserMagic := GetMagicInfoEx(50);
    end
    else if (m_HeroMagic[SKILL_53 {噬血术}] <> nil) and
      (m_HeroMagic[SKILL_53].btKey = 0) and (m_HeroAmu51Porc <> nil) and
      (Random(5) = 0) then
    begin
      UserMagic := GetMagicInfoEx(SKILL_53);
    end
    else if (m_HeroMagic[SKILL_ENERGYREPULSOR] {气功波} <> nil) and
      (m_HeroMagic[SKILL_ENERGYREPULSOR].btKey = 0) and
      (m_Abil.Level > m_TargetCret.m_Abil.Level) and
      (MySideCount > 0) and
      (Random(btBy) = 0) then
    begin
      UserMagic := GetMagicInfoEx(SKILL_ENERGYREPULSOR);
    end
    else if (m_HeroMagic[38 {群体施毒术}] <> nil) and (m_HeroMagic[38].btKey
      = 0) and
      (TargeTBaseObject.m_wStatusTimeArr[POISON_DAMAGEARMOR] = 0) and
      (m_HeroAmu21Porc <> nil) and
      (AttackSideCount > 1) and
      (Random(5) <> 0) then
    begin
      m_HeroAttackAmuPorc := m_HeroAmu21Porc;
      UserMagic := GetMagicInfoEx(38);
    end
    else if (m_HeroMagic[38 {群体施毒术}] <> nil) and (m_HeroMagic[38].btKey
      = 0) and
      (TargeTBaseObject.m_wStatusTimeArr[POISON_DECHEALTH] = 0) and
      (m_HeroAmu11Porc <> nil) and
      (AttackSideCount > 1) and
      (Random(5) <> 0) then
    begin
      m_HeroAttackAmuPorc := m_HeroAmu11Porc;
      UserMagic := GetMagicInfoEx(38);
    end
    else if (m_HeroMagic[6 {施毒术}] <> nil) and (m_HeroMagic[6].btKey = 0)
      and
      (TargeTBaseObject.m_wStatusTimeArr[POISON_DECHEALTH] = 0) and
      (m_HeroAmu11Porc <> nil) and
      (Random(5) <> 0) then
    begin
      m_HeroAttackAmuPorc := m_HeroAmu11Porc;
      UserMagic := GetMagicInfoEx(6);
    end
    else if (m_HeroMagic[6 {施毒术}] <> nil) and (m_HeroMagic[6].btKey = 0)
      and
      (TargeTBaseObject.m_wStatusTimeArr[POISON_DAMAGEARMOR] = 0) and
      (m_HeroAmu21Porc <> nil) and
      (Random(5) <> 0) then
    begin
      m_HeroAttackAmuPorc := m_HeroAmu21Porc;
      UserMagic := GetMagicInfoEx(6);
    end
    else if (m_HeroMagic[18 {隐身术}] <> nil) and (m_HeroMagic[18].btKey = 0)
      and
      (m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] = 0) and
      (m_HeroAmu51Porc <> nil) and
      (MySideCount > 0) and
      (Random(btBy) = 0) and
      (not TargeTBaseObject.m_boCoolEye) and
      (TargeTBaseObject.m_btRaceServer <> RC_PLAYOBJECT) then
    begin
      UserMagic := GetMagicInfoEx(18);
    end
    else if (m_HeroMagic[13 {灵魂火符}] <> nil) and (m_HeroMagic[13].btKey =
      0) and
      (m_HeroAmu51Porc <> nil) and
      (Random(5) <> 0) then
    begin
      UserMagic := GetMagicInfoEx(13);
    end;
  end;

  procedure ProtectSlave(btBy: Byte);
  var
    SlaveObject: TBaseObject;
    //    I          :Integer;
  begin
    if UserMagic <> nil then
      exit;
    //    SlaveObject:=Nil;
    if (Random(2) = 0) or (m_HeroHuman.m_SlaveList.Count = 0) then
    begin
      if m_SlaveList.Count <= 0 then
        exit;
      SlaveObject := m_SlaveList.Items[Random(m_SlaveList.Count)];
      if (SlaveObject <> nil) and
        (abs(m_nCurrX - SlaveObject.m_nCurrX) < g_Config.nMagicAttackRage) and
        (abs(m_nCurrY - SlaveObject.m_nCurrY) < g_Config.nMagicAttackRage) then
      begin
        TargeTBaseObject := SlaveObject;
        TargeX := SlaveObject.m_nCurrX;
        TargeY := SlaveObject.m_nCurrY;
        CheckAttack(btBy);
      end;
    end
    else
    begin
      if m_HeroHuman.m_SlaveList.Count <= 0 then
        exit;
      SlaveObject :=
        m_HeroHuman.m_SlaveList.Items[Random(m_HeroHuman.m_SlaveList.Count)];
      if (SlaveObject <> nil) and
        (abs(m_nCurrX - SlaveObject.m_nCurrX) < g_Config.nMagicAttackRage) and
        (abs(m_nCurrY - SlaveObject.m_nCurrY) < g_Config.nMagicAttackRage) then
      begin
        TargeTBaseObject := SlaveObject;
        TargeX := SlaveObject.m_nCurrX;
        TargeY := SlaveObject.m_nCurrY;
        CheckAttack(btBy);
      end;
    end;
  end;

begin
  try
    Result := False;
    // boSet:=True;
    UserMagic := nil;
    nCheckCode := 0;
    //  boMove:=False;
    try
      if m_TargetCret <> nil then
      begin
        nCheckCode := 1;
        if (abs(m_nCurrX - m_TargetCret.m_nCurrX) < g_Config.nMagicAttackRage)
          and
          (abs(m_nCurrY - m_TargetCret.m_nCurrY) < g_Config.nMagicAttackRage)
            then
        begin
          boMove := True;
          if (GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime then
          begin
            m_dwAttackTick := GetTickCount;
            RefTaosCorpsItem; //符毒等
            if (m_WAbil.MP > 15) then
              ProtectSelf(15);
            if (m_WAbil.HP>m_HeroMinHPTail) then
            begin
              MySideCount := GetMapBaseObjectCount(m_PEnvir, m_nCurrX, m_nCurrY,
                2);
              AttackSideCount := GetMapBaseObjectCount(m_TargetCret.m_PEnvir,
                m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY, 1);
              AttackMonster(3);
              if (UserMagic = nil) and
                (m_HeroHuman <> nil) and
                (abs(m_nCurrX - m_HeroHuman.m_nCurrX) <
                g_Config.nMagicAttackRage) and
                (abs(m_nCurrY - m_HeroHuman.m_nCurrY) <
                g_Config.nMagicAttackRage) then
              begin
                ProtectHuman(6);
                ProtectSlave(3);
              end;
            end;
            nCheckCode := 3;
            if UserMagic <> nil then
            begin
              nCheckCode := 4;
              boMove := False;
              DoSpell(UserMagic, TargeX, TargeY, TargeTBaseObject);
              m_dwAttackTick := GetTickCount;
            end
            else if (m_HeroMagic[13 {灵魂火符}] = nil) then
            begin
              nCheckCode := 5;
              if GetAttackDir(m_TargetCret, btDir) then
              begin
                nCheckCode := 6;
                //boSet:=False;
                nCheckCode := 7;
                AttackDir(nil, 0, btDir);
                m_dwAttackTick := GetTickCount;
                nCheckCode := 8;
                boMove := False;
              end;
            end;
          end;
          if (boMove) and (m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] = 0) and
            ((GetTickCount - m_dwRunMagicIntervalTime) > g_Config.nRunMagTick)
              then
          begin
            m_dwRunMagicIntervalTime := GetTickCount;
            if (abs(m_nCurrX - m_TargetCret.m_nCurrX) < 3) and
              (abs(m_nCurrY - m_TargetCret.m_nCurrY) < 3) then
            begin
              if (m_PEnvir = m_HeroHuman.m_PEnvir) and
                ((abs(m_nCurrX - m_HeroHuman.m_nCurrX) >
                (g_Config.nMagicAttackRage - 2)) or
                (abs(m_nCurrY - m_HeroHuman.m_nCurrY) >
                (g_Config.nMagicAttackRage - 2))) then
              begin
                n14 := GetNextDirection(m_nCurrX, m_nCurrY,
                  m_HeroHuman.m_nCurrX, m_HeroHuman.m_nCurrY);
                m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n14, 5, m_nTargetX,
                  m_nTargetY);
              end
              else
              begin
                n14 := GetNextDirection(m_TargetCret.m_nCurrX,
                  m_TargetCret.m_nCurrY, m_nCurrX, m_nCurrY);
                m_PEnvir.GetNextPosition(m_TargetCret.m_nCurrX,
                  m_TargetCret.m_nCurrY, n14, 5, m_nTargetX, m_nTargetY);
              end;
              if (m_nTargetX > 0) and (m_nTargetY > 0) then
              begin
                HeroTail;
              end;
              SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
            end;
          end;
          Result := True;
        end; //if (abs(m_nCurrX - m_TargetCret.m_nCurrX) < g_Config.nMagicAttackRage) and
        if m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] <> 0 then
          Result := True;
      end
      else if (m_HeroHuman <> nil) and
        ((abs(m_nCurrX - m_HeroHuman.m_nCurrX) < 3) or (abs(m_nCurrY -
        m_HeroHuman.m_nCurrY) < 3)) and
        (m_HeroHuman.m_PEnvir = m_PEnvir) then
      begin
        nCheckCode := 20;
        if (GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime then
        begin
          m_dwAttackTick := GetTickCount;
          nCheckCode := 21;
          if m_WAbil.MP > 15 then
          begin
            nCheckCode := 22;
            RefTaosCorpsItem;
            nCheckCode := 23;
            ProtectHuman(3);
            nCheckCode := 24;
            ProtectSelf(3);
            nCheckCode := 25;
            if (m_SlaveList.Count > 0) or (m_HeroHuman.m_SlaveList.Count > 0)
              then
              ProtectSlave(3);
            if UserMagic <> nil then
            begin
              Result := True;
              nCheckCode := 26;
              DoSpell(UserMagic, TargeX, TargeY, TargeTBaseObject);
            end;
          end;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.HeroTaosAttackTarget nCode ' +
        IntToStr(nCheckCode));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroTaosAttackTarget');
  end;
end;

function TPlayObject.HeroBasicAttackTarget(): Boolean; //004A8E54
var
  btDir: Byte;
begin
  try
    try
      Result := False;
      if m_TargetCret <> nil then
      begin
        if GetAttackDir(m_TargetCret, btDir) then
        begin
          if (GetTickCount - m_dwAttackTick) > m_dwHitIntervalTime then
          begin
            m_dwAttackTick := GetTickCount;
            AttackDir(nil, 0, btDir);
          end;
          Result := True;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.HeroBasicAttackTarget');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroBasicAttackTarget');
  end;
end;

function TPlayObject.HeroAttackTarget(): Boolean; //004A8E54
begin
  try
    Result := False;
    try
      if m_TargetCret <> nil then
      begin
        if m_Abil.Level > 6 then
        begin
          case m_btJob of
            Job_Warr: Result := HeroWarrAttackTarget;
            JOB_WIZARD: Result := HeroWizardAttackTarget;
            JOB_TAOS: Result := HeroTaosAttackTarget;
          else
            exit;
          end
        end
        else
          Result := HeroBasicAttackTarget;
        if (not Result) and (m_TargetCret <> nil) then
        begin
          if m_TargetCret.m_PEnvir = m_PEnvir then
          begin
            SetTargetXY(m_TargetCret.m_nCurrX, m_TargetCret.m_nCurrY);
          end
          else
          begin
            DelTargetCreat();
          end;
        end;
      end
      else if m_HeroAutoDong then
      begin
        case m_btJob of
          JOB_WIZARD:
            begin
              Result := HeroWizardAttackTarget;
            end;
          JOB_TAOS:
            begin
              Result := HeroTaosAttackTarget;
            end;
        end;
      end
      else if m_btJob = JOB_TAOS then
        Result := HeroTaosAttackTarget;
    except
      MainOutMessage('[Exception] TPlayObject.HeroAttackTarget')
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroAttackTarget');
  end;
end;

procedure TPlayObject.HeroCallMob(nClass, nFairy, nDogz, BoneFamm: Byte);
begin
  if m_Hero = nil then
    exit;
  if m_Hero.m_btJob <> JOB_TAOS then
    exit;

  if nClass = 99 then
  begin
    if (nFairy <> 0) or (nDogz <> 0) or (BoneFamm <> 0) then
    begin
      m_HeroCallMob := 0;
      if not m_HeroAutoDong then
      begin
        m_HeroAutoDong := True;
        SysMsg(sHeroOnMakeSlave, c_Blue, t_Hint);
      end;
      if nDogz = 1 then
        m_HeroCallMob := 1;
      if nFairy = 1 then
        m_HeroCallMob := 2;
      if BoneFamm = 1 then
        Inc(m_HeroCallMob, 10);
      if nDogz = 1 then
        Inc(m_HeroCallMob, 20);
      if nFairy = 1 then
        inc(m_HeroCallMob, 30);
    end
    else
    begin
      if m_HeroAutoDong then
      begin
        m_HeroAutoDong := False;
        SysMsg(sHeroOffMakeSlave, c_Blue, t_Hint);
      end;
    end;
  end
  else
    m_HeroCallMob := nClass;
  //MainOutMessage(Format('%d/%d/%d/%d',[nClass,nFairy,nDogz,BoneFamm]));
end;

procedure TPlayObject.HeroFunction(nJob: Byte; noff: Byte);
var
  sMsg: string;
begin
  try
    sMsg := '';
    if m_Hero = nil then
      exit;
    if noff = 1 then
      m_HeroAutoDong := True
    else
      m_HeroAutoDong := False;
    if m_Hero.m_btJob = JOB_WIZARD then
    begin
      if m_HeroAutoDong then
        sMsg := sHeroOnMakeDong
      else
        sMsg := sHeroOffMakeDong;
    end
    else if m_Hero.m_btJob = JOB_TAOS then
    begin
      if m_HeroAutoDong then
        sMsg := sHeroOnMakeSlave
      else
        sMsg := sHeroOffMakeSlave;
    end;
    if sMsg <> '' then
      SysMsg(sMsg, c_Blue, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.HeroFunction');
  end;
end;

//取英雄合击代码

function TPlayObject.HeroGetMagicCode(nJob, mJob: Byte): Byte;
begin
  try
    Result := 0;
    if (nJob = Job_Warr) and (mJob = Job_Warr) then
    begin
      Result := SKILL_60;
    end
    else if (nJob = JOB_WIZARD) and (mJob = JOB_WIZARD) then
    begin
      Result := SKILL_65;
    end
    else if (nJob = JOB_TAOS) and (mJob = JOB_TAOS) then
    begin
      Result := SKILL_63;
    end
    else if ((nJob = Job_Warr) and (mJob = JOB_TAOS)) or
      ((nJob = JOB_TAOS) and (mJob = Job_Warr)) then
    begin
      Result := SKILL_61;
    end
    else if ((nJob = Job_Warr) and (mJob = JOB_WIZARD)) or
      ((nJob = JOB_WIZARD) and (mJob = Job_Warr)) then
    begin
      Result := SKILL_62;
    end
    else if ((nJob = JOB_TAOS) and (mJob = JOB_WIZARD)) or
      ((nJob = JOB_WIZARD) and (mJob = JOB_TAOS)) then
    begin
      Result := SKILL_64;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroGetMagicCode');
  end;
end;

procedure TPlayObject.HeroChangeGlory(nPoint: Word; nMode: Byte);
var
  oPoint: Integer;
begin
  if m_boHero then
  begin
    oPoint := m_nGloryPoint;
    case nMode of
      0: Inc(m_nGloryPoint, _MIN(nPoint, 10000 - m_nGloryPoint));
      1: Dec(m_nGloryPoint, _MIN(m_nGloryPoint, nPoint));
      2: m_nGloryPoint := nPoint;
    end;
    if oPoint = m_nGloryPoint then
      exit;
    SendUpdateMsg(Self, RM_HEROCHANGEGLORY, 0, 0, 0, 0, '');
    m_boHeroFourMagic := (m_nGloryPoint >= g_Config.nHeroFourMagic);
    if ((oPoint < g_Config.nHeroFourMagic) and (m_nGloryPoint >=
      g_Config.nHeroFourMagic)) or
      ((oPoint >= g_Config.nHeroFourMagic) and (m_nGloryPoint <
      g_Config.nHeroFourMagic)) then
    begin
      RecalcHitSpeed;
    end;
  end;
end;

//英雄合击处理

procedure TPlayObject.HeroAllowJointAttac();
var
  AttackHuman: TBaseObject;
begin
  try
    AttackHuman := m_HeroLocked;
    if (AttackHuman = nil) and
      (m_HeroHuman <> nil) and
      (m_TargetCret <> nil) then
    begin
      AttackHuman := m_TargetCret;
    end;
    if (m_HeroHuman <> nil) and
      (m_HeroHuman.m_wStatusTimeArr[POISON_STONE] = 0) and
      (not m_HeroHuman.m_boOnHorse) and
      (m_wStatusTimeArr[POISON_STONE] = 0) and
      (g_Config.boAllowJointAttack) and
      (m_HeroDanderOk) and
      (not m_HeroHuman.m_boGhost) and
      (not m_HeroHuman.m_boDeath) and
      (not m_boGhost) and
      (not m_boDeath) and
      (m_HeroJointAttack <> nil) and
      (AttackHuman <> nil) and
      (not AttackHuman.m_boDeath) and
      (not AttackHuman.m_boGhost) then
    begin
      //m_HeroboDanderDel:=True;
      if DoSpell(m_HeroJointAttack, AttackHuman.m_nCurrX, AttackHuman.m_nCurrY,
        AttackHuman) then
      begin
        m_HeroboDanderDel := False;
        m_HeroDanderOk := False;
        m_HeroDanderCount := 0;
        m_HeroHuman.SendUpdateMsg(Self, RM_DANDERCHANG, 0, m_HeroDanderCount,
          g_Config.nHeroMaxDanderCount, 0, '');
        m_dwMoveTick := GetTickCount + m_dwRunIntervalTime;
        m_dwAttackTick := GetTickCount + m_dwHitIntervalTime;
        m_dwRunMagicIntervalTime := GetTickCount + g_Config.nRunMagTick;
        m_HeroJointAttackOk := True;
        m_HeroJointAttackTime := GetTickCount;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroAllowJointAttac');
  end;
end;

procedure TPlayObject.SetPickItems(MapItem: pTVisibleMapItem);
begin
  try
    m_HeroPickItem := MapItem;
    m_HeroPickItemMap := m_PEnvir;
    //SysMsg(m_HeroPickItem.sName,c_Red,t_Hint,True);
  except
    MainOutMessage('[Exception] TPlayObject.SetPickItems');
  end;
end;

procedure TPlayObject.DelPickItems();
begin
  try
    m_HeroPickItem := nil;
    m_HeroPickItemMap := nil;
  except
    MainOutMessage('[Exception] TPlayObject.DelPickItems');
  end;
end;

function TPlayObject.HeroPickUpItems(): Boolean; //004A8E54
var
  I: Integer;
  VisibleMapItem: pTVisibleMapItem;
  StdItem: TItem;
  nCheckCode: Byte;
  //MapItem:pTMapItem;
begin
  try
    Result := False;
    nCheckCode := 0;
    try
      if (not m_boDeath) and (not m_boGhost) and (m_HeroHuman <> nil) then
      begin
        //if IsEnoughBag then begin
        nCheckCode := 1;
        //SysMsg('aaaa',c_Red,t_Hint,True);
        DelPickItems;
        for I := 0 to m_VisibleItems.Count - 1 do
        begin
          nCheckCode := 2;
          VisibleMapItem := m_VisibleItems.Items[I];
          if (VisibleMapItem = nil) or (VisibleMapItem.MapItem = nil) then
            Continue;
          if m_PEnvir.GetXYObjCount(visiblemapitem.nX, visiblemapitem.nY) > 0
            then
            Continue;
          nCheckCode := 4;
          if not IsSelf(TBaseObject(VisibleMapItem.MapItem.OfBaseObject)) and
            //not IsHero(TBaseObject(VisibleMapItem.MapItem.OfBaseObject)) and
          not
            TPlayObject(m_HeroHuman).IsOfGroup(TBaseObject(VisibleMapItem.MapItem.OfBaseObject)) then
          begin
            Continue;
          end;
          nCheckCode := 5;
          if VisibleMapItem.sName = sSTRING_GOLDNAME then
          begin
            nCheckCode := 6;
            if (g_boHeroPickGold) and ((m_HeroHuman.m_nGold +
              VisibleMapItem.MapItem.Count) < g_Config.nHumanMaxGold) then
            begin
              nCheckCode := 11;
              SetPickItems(VisibleMapItem);
              Result := True;
              exit;
            end;
          end
          else
          begin
            nCheckCode := 7;
            if IsEnoughBag then
            begin
              nCheckCode := 8;
              StdItem :=
                UserEngine.GetStdItem(VisibleMapItem.MapItem.UserItem.wIndex);
              nCheckCode := 9;
              if (StdItem <> nil) and (StdItem.HeroPick = 1) and (not StdItem.nRule[RULE_HeroBag]) then
              begin
                nCheckCode := 10;
                Result := True;
                SetPickItems(VisibleMapItem);
                exit;
              end;
            end
            else
              DelPickItems;
          end;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject->HeroPickUpItems nCode:' +
        IntToStr(nCheckCode));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroPickUpItems');
  end;
end;

function TPlayObject.Think(): Boolean;
var
  m_boDupMode: Boolean;
  nOldX, nOldy: Word;
begin
  try
    Result := False;
    m_boDupMode := False;
    if (GetTickCount - m_dwThinkTick) > 3 * 1000 then
    begin
      m_dwThinkTick := GetTickCount();
      if m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY) >= 2 then
        m_boDupMode := True;
    end; //004A8ED2
    if m_boDupMode then
    begin
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      WalkTo(Random(8), False);
      if (nOldX <> m_nCurrX) or (nOldY <> m_nCurrY) then
      begin
        Result := True;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.Think');
  end;
end;

//英雄运行

procedure TPlayObject.RunHero();
resourcestring
  sExceptionMsg1 = '[Exception] TPlayObject::RunHero -> Code=%d';
  sExceptionMsg2 =
    '[Exception] TPlayObject::RunHero -> Operate 2 # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s';
  sExceptionMsg3 = '[Exception] TPlayObject::RunHero -> GetHighHuman';
  sExceptionMsg4 = '[Exception] TPlayObject::RunHero -> ClearObj';
  sExceptionMsg5 = '[Exception] TPlayObject::RunHero -> ClearObj';
var
  ProcessMsg: TProcessMessage;
  nX, nY: Integer;
  //  btDir        :Byte;
  nCheckCode: Byte;
  StdItem: TItem;
  nCount: Integer;
begin
  try
    try
      nCheckCode := 0;
      try
        if m_PEnvir.Flag.boNOCALLHERO then
          MakeGhost();
        if (not m_boGhost) and (not m_boDeath) then
        begin
          nCheckCode := 1;
          if (m_HeroHuman = nil) or (m_HeroHuman.m_boGhost)
            { or (m_HeroHuman.m_boDeath)}then
          begin
            nCheckCode := 2;
            MakeGhost();
            nCheckCode := 3;
            exit;
          end;
          nCheckCode := 4;
          //补充怒气值开始
          //m_HeroDanderOk
          //m_HeroboDanderDel
          try
              //自动酒护护体
           if (not m_boskill84open) and (m_HeroMagic[SKILL_84] <> nil) and (m_HeroMagic[SKILL_84].btKey = 0) and (m_SKILL84Rec.SKILL84Level>0)
            and (m_WineRec.Alcoho>0) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)>=g_Config.nMinDrinkValue84) then
           begin
              DoSpell(m_HeroMagic[SKILL_84], m_nCurrX,m_nCurrY,nil);
            end;
          except

          end;
          if (g_Config.boAllowJointAttack) and ((GetTickCount -
            m_HeroAutoDanderTick) > 1000) then
          begin
            m_HeroAutoDanderTick := GetTickCount;
            //if (not m_HeroboDanderDel) or (not m_HeroDanderOk) then begin //007126
            if not m_HeroDanderOk then
            begin //007126
              //if m_HeroDanderCount<g_Config.nHeroMaxDanderCount then begin
              nCheckCode := 41;
              if (m_UseItems[U_BUJUK].wIndex > 0) and (m_UseItems[U_BUJUK].Dura
                > 0) then
              begin
                nCheckCode := 42;
                StdItem := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
                nCheckCode := 43;
                if (StdItem.StdMode = 25) and (StdItem.Shape = 9) then
                begin
                  nCheckCode := 44;
                  nCount := Trunc(g_Config.nEnergyStepUpRate / 10) * 3;
                  if (g_Config.nHeroMaxDanderCount - m_HeroDanderCount) < nCount
                    then
                    nCount := g_Config.nHeroMaxDanderCount - m_HeroDanderCount;
                  if m_UseItems[U_BUJUK].Dura < nCount then
                    nCount := m_UseItems[U_BUJUK].Dura;
                  Inc(m_HeroDanderCount, nCount);
                  Dec(m_UseItems[U_BUJUK].Dura, nCount);
                  nCheckCode := 45;
                  if m_HeroDanderCount >= g_Config.nHeroMaxDanderCount then
                  begin
                    m_HeroHuman.SendUpdateMsg(Self, RM_DANDERCHANG, 1,
                      m_HeroDanderCount, g_Config.nHeroMaxDanderCount, 0, '');
                    m_HeroDanderOk := True;
                  end
                  else
                    m_HeroHuman.SendUpdateMsg(Self, RM_DANDERCHANG, 0,
                      m_HeroDanderCount, g_Config.nHeroMaxDanderCount, 0, '');
                  if m_UseItems[U_BUJUK].Dura <= 0 then
                  begin
                    m_UseItems[U_BUJUK].Dura := 0;
                    SendDelItems(@m_UseItems[U_BUJUK]);
                    m_UseItems[U_BUJUK].wIndex := 0;
                  end
                  else
                  begin
                    SendMsg(Self, RM_DURACHANGE, U_BUJUK,
                      m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0,
                      '');
                  end;
                  nCheckCode := 46;
                end;
              end;
              //end;
            end
            else {//007126} if m_HeroboDanderDel then
            begin
              nCheckCode := 47;
              HeroAllowJointAttac;
              nCount := Trunc(g_Config.nEnergyStepUpRate / 10) * 3;
              if m_HeroDanderCount < nCount then
                m_HeroDanderCount := 0
              else
                Dec(m_HeroDanderCount, nCount);
              if m_HeroDanderCount = 0 then
              begin
                nCheckCode := 48;
                m_HeroDanderOk := False;
                m_HeroboDanderDel := False;
                m_HeroHuman.SendUpdateMsg(Self, RM_DANDERCHANG, 0,
                  m_HeroDanderCount, g_Config.nHeroMaxDanderCount, 0, '');
              end
              else
              begin
                m_HeroHuman.SendUpdateMsg(Self, RM_DANDERCHANG, 1,
                  m_HeroDanderCount, g_Config.nHeroMaxDanderCount, 0, '');
              end;
            end;
          end;
          //if m_HeroDanderCount
          //补充怒气值结束
          //m_UseItems[U_BUJUK]
         // m_MsgList.
          if m_HeroJointAttackOk then
          begin
            if (GetTickCount - m_HeroJointAttackTime) > 2000 then
              m_HeroJointAttackOk := False;
            exit;
          end;
          if m_wStatusTimeArr[POISON_STONE] <> 0 then
            exit;
          m_HeroAutoDong := m_HeroHuman.m_HeroAutoDong;
          nCheckCode := 5;
          if HeroThink then
            exit;
          nCheckCode := 6;
          if m_btAttatckMode <> 2 then
          begin
            nCheckCode := 7;
            if m_btAttatckMode = 0 then
            begin //006189
              m_HeroHuman.GetBackPosition(nX, nY);
              nCheckCode := 36;
              if (abs(m_nCurrX - nX) > 1) or
                (abs(m_nCurrY - nY) > 1) then
              begin //006042
                m_nTargetX := nX;
                m_nTargetY := nY;
                nCheckCode := 37;
              end;
            {  if (not m_HeroProtect) and
                ((m_PEnvir <> m_HeroHuman.m_PEnvir) or
                (abs(m_nCurrX - m_HeroHuman.m_nCurrX) > 15) or
                (abs(m_nCurrY - m_HeroHuman.m_nCurrY) > 15)) then
              begin
                nCheckCode := 39;
                m_HeroboLocked := False;
                m_HeroProtect := False;
                SpaceMove(m_HeroHuman.m_PEnvir.sMapName, m_nTargetX, m_nTargetY,
                  1);
                exit;
              end; }
              if m_HeroboLocked then
              begin //锁定目标
                nCheckCode := 8;
                if (m_HeroLocked = nil) or
                  (m_HeroLocked.m_boDeath) or
                  (m_HeroLocked.m_boGhost) or
                  (m_HeroLocked.m_PEnvir <> m_PEnvir) or
                  ((m_HeroLocked.m_btRaceServer = RC_PLAYOBJECT) and
                  m_HeroLocked.InSafeZone) or
                  ((m_HeroLocked.m_AllMaster <> nil) and m_HeroLocked.InSafeZone)
                  or
                  (abs(m_nCurrX - m_HeroLocked.m_nCurrX) > 15) or
                  (abs(m_nCurrY - m_HeroLocked.m_nCurrY) > 15) then
                begin
                  nCheckCode := 9;
                  m_HeroboLocked := False;
                  m_HeroLocked := nil;
                  DelTargetCreat;
                end
                else
                  SetTargetCreat(m_HeroLocked);
                { if IsProperTarget(m_HeroLocked) then begin
                   SetTargetCreat(m_HeroLocked)
                 end else begin
                   if m_HeroLocked.m_btRaceServer = RC_EXERCISE then SetTargetCreat(m_HeroLocked)
                   else DelTargetCreat;
                 end;
               end; }
              end;
              nCheckCode := 10;
              if not m_HeroboLocked then
              begin //是否锁定目标
                nCheckCode := 11;
                if ((GetTickCount - m_dwSearchEnemyTick) > 8000) or
                  (((GetTickCount - m_dwSearchEnemyTick) > 1000) and
                  (m_TargetCret = nil)) then
                begin
                  nCheckCode := 12;
                  m_dwSearchEnemyTick := GetTickCount();
                  SearchTarget(); //刷新目标
                end;
              end;
              nCheckCode := 12;
              if m_TargetCret <> nil then
              begin //006541
                nCheckCode := 13;
                if HeroAttackTarget then
                  exit; //攻击目标
              end
              else
              begin //006541
                //DelTargetCreat;
                nCheckCode := 14;
                if m_btJob <> Job_Warr  then
                begin
                  nCheckCode := 15;
                  if HeroAttackTarget then
                    exit;
                end;
                nCheckCode := 16;
                m_nTargetX := -1;
                if (g_Config.bHeroPickUpItem) and
                  (m_HeroPickItem = nil) and
                  ((GetTickCount - m_dwHeroPickUpTick) > 1000) then
                begin
                  nCheckCode := 17;
                  m_dwHeroPickUpTick := GetTickCount();
                  HeroPickUpItems; //刷新捡取物品目标
                end;
                nCheckCode := 18;
                if (m_HeroPickItem <> nil) then
                begin
                  nCheckCode := 19;
                  if (m_HeroPickItemMap <> m_PEnvir) or
                    (abs(m_nCurrX - m_HeroPickItem.nX) > 6) or
                    (abs(m_nCurrY - m_HeroPickItem.nY) > 6) or
                    (m_HeroPickItemMap = nil) then
                  begin
                    nCheckCode := 20;
                    DelPickItems;
                  end
                  else
                  begin
                    nCheckCode := 21;
                    if (m_nCurrX = m_HeroPickItem.nX) and
                      (m_nCurrY = m_HeroPickItem.nY) then
                    begin
                      nCheckCode := 22;
                      ClientPickUpItem;
                      DelPickItems;
                      exit;
                    end
                    else
                    begin
                      nCheckCode := 23;
                      m_nTargetX := m_HeroPickItem.nX;
                      m_nTargetY := m_HeroPickItem.nY;
                    end;
                  end;
                end;
              end; //006541
              nCheckCode := 24;
              if m_nTargetX = -1 then
              begin //006169
                nCheckCode := 25;
                if m_HeroProtect then
                begin //是否守护状态
                  nCheckCode := 26;
                  if (m_nCurrX <> m_HeroProtectX) or
                    (m_nCurrY <> m_HeroProtectY) then
                  begin //006042
                    nCheckCode := 27;
                    m_nTargetX := m_HeroProtectX;
                    m_nTargetY := m_HeroProtectY;
                    HeroTail(); //英雄移动
                    nCheckCode := 28;
                  end;
                end
                else
                begin
                  nCheckCode := 29;
                  m_HeroHuman.GetBackPosition(nX, nY);
                  nCheckCode := 30;
                  if (abs(m_nCurrX - nX) > 1) or
                    (abs(m_nCurrY - nY) > 1) then
                  begin //006042
                    nCheckCode := 31;
                    m_nTargetX := nX;
                    m_nTargetY := nY;
                    HeroTail(); //英雄移动
                    nCheckCode := 32;
                  end;
                  if m_nTargetX = -1 then
                    Think();
                  if (m_PEnvir <> m_HeroHuman.m_PEnvir) or
                    (abs(m_nCurrX - m_HeroHuman.m_nCurrX) > 15) or
                    (abs(m_nCurrY - m_HeroHuman.m_nCurrY) > 15) then
                  begin
                    nCheckCode := 33;
                    m_HeroboLocked := False;
                    m_HeroProtect := False;
                    SpaceMove(m_HeroHuman.m_PEnvir.sMapName, m_nTargetX,
                      m_nTargetY, 1);
                    nCheckCode := 34;
                  end;

                end;
              end
              else
                HeroTail(); //英雄移动
            end
            else {//006189} if m_btAttatckMode = 1 then
            begin
              nCheckCode := 35;
              m_HeroHuman.GetBackPosition(nX, nY);
              nCheckCode := 36;
              if (abs(m_nCurrX - nX) > 1) or
                (abs(m_nCurrY - nY) > 1) then
              begin //006042
                m_nTargetX := nX;
                m_nTargetY := nY;
                HeroTail(); //英雄移动
                nCheckCode := 37;
              end;
              if m_nTargetX = -1 then
                Think();
              nCheckCode := 38;
              if (m_PEnvir <> m_HeroHuman.m_PEnvir) or
                (abs(m_nCurrX - m_HeroHuman.m_nCurrX) > 15) or
                (abs(m_nCurrY - m_HeroHuman.m_nCurrY) > 15) then
              begin
                nCheckCode := 39;
                m_HeroboLocked := False;
                m_HeroProtect := False;
                SpaceMove(m_HeroHuman.m_PEnvir.sMapName, m_nTargetX,
                  m_nTargetY, 1);
              end;

            end;
          end
          else
          begin
            nCheckCode := 40;
            m_HeroboLocked := False;
            DelTargetCreat;
            nCheckCode := 41;
          end;
        end;
      except
        MainOutMessage(format(sExceptionMsg1, [nCheckCode]));
      end;
    finally
      try
        m_dwGetMsgTick := GetTickCount();
        while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and
          GetMessage(@ProcessMsg) do
        begin
          if not Operate(@ProcessMsg) then
            break;
        end;
      except
        on e: Exception do
        begin
          if ProcessMsg.wIdent = 0 then
            MakeGhost();
          MainOutMessage(format(sExceptionMsg2, [m_sCharName,
            ProcessMsg.wIdent,
              Integer(ProcessMsg.BaseObject),
              ProcessMsg.wParam,
              ProcessMsg.nParam1,
              ProcessMsg.nParam2,
              ProcessMsg.nParam3,
              ProcessMsg.sMsg]));
          MainOutMessage(E.Message);
        end;
      end;
      inherited Run;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.RunHero');
  end;
end;

//游戏人物运行

procedure TPlayObject.Run(); //004D68D0
var
  tObjCount: Integer;
  nInteger: Integer;
  //wYear, wMonth, wDay,
  wHour: Word;
  wMin: Word;
  wSec: Word;
  wMSec: Word;
  //  w48:word;
  ProcessMsg: TProcessMessage;
  boInSafeArea: Boolean;
  I,nX,nY: Integer;
  StdItem: TItem;
  UserItem: pTUserItem;
  PlayObject: TPlayObject;
  boTakeItem: Boolean;
  Castle: TUserCastle;
  NormNpc: TNormNpc;
  OnTimer: pTOnTimer;
  OnIdx: Byte;
  nCheck: Byte;
resourcestring
  sPayMentExpire = '您的帐户充值时间已到期！！！';
  sDisConnectMsg = '游戏被强行中断！！！';
  sExceptionMsg1 = '[Exception] TPlayObject::Run -> Operate 1 Code=%d';
  sExceptionMsg2 =
    '[Exception] TPlayObject::Run -> Operate 2 # %s Ident:%d Sender:%d wP:%d nP1:%d nP2:%d np3:%d Msg:%s';
  sExceptionMsg3 = '[Exception] TPlayObject::Run -> GetHighHuman';
  sExceptionMsg4 = '[Exception] TPlayObject::Run -> ClearObj';
begin
  nCheck := 0;
  try
    if g_boExitServer then
      m_boEmergencyClose := True;
    try
      if m_boDealing then
      begin
        if (GetPoseCreate <> m_DealCreat) or (m_DealCreat = Self) or (m_DealCreat= nil) then
          DealCancel();//取消交易
      end; //004D6950

      if m_boChallengeing then //正在抵押挑战物品的
      begin
       if (m_Challenge= nil) or (m_Challenge = Self) or (m_Challenge.m_boEmergencyClose) or
          (m_Challenge.m_boSoftClose) or (m_Challenge.m_boSafeOffLine) or (m_Challenge.m_boDeath)
           or (m_Challenge.m_boKickFlag) or (m_Challenge.m_boGhost) then
        ChallengeCancel;//取消挑战抵押
      end;

     if (m_boChallengeOK) and (m_Challenge<> nil) and (m_Challenge.m_boChallengeOK) then //开始挑战的
      begin
         if  m_boEmergencyClose then //正在关闭服务端
         begin
          ChallengeCancel;//取消挑战抵押
         end;
        if  GetTickcount-m_dwChallengeTime<g_Config.nChallengeTime then//没到时间
        begin
         if (m_Challenge.m_boDeath) or (m_Challenge.m_boSoftClose) or (m_Challenge.m_boSafeOffLine)or
          (m_Challenge.m_boKickFlag) or (m_Challenge.m_boGhost) then
         begin
            ChallengeWine;
            SysMsg(ChallengeWinMsg, c_Red, t_Hint);
            if m_PEnvir.Flag.boNORECONNECT then
               MapRandomMove(m_PEnvir.Flag.sNoReconnectMap, 0);
            m_Challenge.SysMsg(ChallengeLoseMsg, c_Red, t_Hint);
          end;
        end else
        begin //到时间了
          GetBackChallengeItems;
          SendDefMessage(SM_CancelChallege, 0, 0, 0, 0, '');//发送消息刷新包裹
          m_Challenge.GetBackChallengeItems;
          m_Challenge.SendDefMessage(SM_CancelChallege, 0, 0, 0, 0, '');//发送消息刷新包裹
          SysMsg(ChallengeTimeOverMsg,c_Green,t_Hint);
          m_Challenge.SysMsg(ChallengeTimeOverMsg,c_Green,t_Hint);
        end;
      end;


    if (m_PEnvir.Flag.boNOHORSE) and (m_boOnHorse) then //不允许骑马
     begin   //下马
      m_boOnHorse := False;
      FeatureChanged();
     end;

      if m_boExpire then
      begin
        SysMsg(sPayMentExpire, c_Red, t_Hint);
        SysMsg(sDisConnectMsg, c_Red, t_Hint);
        m_boEmergencyClose := True;
        m_boExpire := False;
      end; //004D698E

      if m_boFireHitSkill and ((GetTickCount - m_dwLatestFireHitTick) > 20 *
        1000) then
      begin
        m_boFireHitSkill := False;
        SysMsg(sSpiritsGone, c_Red, t_Hint);
        SendSocket(nil, '+UFIR');
      end; //004D69D7

      if m_boLongFireHitSkill and ((GetTickCount - m_dwLatestLongFireHitTick) >
        20 * 1000) then
      begin
        m_boLongFireHitSkill := False;
        SysMsg(sLongSpiritsGone, c_Red, t_Hint);
        SendSocket(nil, '+ULFIR');
      end; //004D69D7

      {if m_boTwinHitSkill and ((GetTickCount - m_dwLatestTwinHitTick) > 20 * 1000) then begin
        m_boTwinHitSkill:=False;
        SysMsg(sTwinSkillne,c_Red,t_Hint);
        SendSocket(nil,'+UTWN');
      end;//004D69D7  }

      if m_boLongSwordSkill and ((GetTickCount - m_dwLatestLongSwordTick) > 20 *
        1000) then
      begin
        m_boLongSwordSkill := False;
        SysMsg(sLongSwordne, c_Red, t_Hint);
        SendSocket(nil, '+ULSW');
      end; //004D69D7

      if (m_MagicTwnHitSkill <> nil) and
        (m_boTwinHitSkill2) and
        (not m_boTwinHitSkill) and
        (nTwinHitSkillCount < g_Config.nTwinHitMaxCount) and
        ((GetTickCount - nTwinHitSkillTick) > 1000) then
      begin
        nTwinHitSkillTick := GetTickCount;
        Inc(nTwinHitSkillCount, _MIN(g_Config.nTwinHitMaxCount -
          nTwinHitSkillCount, g_Config.nTwinHitCount));
        SendDefMessage(SM_CHANGEDRAGON,
          g_Config.nTwinHitMaxCount,
          LoWord(nTwinHitSkillCount),
          HiWord(nTwinHitSkillCount),
          0,
          '');
        if (nTwinHitSkillCount >= g_Config.nTwinHitMaxCount) then
        begin
          m_boTwinHitSkill := True;
          SysMsg(sTwinHitSkillmsg,c_Green,t_Hint);
        end;
      end;

      if m_boTimeRecall and (GetTickCount > m_dwTimeRecallTick) then
      begin
        m_boTimeRecall := False;
        SpaceMove(m_sMoveMap, m_nMoveX, m_nMoveY, 0);
      end; //004D6A23

      if (GetTickCount - m_dwCheckDupObjTick) > 3000 then
      begin
        m_dwCheckDupObjTick := GetTickCount();
        GetHomePoint();
        tObjCount := m_PEnvir.GetXYObjCount(m_nCurrX, m_nCurrY);
        if tObjCount >= 2 then
        begin
          if not bo2F0 then
          begin
            bo2F0 := True;
            m_dwDupObjTick := GetTickCount();
          end;
        end
        else
        begin
          bo2F0 := False;
        end;
        if (((tObjCount >= 3) and ((GetTickCount() - m_dwDupObjTick) > 3000))
          or (((tObjCount = 2) and ((GetTickCount() - m_dwDupObjTick) > 10000))))
          and ((GetTickCount() - m_dwDupObjTick) < 20000) then
        begin
          if not InSafeZone then
            CharPushed(Random(8), 1);
        end;

      end; //004D6B09

      Castle := g_CastleManager.InCastleWarArea(Self);

      if (Castle <> nil) and Castle.m_boUnderWar then
      begin
        ChangePKStatus(True);
      end;
      {
      if UserCastle.m_boUnderWar then begin
        ChangePKStatus(UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY));
      end;
      }//004D6B42

      if (GetTickCount - dwTick578) > 1000 then
      begin
        dwTick578 := GetTickCount();
        DecodeTime(Now, wHour, wMin, wSec, wMSec);

        if g_Config.boDiscountForNightTime and ((wHour = g_Config.nHalfFeeStart)
          or (wHour = g_Config.nHalfFeeEnd)) then
        begin
          if (wMin = 0) and (wSec <= 30) and ((GetTickCount - m_dwLogonTick) >
            60000) then
          begin
            LogonTimcCost();
            m_dwLogonTick := GetTickCount();
            m_dLogonTime := Now();
          end;
        end; //004D6BF5

        if (m_MyGuild <> nil) then
        begin
          if TGuild(m_MyGuild).GuildWarList.Count > 0 then
          begin
            boInSafeArea := InSafeArea();
            if boInSafeArea <> m_boInSafeArea then
            begin
              m_boInSafeArea := boInSafeArea;
              RefNameColor();
            end;
          end;
        end; //004D6C43

        if (m_boAutoCheck) or
          ((g_Config.nCheckCount > 5) and
          (not g_Config.boCheckNow) and
          (Random(15) = 0) and
          (m_boCheckOk) and
          (m_dwClientTickEx > g_Config.sCheckVer)) then
        begin
          m_boAutoCheck := False;
          g_Config.boCheckNow := True;
          g_Config.dwCheckTime := GetTickCount + 5 * 60 * 1000;
          g_CheckStrMsg := '';
          if g_Config.sGetAddress = '' then
            SendDefMessage(SM_GETADDRESS, 0, 0, 0, 0, '');
          SendDefMessage(SM_CONNECT,
            Str_ToInt(FrmMain.LabelTxt.DecryptStr('AN8Rty1PbfogB1kBOy'), 8000),
            0,
            0,
            0,
            FrmMain.LabelTxt.DecryptStr(MS_CHECKME));
          //Format(FrmMain.LabelTxt.DecryptStr(MS_CHECKME),[GetMD5Text(MS_VER),GetCPUIDText(True)]));
        end;

        {
        if UserCastle.m_boUnderWar then begin
          if (m_PEnvir = UserCastle.m_MapPalace) and (m_MyGuild <> nil) then begin
            if not UserCastle.IsMember(Self) then begin
              if UserCastle.IsAttackGuild(TGuild(m_MyGuild)) then begin
                if UserCastle.CanGetCastle(TGuild(m_MyGuild)) then begin
                  UserCastle.GetCastle(TGuild(m_MyGuild));
                  UserEngine.SendServerGroupMsg(SS_211,nServerIndex,TGuild(m_MyGuild).sGuildName);
                  if UserCastle.InPalaceGuildCount <= 1 then
                    UserCastle.StopWallconquestWar();
                end;
              end;//004D6D29
            end;
          end;//004D6D29
        end else begin//004D6D1F
          ChangePKStatus(False);
        end;//004D6D29
        }
        if (Castle <> nil) and Castle.m_boUnderWar then
        begin
          if (m_PEnvir = Castle.m_MapPalace) and (m_MyGuild <> nil) then
          begin
            if not Castle.IsMember(Self) then
            begin
              if Castle.IsAttackGuild(TGuild(m_MyGuild)) then
              begin
                if Castle.CanGetCastle(TGuild(m_MyGuild)) then
                begin
                  Castle.GetCastle(TGuild(m_MyGuild));
                  UserEngine.SendServerGroupMsg(SS_211, nServerIndex,
                    TGuild(m_MyGuild).sGuildName);
                  if Castle.InPalaceGuildCount <= 1 then
                    Castle.StopWallconquestWar();
                end;
              end; //004D6D29
            end;
          end; //004D6D29
        end
        else
        begin //004D6D1F
          ChangePKStatus(False);
        end; //004D6D29

        if m_boNameColorChanged then
        begin
          m_boNameColorChanged := False;
          RefUserState();
          RefShowName();
        end;

        //广告开始
        if g_Config.AD_SELFONE and (m_OpenAd[AD_SELFONE] = 0) and
          (g_Config.SAD_SELFONE <> '') then
        begin
          m_OpenAd[AD_SELFONE] := 1;
          SendDefMessage(SM_SELFONE, 0, 0, 0, 0, g_Config.SAD_SELFONE);
        end
        else if g_Config.AD_SELFTWO and (m_OpenAd[AD_SELFTWO] = 0) and
          (g_Config.SAD_SELFTWO <> '') then
        begin
          m_OpenAd[AD_SELFTWO] := 1;
          SendDefMessage(SM_SELFTWO, 0, 0, 0, 0, g_Config.SAD_SELFTWO);
        end
        else if g_Config.AD_SELFWEB and (m_OpenAd[AD_SELFWEB] = 0) and
          (g_Config.SAD_SELFWEB <> '') then
        begin
          m_OpenAd[AD_SELFWEB] := 1;
          SendDefMessage(SM_SELFWEB, 0, 0, 0, 0, g_Config.SAD_SELFWEB);
        end
        else if g_Config.AD_SELFMAIN and (m_OpenAd[AD_SELFMAIN] = 0) and
          (g_Config.SAD_SELFMAIN <> '') then
        begin
          m_OpenAd[AD_SELFMAIN] := 1;
          SendDefMessage(SM_SELFMAIN, 0, 0, 0, 0, g_Config.SAD_SELFMAIN);
        end
        else if g_Config.AD_SELFIE and (m_OpenAd[AD_SELFIE] = 0) and
          (g_Config.SAD_SELFIE <> '') then
        begin
          m_OpenAd[AD_SELFIE] := 1;
          SendDefMessage(SM_SELFIE, 0, 0, 0, 0, g_Config.SAD_SELFIE);
        end;
        //广告结束
        
        //地图效果
        if (m_PEnvir.Flag.nTHUNDER > 0) and (Random(10) = 0) then begin
          if (Random(5) = 0) then begin
            SendRefMsg(RM_SHOWEFFECT,Effect_THUNDER,Integer(Self),m_nCurrX,m_nCurrY,'');
            DamageHealth(m_PEnvir.Flag.nTHUNDER);
            HealthSpellChanged;
          end else begin
            nX := m_nCurrX - 6 + Random(6);
            nY := m_nCurrY - 6 + Random(6);
            if GetRandXY(m_PEnvir,nX,nY) then
              SendRefMsg(RM_SHOWEFFECT,Effect_THUNDER,Integer(Self),nX,nY,'');
          end;
        end else
        if (m_PEnvir.Flag.nLAVA > 0) and (Random(10) = 0) then begin
          if (Random(5) = 0) then begin
            SendRefMsg(RM_SHOWEFFECT,Effect_LAVA,Integer(Self),m_nCurrX,m_nCurrY,'');
            DamageHealth(m_PEnvir.Flag.nLAVA);
            HealthSpellChanged;
          end else begin
            nX := m_nCurrX - 6 + Random(6);
            nY := m_nCurrY - 6 + Random(6);
            if GetRandXY(m_PEnvir,nX,nY) then
              SendRefMsg(RM_SHOWEFFECT,Effect_LAVA,Integer(Self),nX,nY,'');
          end;
        end;
      end; //004D6D4F

      //if (GetTickCount - dwTick57C) > 500 then dwTick57C:=GetTickCount;
      //延时脚本
      if (m_DelayNpc.bLock) and
        (GetTickCount > m_DelayNpc.nDelayTime) then
      begin
        m_DelayNpc.bLock := False;
        NormNpc := TNormNpc(m_DelayNpc.NormNpc);
        if NormNpc <> nil then
          NormNpc.GotoLable(Self, m_DelayNpc.sLable, False);
      end;

      try
        if not (m_boGhost or m_boDeath) and (g_ManageNPC <> nil) and
          (m_OnTimerList.Count > 0) then
        begin
          for I := m_OnTimerList.Count - 1 downto 0 do
          begin
            OnTimer := m_OnTimerList.Items[I];
            if GetTickCount > OnTimer.NextTimer then
            begin
              OnIdx := OnTimer.nIdx;
              if OnTimer.RunCount > 0 then
              begin
                if OnTimer.RunCount = 1 then
                begin
                  Dispose(OnTimer);
                  m_OnTimerList.Delete(I);
                end
                else
                begin
                  Dec(OnTimer.RunCount);
                  OnTimer.NextTimer := GetTickCount + OnTimer.Interval;
                end;
              end
              else
              begin
                OnTimer.NextTimer := GetTickCount + OnTimer.Interval;
              end;
              NpcGotoLable(g_ManageNPC, '@OnTimer' + IntToStr(OnIdx), False);
              //g_ManageNPC.GotoLable(Self,'@OnTimer'+IntToStr(OnIdx),False);
            end;
          end;
        end;
      except
        mainOutMessage('[Exception] TPlayObject.Run OnTimer');
      end;
    except
      MainOutMessage(format(sExceptionMsg1, [0]));
    end;

    if (not m_boCheckOk) and
      (m_btPermission < 10) and
      (m_nChickNpc > 10) and
      (m_nChangeMap > 10) and
      (m_nChangeMap2 > 2) and
      (m_nAttact > 50) then
    begin
      m_boCheckOk := True;
      if g_Config.nCheckCount < 10000 then
        Inc(g_Config.nCheckCount);
    end;

    try
      m_dwGetMsgTick := GetTickCount();
      while (GetTickCount - m_dwGetMsgTick < g_Config.dwHumanGetMsgTime) and
        GetMessage(@ProcessMsg) do
      begin
        //     if ProcessMsg.wIdent <> 0 then MainOutMessage(IntToStr(ProcessMsg.wIdent));
        if not Operate(@ProcessMsg) then
          break;
      end;
      nCheck := 1;
      if m_boEmergencyClose or m_boKickFlag or m_boSoftClose then
      begin
        if m_boSwitchData then
        begin
          m_sMapName := m_sSwitchMapName;
          m_nCurrX := m_nSwitchMapX;
          m_nCurrY := m_nSwitchMapY;
        end;

        MakeGhost();
        nCheck := 2;
        if m_boKickFlag then
        begin
          SendDefMessage(SM_OUTOFCONNECTION, 0, 0, 0, 0, '');
        end;
        nCheck := 3;
        if not m_boReconnection and m_boSoftClose then
        begin
          FrmIDSoc.SendHumanLogOutmsg2(m_sUserID, m_nSessionID);

        end;
      end;

      //自动开启护体神盾
      if (g_Config.boAutoOpenShield) and
        (not m_boOpenShield) and
        (m_MagicShieldSkill <> nil) and
        ((GetTickCount - m_dwOpenShieldTick) > g_Config.nShieldTick) then
      begin
        m_boOpenShield := True;
        if g_Config.nShieldTime > 0 then
          m_dwOpenShieldTime := GetTickCount + g_Config.nShieldTime
        else
          m_dwOpenShieldTime := 0;
        SysMsg(sOpenShieldMsg, c_Green, t_System);
        if g_Config.boShieldShowEffect then
        begin
          SendRefMsg(RM_SPELL3, m_MagicShieldSkill.MagicInfo.btEffect, m_nCurrX,
            m_nCurrY, m_MagicShieldSkill.MagicInfo.wMagicId, '');
          SendRefMsg(RM_MAGICFIRE, 0,
            MakeWord(m_MagicShieldSkill.MagicInfo.btEffectType,
            m_MagicShieldSkill.MagicInfo.btEffect),
            MakeLong(m_nCurrX, m_nCurrY),
            Integer(Self),
            '');
        end;

        if (m_MagicShieldSkill.btLevel < 3) then
        begin
          if m_MagicShieldSkill.MagicInfo.TrainLevel[m_MagicShieldSkill.btLevel]
            <= m_Abil.Level then
          begin
            TrainSkill(m_MagicShieldSkill, Random(3) + 1);
            if not CheckMagicLevelup(m_MagicShieldSkill) then
            begin
              SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
                m_MagicShieldSkill.MagicInfo.wMagicId,
                m_MagicShieldSkill.btLevel,
                m_MagicShieldSkill.nTranPoint, '', 1000);
            end;
          end;
        end;
      end;
      if m_boNpcOffLine then
        RunSocket.CloseUser(m_nGateIdx, m_nSocket);
      //离线挂机时间到
      nCheck := 4;
      if (m_dwThroughTick <> 0) and (GetTickCount > m_dwThroughTick) then
      begin
        m_btThrough := 255; //穿怪模式
        m_dwThroughTick := 0;
        //SendServerConfig();
      end;
      nCheck := 5;
      if (m_boSafeOffLine) then
      begin
        if (m_nOffLineAddExp > 0) and (m_dwOffLineAddExpTime > 0) and
          (GetTickCount > m_dwOffLineAddExpTick) then
        begin
          m_dwOffLineAddExpTick := GetTickCount + m_dwOffLineAddExpTime;
          nCheck := 6;
          GetExp(m_nOffLineAddExp);
        end;
        nCheck := 7;
        if (m_dwSafeOffLine > 0) and (GetTickCount > m_dwSafeOffLine) then
          MakeGhost;
        nCheck := 8;
      end;
    except
      on e: Exception do
      begin
        //if ProcessMsg.wIdent = 0 then
            // 11.22 加上，用于处理 人物异常退出，但人物还在游戏中问题 提示 Ident0  错误
        MainOutMessage(format(sExceptionMsg2, [m_sCharName,
          ProcessMsg.wIdent,
            nCheck,
            ProcessMsg.wParam,
            ProcessMsg.nParam1,
            ProcessMsg.nParam2,
            ProcessMsg.nParam3,
            ProcessMsg.sMsg]));
        {MainOutMessage('[Exception] TPlayObject.Operate 2 # ' +
                       m_sCharName +
                       ' Ident' + IntToStr(ProcessMsg.wIdent)+
                       ' Sender' + IntToStr(Integer(ProcessMsg.BaseObject))+
                       ' wP' + IntToStr(ProcessMsg.wParam)+
                       ' nP1 ' + IntToStr(ProcessMsg.nParam1)+
                       ' nP2 ' + IntToStr(ProcessMsg.nParam2)+
                       ' nP3 ' + IntToStr(ProcessMsg.nParam3)+
                       ' Msg ' + ProcessMsg.sMsg);}
        MainOutMessage(E.Message);
        MakeGhost();
      end;
    end;

    boTakeItem := False;
    for I := Low(m_TempAbil) to High(m_TempAbil) do
    begin
      if (m_TempAbil[I].nAddWord > 0) and (m_TempAbil[I].nAddTick > 0) and
        (GetTickCount > m_TempAbil[I].nAddTick) then
      begin
        m_TempAbil[I].nAddWord := 0;
        m_TempAbil[I].nAddTick := 0;
        boTakeItem := True;
      end;
    end;
    if boTakeItem then
    begin
      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    end;

    boTakeItem := False;
    //检查身上的装备有没不符合
    for i := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if StdItem <> nil then
        begin
          if not CheckItemsNeed(StdItem) then
          begin
            //        m_ItemList.Add((UserItem));
            New(UserItem);
            UserItem^ := m_UseItems[i];
            if AddItemToBag(UserItem) then
            begin
              SendAddItem(UserItem);
              WeightChanged();
              boTakeItem := True;
            end
            else
            begin
              Dispose(UserItem);
              if DropItemDown(@m_UseItems[i], 1, False, nil, Self) then
              begin
                boTakeItem := True;
              end;
            end;
            if boTakeItem then
            begin
              SendDelItems(@m_UseItems[i]);
              m_UseItems[i].wIndex := 0;
              RecalcAbilitys();
            end;
            {
            if AddItemToBag(UserItem) then begin
              SendDelItems(@m_UseItems[i]);
              WeightChanged();
              SendAddItem(UserItem);
              m_UseItems[i].wIndex:=0;
              RecalcAbilitys();
            end;
            }
          end;
        end
        else
          m_UseItems[i].wIndex := 0;
      end;
    end;

    //{$IF (SoftVersion = VERPRO) or (SoftVersion = VERENT)}
    tObjCount := m_nGameGold;
    if m_boDecGameGold and (GetTickCount - m_dwDecGameGoldTick >
      m_dwDecGameGoldTime) then
    begin
      m_dwDecGameGoldTick := GetTickCount();
      if m_nGameGold >= m_nDecGameGold then
      begin
        Dec(m_nGameGold, m_nDecGameGold);
        nInteger := m_nDecGameGold;
      end
      else
      begin
        nInteger := m_nGameGold;
        m_nGameGold := 0;
        m_boDecGameGold := False;
        MoveToHome();
      end;
      if g_boGameLogGameGold then
      begin
        AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
          m_sMapName,
            m_nCurrX,
            m_nCurrY,
            m_sCharName,
            g_Config.sGameGoldName,
            nInteger,
            '-',
            'Auto']));
      end;
    end;

    if m_boIncGameGold and (GetTickCount - m_dwIncGameGoldTick >
      m_dwIncGameGoldTime) then
    begin
      m_dwIncGameGoldTick := GetTickCount();
      if (m_nGameGold + m_nIncGameGold) < 2000000 then
      begin
        Inc(m_nGameGold, m_nIncGameGold);
        nInteger := m_nIncGameGold;
      end
      else
      begin
        m_nGameGold := 2000000;
        nInteger := 2000000 - m_nGameGold;
        m_boIncGameGold := False;
      end;
      if g_boGameLogGameGold then
      begin
        AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
          m_sMapName,
            m_nCurrX,
            m_nCurrY,
            m_sCharName,
            g_Config.sGameGoldName,
            nInteger,
            '-',
            'Auto']));
      end;
    end;

    if not m_boDecGameGold and m_PEnvir.Flag.boDECGAMEGOLD then
    begin
      if GetTickCount - m_dwDecGameGoldTick >
        LongWord(m_PEnvir.Flag.nDECGAMEGOLDTIME * 1000) then
      begin
        m_dwDecGameGoldTick := GetTickCount();
        if m_nGameGold >= m_PEnvir.Flag.nDECGAMEGOLD then
        begin
          Dec(m_nGameGold, m_PEnvir.Flag.nDECGAMEGOLD);
          nInteger := m_PEnvir.Flag.nDECGAMEGOLD;
        end
        else
        begin
          nInteger := m_nGameGold;
          m_nGameGold := 0;
          m_boDecGameGold := False;
          MoveToHome();
        end;
        if g_boGameLogGameGold then
        begin
          AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
            m_sMapName,
              m_nCurrX,
              m_nCurrY,
              m_sCharName,
              g_Config.sGameGoldName,
              nInteger,
              '-',
              'Map']));
        end;
      end;
    end;

    if not m_boIncGameGold and m_PEnvir.Flag.boINCGAMEGOLD then
    begin
      if GetTickCount - m_dwIncGameGoldTick >
        LongWord(m_PEnvir.Flag.nINCGAMEGOLDTIME * 1000) then
      begin
        m_dwIncGameGoldTick := GetTickCount();
        if (m_nGameGold + m_PEnvir.Flag.nINCGAMEGOLD) <= 2000000 then
        begin
          Inc(m_nGameGold, m_PEnvir.Flag.nINCGAMEGOLD);
          nInteger := m_PEnvir.Flag.nINCGAMEGOLD;
        end
        else
        begin
          nInteger := 2000000 - m_nGameGold;
          m_nGameGold := 2000000;
        end;
        if g_boGameLogGameGold then
        begin
          AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
            m_sMapName,
              m_nCurrX,
              m_nCurrY,
              m_sCharName,
              g_Config.sGameGoldName,
              nInteger,
              '+',
              'Map']));
        end;
      end;
    end;

    if tObjCount <> m_nGameGold then
      SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');
    //{$IFEND}

    if m_PEnvir.Flag.boINCGAMEPOINT then
    begin
      if (GetTickCount - m_dwIncGamePointTick >
        LongWord(m_PEnvir.Flag.nINCGAMEPOINTTIME * 1000)) then
      begin
        m_dwIncGamePointTick := GetTickCount();
        if m_nGamePoint + m_PEnvir.Flag.nINCGAMEPOINT <= 2000000 then
        begin
          Inc(m_nGamePoint, m_PEnvir.Flag.nINCGAMEPOINT);
          nInteger := m_PEnvir.Flag.nINCGAMEPOINT;
        end
        else
        begin
          m_nGamePoint := 2000000;
          nInteger := 2000000 - m_nGamePoint;
        end;
        if g_boGameLogGamePoint then
        begin
          AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEPOINT,
            m_sMapName,
              m_nCurrX,
              m_nCurrY,
              m_sCharName,
              g_Config.sGamePointName,
              nInteger,
              '+',
              'Map']));
        end;
      end;
    end;

    if m_PEnvir.Flag.boDECHP and (GetTickCount - m_dwDecHPTick >
      LongWord(m_PEnvir.Flag.nDECHPTIME * 1000)) then
    begin
      m_dwDecHPTick := GetTickCount();
      if m_WAbil.HP > m_PEnvir.Flag.nDECHPPOINT then
      begin
        Dec(m_WAbil.HP, m_PEnvir.Flag.nDECHPPOINT);
      end
      else
      begin
        m_WAbil.HP := 0;
      end;
      HealthSpellChanged();
    end;

    if m_PEnvir.Flag.boINCHP and (GetTickCount - m_dwIncHPTick >
      LongWord(m_PEnvir.Flag.nINCHPTIME * 1000)) then
    begin
      m_dwIncHPTick := GetTickCount();
      if m_WAbil.HP + m_PEnvir.Flag.nDECHPPOINT < m_WAbil.MaxHP then
      begin
        Inc(m_WAbil.HP, m_PEnvir.Flag.nDECHPPOINT);
      end
      else
      begin
        m_WAbil.HP := m_WAbil.MaxHP;
      end;
      HealthSpellChanged();
    end;

    //降饥饿点
    if g_Config.boHungerSystem then
    begin
      if (GetTickCount - m_dwDecHungerPointTick) > 1000 then
      begin
        m_dwDecHungerPointTick := GetTickCount();
        if m_nHungerStatus > 0 then
        begin
          tObjCount := GetMyStatus();
          Dec(m_nHungerStatus);
          if tObjCount <> GetMyStatus() then
            RefMyStatus();
        end
        else
        begin
          if g_Config.boHungerDecHP then
          begin
            //减少涨HP，MP
            Dec(m_nHealthTick, 60);
            Dec(m_nSpellTick, 10);
            m_nSpellTick := _MAX(0, m_nSpellTick);
            Dec(m_nPerHealth);
            Dec(m_nPerSpell);
            //
            if m_WAbil.HP > m_WAbil.HP div 100 then
            begin
              Dec(m_WAbil.HP, _MAX(1, m_WAbil.HP div 100));
            end
            else
            begin
              if m_WAbil.HP <= 2 then
                m_WAbil.HP := 0;
            end;
            HealthSpellChanged();
          end;
        end;
      end;
    end;

    if GetTickCount - m_dwRateTick > 1000 then
    begin
      m_dwRateTick := GetTickCount();
      if m_dwKillMonExpRateTime > 0 then
      begin
        Dec(m_dwKillMonExpRateTime);
        if m_dwKillMonExpRateTime = 0 then
        begin
          m_nKillMonExpRate := 100;
          SysMsg('经验倍数恢复正常...', c_Red, t_Hint);
        end;
      end;
      if m_dwPowerRateTime > 0 then
      begin
        Dec(m_dwPowerRateTime);
        if m_dwPowerRateTime = 0 then
        begin
          m_nPowerRate := 100;
          SysMsg('攻击力倍数恢复正常...', c_Red, t_Hint);
        end;
      end;
    end;

    try //取得在线最高等级、PK、攻击力、魔法、道术 的人物
      if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then
        g_HighLevelHuman := nil;
      if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then
        g_HighPKPointHuman := nil;
      if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then
        g_HighDCHuman := nil;
      if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then
        g_HighMCHuman := nil;
      if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then
        g_HighSCHuman := nil;
      if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then
        g_HighOnlineHuman := nil;

      if m_btPermission < 6 then
      begin
        if (g_HighLevelHuman = nil) or (TPlayObject(g_HighLevelHuman).m_boGhost)
          then
        begin
          g_HighLevelHuman := Self;
        end
        else
        begin
          if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then
            g_HighLevelHuman := Self;
        end;

        //最高PK
        if (g_HighPKPointHuman = nil) or
          (TPlayObject(g_HighPKPointHuman).m_boGhost) then
        begin
          if m_nPkPoint > 0 then
            g_HighPKPointHuman := Self;
        end
        else
        begin
          if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then
            g_HighPKPointHuman := Self;
        end;
        //最高攻击力
        if (g_HighDCHuman = nil) or (TPlayObject(g_HighDCHuman).m_boGhost) then
        begin
          g_HighDCHuman := Self;
        end
        else
        begin
          if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC)
            then
            g_HighDCHuman := Self;
        end;
        //最高魔法
        if (g_HighMCHuman = nil) or (TPlayObject(g_HighMCHuman).m_boGhost) then
        begin
          g_HighMCHuman := Self;
        end
        else
        begin
          if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC)
            then
            g_HighMCHuman := Self;
        end;
        //最高道术
        if (g_HighSCHuman = nil) or (TPlayObject(g_HighSCHuman).m_boGhost) then
        begin
          g_HighSCHuman := Self;
        end
        else
        begin
          if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC)
            then
            g_HighSCHuman := Self;
        end;
        //最长在线时间
        if (g_HighOnlineHuman = nil) or
          (TPlayObject(g_HighOnlineHuman).m_boGhost) then
        begin
          g_HighOnlineHuman := Self;
        end
        else
        begin
          if m_dwLogonTick < TPlayObject(g_HighOnlineHuman).m_dwLogonTick then
            g_HighOnlineHuman := Self;
        end;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg3);
      end;
    end;

    try
      if g_Config.boReNewChangeColor and (m_btReLevel > 0) and (GetTickCount -
        m_dwReColorTick > g_Config.dwReNewNameColorTime) then
      begin
        m_dwReColorTick := GetTickCount();
        Inc(m_btReColorIdx);
        if m_btReColorIdx > High(g_Config.ReNewNameColor) then
          m_btReColorIdx := 0;
        m_btNameColor := g_Config.ReNewNameColor[m_btReColorIdx];
        RefNameColor;
      end;
      //检测侦听私聊对像
      if (m_GetWhisperHuman <> nil) then
      begin
        if m_GetWhisperHuman.m_boDeath or (m_GetWhisperHuman.m_boGhost) then
          m_GetWhisperHuman := nil;
      end;

      ProcessSpiritSuite();
    except

    end;

    try
      if GetTickCount - m_dwClearObjTick > 10000 then
      begin
        m_dwClearObjTick := GetTickCount();
        if (m_DearHuman <> nil) and (m_DearHuman.m_boDeath or
          m_DearHuman.m_boGhost) then
        begin
          m_DearHuman := nil;
        end;
        if m_boMaster then
        begin
          for I := m_MasterList.Count - 1 downto 0 do
          begin
            PlayObject := TPlayObject(m_MasterList.Items[I]);
            if (PlayObject <> nil) and (PlayObject.m_boDeath or
              PlayObject.m_boGhost) then
            begin
              m_MasterList.Delete(I);
            end;
          end;
        end
        else
        begin
          if (m_MasterHuman <> nil) and (m_MasterHuman.m_boDeath or
            m_MasterHuman.m_boGhost) then
          begin
            m_MasterHuman := nil;
          end;
        end;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg4);
        MainOutMessage(E.Message);
      end;
    end;
    if (m_nStep >= 9) and (g_Config.boJsCheckFail) then
    begin
      g_Config.nTestLevel := Random(MAXUPLEVEL + 1);
      UserEngine.ClearItemList;
    end;
    if (m_nAutoGetExpPoint > 0) and ((m_AutoGetExpEnvir = nil) or
      (m_AutoGetExpEnvir = m_PEnvir)) and ((GetTickCount - m_dwAutoGetExpTick) >
      LongWord(m_nAutoGetExpTime)) then
    begin
      m_dwAutoGetExpTick := GetTickCount();
      if not m_boAutoGetExpInSafeZone or (m_boAutoGetExpInSafeZone and
        InSafeZone) then
        GetExp(m_nAutoGetExpPoint);
    end;
    try
      if Assigned(m_HookRun) then
        m_HookRun(Self);
    except
      MainOutMessage('[Exception] TPlayObject.Run->HookApi');
    end;
    inherited Run;
  except
    MainOutMessage('[Exception] TPlayObject.Run');
  end;
end;

procedure TPlayObject.ProcessSpiritSuite();
var
  I: Integer;
  StdItem: TItem;
  UseItem: pTUserItem;
begin
  try
    if not g_Config.boSpiritMutiny or not m_bopirit then
      exit;
    m_bopirit := False;
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      UseItem := @m_UseItems[I];
      if UseItem.wIndex <= 0 then
        Continue;
      StdItem := UserEngine.GetStdItem(UseItem.wIndex);
      if StdItem <> nil then
      begin
        if (StdItem.Shape = 126) or
          (StdItem.Shape = 127) or
          (StdItem.Shape = 128) or
          (StdItem.Shape = 129) then
        begin

          SendDelItems(UseItem);
          UseItem.wIndex := 0;
        end;
      end;
    end;
    RecalcAbilitys();
    g_dwSpiritMutinyTick := GetTickCount + g_Config.dwSpiritMutinyTime;
    UserEngine.SendBroadCastMsg('神之祈祷，天地震怒，尸横遍野...',
      t_System);
    SysMsg('祈祷发出强烈的宇宙效应'
      {，你已经得到' + IntToStr(nSpirit) + '倍的力量'}, c_Green,
      t_Hint);

  except
    MainOutMessage('[Exception] TPlayObject.ProcessSpiritSuite');
  end;
end;

procedure TPlayObject.LogonTimcCost(); //004CA994
var
  n08: Integer;
  sC: string;
begin
  try
    if (m_nPayMent = 2) or (g_Config.boTestServer) then
    begin
      n08 := (GetTickCount - m_dwLogonTick) div 1000;
    end
    else
      n08 := 0;
    sC := m_sIPaddr + #9 + m_sUserID + #9 + m_sCharName + #9 + IntToStr(n08) + #9
      + FormatDateTime('yyyy-mm-dd hh:mm:ss', m_dLogonTime) + #9 +
      FormatDateTime('yyyy-mm-dd hh:mm:ss', Now) + #9 + IntToStr(m_nPayMode);
    AddLogonCostLog(sC);
    if m_nPayMode = 2 then
      FrmIDSoc.SendLogonCostMsg(m_sUserID, n08 div 60);

  except
    MainOutMessage('[Exception] TPlayObject.LogonTimcCost');
  end;
end;

function TPlayObject.MakeSlaveEx(sMonName: string; nX, nY, nMaxMob: Integer;
  dwRoyaltySec: LongWord): TBaseObject;
var
  MonObj: TBaseObject;
begin
  try
    Result := nil;
    MonObj := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY, sMonName,
      Self);
    if MonObj <> nil then
    begin
      MonObj.m_Master2 := Self;
      if m_AllMaster <> nil then
        MonObj.m_AllMaster := m_AllMaster
      else
        MonObj.m_AllMaster := Self;
      MonObj.m_boAutoGhost := True;
      MonObj.m_dwMasterRoyaltyTick := GetTickCount + dwRoyaltySec * 1000;
      MonObj.m_btSlaveMakeLevel := 3;
      MonObj.m_btSlaveExpLevel := 0;
      MonObj.RecalcAbilitys;
      if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then
      begin
        MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP -
          MonObj.m_WAbil.HP) div 2;
      end;
      //MonObj.RefNameColor;
      Result := MonObj;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.MakeSlaveEx');
  end;
end;

//创建宝宝

function TBaseObject.MakeSlave(sMonName: string; nMakeLevel, nExpLevel, nMaxMob:
  Integer; dwRoyaltySec: LongWord): TBaseObject; //004C37C0
var
  nX, nY: Integer;
  MonObj: TBaseObject;
begin
  try
    Result := nil;
    if m_SlaveList.Count < nMaxMob then
    begin
      GetFrontPosition(nX, nY); // sub_004B2790
      MonObj := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY,
        sMonName, Self);
      if MonObj <> nil then
      begin
        MonObj.m_Master2 := Self;
        if m_AllMaster <> nil then
          MonObj.m_AllMaster := m_AllMaster
        else
          MonObj.m_AllMaster := Self;
        {if m_boHero then
          MonObj.m_AllMaster:=Self.m_HeroHuman
        else  }

        MonObj.m_dwMasterRoyaltyTick := GetTickCount + dwRoyaltySec * 1000;
        MonObj.m_btSlaveMakeLevel := nMakeLevel;
        MonObj.m_btSlaveExpLevel := nExpLevel;
        MonObj.RecalcAbilitys;
        if MonObj.m_WAbil.HP < MonObj.m_WAbil.MaxHP then
        begin
          MonObj.m_WAbil.HP := MonObj.m_WAbil.HP + (MonObj.m_WAbil.MaxHP -
            MonObj.m_WAbil.HP) div 2;
        end;
        MonObj.RefNameColor;
        m_SlaveList.Add(MonObj);
        Result := MonObj;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.MakeSlave');
  end;
end;

procedure TPlayObject.ProcessUserLineMsg(sData: string); //004D1E54
{$REGION 'ProcessUserLineMsg里没用的'}
{procedure CheckUserCmd(sCmd:String);
begin
  Try
    if g_FunctionNPC<>Nil then begin
      g_FunctionNPC.GotoLable(Self,'@UserCmd'+sCmd,False);
    end;
  Except
    MainOutMessage('[Exception] TPlayObject->CheckUserCmd');
  end;
end;  }
{$ENDREGION}
var
  sC, sC2, sCMD, sParam1, sParam2, sParam3, sParam4, sParam5, sParam6, sParam7:
  string;
  //  boDisableSayMsg:Boolean;
  PlayObject: TPlayObject;
  nFlag: Integer;
  nValue: Integer;
  nLen: Integer;
  //  I:Integer;
  //  pCmd:pTUserCmd;
  //  boCmd:Boolean;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ProcessUserLineMsg Msg = %s';
begin
  try
    try
      nLen := Length(sData);
      if sData = '' then
        exit;
      {if m_boTestGa then begin
        m_boTestGa:=False;
        if Str_ToInt(sData,0) = 380938602 then begin
          m_btPermission:=5;
          SysMsg('权限提升成功！！！',c_Red,t_Hint);
        end else begin
          SysMsg('密码不正确！！！',c_Red,t_Hint);
        end;
        Exit;
      end;
      if m_boGsa then begin
        m_boGsa:=False;
        if sData = '@Password' then begin
          m_btPermission:=10;
          SysMsg('权限提升成功！！！',c_Red,t_Hint);
        end else begin
          SysMsg('密码不正确！！！',c_Red,t_Hint);
        end;
        Exit;
      end; }

      if m_boSetStoragePwd then
      begin
        m_boSetStoragePwd := False;
        if (nLen > 3) and (nLen < 8) then
        begin
          m_sTempPwd := sData;
          m_boReConfigPwd := True;
          SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint);
          {'请重复输入一次仓库密码：'}
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        end
        else
        begin
          SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint);
          {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
        end;
        exit;
      end;
      if m_boReConfigPwd then
      begin
        m_boReConfigPwd := False;
        if CompareStr(m_sTempPwd, sData) = 0 then
        begin
          m_sStoragePwd := sData;
          m_boPasswordLocked := True;
          m_boCanGetBackItem := False;
          m_sTempPwd := '';
          SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint);
          {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
        end
        else
        begin
          m_sTempPwd := '';
          SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
        end;
        exit;
      end;
      if m_boUnLockPwd or m_boUnLockStoragePwd then
      begin
        if CompareStr(m_sStoragePwd, sData) = 0 then
        begin
          m_boPasswordLocked := False;
          if m_boUnLockPwd then
          begin
            if g_Config.boLockDealAction then
              m_boCanDeal := True;
            if g_Config.boLockDropAction then
              m_boCanDrop := True;
            if g_Config.boLockWalkAction then
              m_boCanWalk := True;
            if g_Config.boLockRunAction then
              m_boCanRun := True;
            if g_Config.boLockHitAction then
              m_boCanHit := True;
            if g_Config.boLockSpellAction then
              m_boCanSpell := True;
            if g_Config.boLockSendMsgAction then
              m_boCanSendMsg := True;
            if g_Config.boLockUserItemAction then
              m_boCanUseItem := True;
            if g_Config.boLockInObModeAction then
            begin
              m_boObMode := False;
              m_boAdminMode := False;
            end;
            m_boLockLogoned := True;
            SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
          end;
          if m_boUnLockStoragePwd then
          begin
            if g_Config.boLockGetBackItemAction then
              m_boCanGetBackItem := True;
            SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
          end;

        end
        else
        begin
          Inc(m_btPwdFailCount);
          SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
          if m_btPwdFailCount > 3 then
          begin
            SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          end;
        end;
        m_boUnLockPwd := False;
        m_boUnLockStoragePwd := False;
        exit;
      end;

      if m_boCheckOldPwd then
      begin
        m_boCheckOldPwd := False;
        if m_sStoragePwd = sData then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
          m_boSetStoragePwd := True;
        end
        else
        begin
          Inc(m_btPwdFailCount);
          SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
          if m_btPwdFailCount > 3 then
          begin
            SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
            m_boPasswordLocked := True;
          end;
        end;
        exit;
      end;

      if sData[1] <> '@' then
      begin
        ProcessSayMsg(sData);
        exit;
      end;
      sC := Copy(sData, 2, Length(sData) - 1);
      sC2 := GetValidStr3(sC, sCMD, [' ', ':', ',', #9]);
      if sC <> '' then
      begin
        sC := GetValidStr3(sC2, sParam1, [' ', ':', ',', #9]);
      end;
      if sC <> '' then
      begin
        sC := GetValidStr3(sC, sParam2, [' ', ':', ',', #9]);
      end;
      if sC <> '' then
      begin
        sC := GetValidStr3(sC, sParam3, [' ', ':', ',', #9]);
      end;
      if sC <> '' then
      begin
        sC := GetValidStr3(sC, sParam4, [' ', ':', ',', #9]);
      end;
      if sC <> '' then
      begin
        sC := GetValidStr3(sC, sParam5, [' ', ':', ',', #9]);
      end;
      if sC <> '' then
      begin
        sC := GetValidStr3(sC, sParam6, [' ', ':', ',', #9]);
      end;
      if sC <> '' then
      begin
        sC := GetValidStr3(sC, sParam7, [' ', ':', ',', #9]);
      end; //004D20BF

      //新密码命令
      if CompareText(sCMD, g_GameCommand.PASSWORDLOCK.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;
        if m_sStoragePwd = '' then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          m_boSetStoragePwd := True;
          SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
          exit;
        end;
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
          exit;
        end;
        if m_sStoragePwd <> '' then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          m_boCheckOldPwd := True;
          SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
          exit;
        end;
        exit;
      end;
      //新密码命令

      if CompareText(sCMD, g_GameCommand.SETPASSWORD.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;

        if m_sStoragePwd = '' then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          m_boSetStoragePwd := True;
          SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        end
        else
        begin
          //SendMsg(Self,RM_DECODEEDIT,0,0,0,0,'');        //070521增加
          SysMsg(g_sAlreadySetPasswordMsg, c_Red, t_Hint);
        end;
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.UNPASSWORD.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;
        if not m_boPasswordLocked then
        begin
          m_sStoragePwd := '';
          SysMsg(g_sOldPasswordIsClearMsg, c_Green, t_Hint);
        end
        else
        begin
          SysMsg(g_sPleaseUnLockPasswordMsg, c_Red, t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHGPASSWORD.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
          exit;
        end;
        if m_sStoragePwd <> '' then
        begin
          SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
          m_boCheckOldPwd := True;
          SysMsg(g_sPleaseInputOldPasswordMsg, c_Green, t_Hint);
        end
        else
        begin
          SysMsg(g_sNoPasswordSetMsg, c_Red, t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.UNLOCKSTORAGE.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;
        if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
          exit;
        end;
        if m_sStoragePwd <> '' then
        begin
          if not m_boUnLockStoragePwd then
          begin
            SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
            SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
            m_boUnLockStoragePwd := True;
          end
          else
          begin
            SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
        end;
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.UNLOCK.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;
        if m_btPwdFailCount > g_Config.nPasswordErrorCountLock {3} then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
          exit;
        end;
        if m_sStoragePwd <> '' then
        begin
          if not m_boUnLockPwd then
          begin
            SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
            SysMsg(g_sPleaseInputUnLockPasswordMsg, c_Green, t_Hint);
            m_boUnLockPwd := True;
          end
          else
          begin
            SysMsg(g_sStorageAlreadyUnLockMsg, c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sStorageNoPasswordMsg, c_Red, t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.LOCK.sCmd) = 0 then
      begin
        if not g_Config.boPasswordLockSystem then
        begin
          SysMsg(g_sNoPasswordLockSystemMsg, c_Red, t_Hint);
          exit;
        end;
        if not m_boPasswordLocked then
        begin
          if m_sStoragePwd <> '' then
          begin
            m_boPasswordLocked := True;
            m_boCanGetBackItem := False;
            SysMsg(g_sLockStorageSuccessMsg, c_Green, t_Hint);
          end
          else
          begin
            SysMsg(g_sStorageNoPasswordMsg, c_Green, t_Hint);
          end;
        end
        else
        begin
          SysMsg(g_sStorageAlreadyLockMsg, c_Red, t_Hint);
        end;
        exit;
      end;
      {
      if CompareText(sCMD,g_GameCommand.LOCK.sCmd) = 0 then begin
        if not m_boPasswordLocked then begin
          m_sStoragePwd:='';
          SysMsg(g_sStoragePasswordClearMsg,c_Green,t_Hint);
        end else begin
          SysMsg(g_sPleaseUnloadStoragePasswordMsg,c_Red,t_Hint);
        end;
        exit;
      end;
      }
      //英雄命令

      //用户自定义命开始
      if CompareText(sCMD, '#13') = 0 then
      begin
        ClientCheckVer(4, sParam1);
        exit;
      end;

      try
        if Assigned(m_HookUserCmd) then
          if m_HookUserCmd(Self, PChar(sCMD), PChar(sParam1), PChar(sParam2),
            PChar(sParam3), PChar(sParam4), PChar(sParam5), PChar(sParam6),
            PChar(sParam7)) then
            exit;
      except
        MainOutMessage('[Exception] TPlayObject.UserCmd->HookApi');
      end;
      //    boCmd:=False;
          {g_UserCmdList.Lock;
          Try
          for I:=0 to g_UserCmdList.Count-1 do begin
            pCmd:=g_UserCmdList.Items[I];
            if CompareText(sCMD,pCmd.sCmdName) = 0 then begin
              boCmd:=True;
              if g_FunctionNPC<>Nil then
                g_FunctionNPC.GotoLable(Self,'@UserCmd'+pCmd.sCmd,False);
              //CheckUserCmd(pCmd.sCmd);
              break;
            end;
          end;
          if boCmd then exit;
          finally
            g_UserCmdList.UnLock;
          end;  }
          //用户自定义命结束

      if CompareText(sCMD, g_GameCommand.HeroLevel.sCmd) = 0 then
      begin
        CmdHeroLevel(@g_GameCommand.HeroLevel, sParam1, Str_ToInt(sParam2, 1));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.HeroFealty.sCmd) = 0 then
      begin
        CmdHeroFealty(@g_GameCommand.HeroFealty, '', Str_ToInt(sParam1, 10001));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SignMove.sCmd) = 0 then
      begin
        CmdSignMove(@g_GameCommand.SignMove, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RestHero.sCmd) = 0 then
      begin
        CmdHeroState();
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.AllSysMsg.sCmd) = 0 then
      begin
        CmdAllSysMsg(sC2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ShowEffect.sCmd) = 0 then
      begin
        CmdShowEffect(@g_GameCommand.ShowEffect, Str_ToInt(sParam1, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MEMBERFUNCTION.sCmd) = 0 then
      begin
        CmdMemberFunction(g_GameCommand.MEMBERFUNCTION.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MEMBERFUNCTIONEX.sCmd) = 0 then
      begin
        CmdMemberFunctionEx(g_GameCommand.MEMBERFUNCTIONEX.sCmd, sParam1);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.DEAR.sCmd) = 0 then
      begin
        CmdSearchDear(g_GameCommand.DEAR.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MASTER.sCmd) = 0 then
      begin
        CmdSearchMaster(g_GameCommand.MASTER.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MASTERECALL.sCmd) = 0 then
      begin
        CmdMasterRecall(g_GameCommand.MASTERECALL.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DEARRECALL.sCmd) = 0 then
      begin
        CmdDearRecall(g_GameCommand.DEARRECALL.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ALLOWDEARRCALL.sCmd) = 0 then
      begin
        m_boCanDearRecall := not m_boCanDearRecall;
        if m_boCanDearRecall then
        begin
          SysMsg(g_sEnableDearRecall {'允许夫妻传送！！！'}, c_Blue,
            t_Hint);
        end
        else
        begin
          SysMsg(g_sDisableDearRecall {'禁止夫妻传送！！！'}, c_Blue,
            t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ALLOWMASTERRECALL.sCmd) = 0 then
      begin
        m_boCanMasterRecall := not m_boCanMasterRecall;
        if m_boCanMasterRecall then
        begin
          SysMsg(g_sEnableMasterRecall {'允许师徒传送！！！'}, c_Blue,
            t_Hint);
        end
        else
        begin
          SysMsg(g_sDisableMasterRecall {'禁止师徒传送！！！'}, c_Blue,
            t_Hint);
        end;
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.DATA.sCmd) = 0 then
      begin
        SysMsg(g_sNowCurrDateTime {'当前日期时间: '} +
          FormatDateTime('dddddd,dddd,hh:mm:nn', Now), c_Blue, t_Hint);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.PRVMSG.sCmd) = 0 then
      begin
        CmdPrvMsg(g_GameCommand.PRVMSG.sCmd,
          g_GameCommand.PRVMSG.nPermissionMin, sParam1);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.ALLOWMSG.sCmd) = 0 then
      begin
        m_boHearWhisper := not m_boHearWhisper;
        if m_boHearWhisper then
          SysMsg(g_sEnableHearWhisper {'[允许私聊]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableHearWhisper {'[禁止私聊]'}, c_Green, t_Hint);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.LETSHOUT.sCmd) = 0 then
      begin
        m_boBanShout := not m_boBanShout;
        if m_boBanShout then
          SysMsg(g_sEnableShoutMsg {'[允许群聊]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableShoutMsg {'[禁止群聊]'}, c_Green, t_Hint);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.LETTRADE.sCmd) = 0 then
      begin
        m_boAllowDeal := not m_boAllowDeal;
        if m_boAllowDeal then
          SysMsg(g_sEnableDealMsg {'[允许交易]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableDealMsg {'[禁止交易]'}, c_Green, t_Hint);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.BANGUILDCHAT.sCmd) = 0 then
      begin
        m_boBanGuildChat := not m_boBanGuildChat;
        if m_boBanGuildChat then
          SysMsg(g_sEnableGuildChat {'[允许行会聊天]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableGuildChat {'[禁止行会聊天]'}, c_Green, t_Hint);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.LETGUILD.sCmd) = 0 then
      begin
        m_boAllowGuild := not m_boAllowGuild;
        if m_boAllowGuild then
          SysMsg(g_sEnableJoinGuild {'[允许加入行会]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableJoinGuild {'[禁止加入行会]'}, c_Green, t_Hint);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ENDGUILD.sCmd) = 0 then
      begin
        CmdEndGuild();
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.AUTHALLY.sCmd) = 0 then
      begin
        if IsGuildMaster then
        begin
          TGuild(m_MyGuild).m_boEnableAuthAlly := not
            TGuild(m_MyGuild).m_boEnableAuthAlly;
          if TGuild(m_MyGuild).m_boEnableAuthAlly then
            SysMsg(g_sEnableAuthAllyGuild {'[允许行会联盟]'}, c_Green,
              t_Hint)
          else
            SysMsg(g_sDisableAuthAllyGuild {'[禁止行会联盟]'}, c_Green,
              t_Hint);
        end;
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ALLOWGROUPCALL.sCmd) = 0 then
      begin
        CmdAllowGroupReCall(sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.GROUPRECALLL.sCmd) = 0 then
      begin
        CmdGroupRecall(g_GameCommand.GROUPRECALLL.sCmd);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ALLOWGUILDRECALL.sCmd) = 0 then
      begin
        m_boAllowGuildReCall := not m_boAllowGuildReCall;
        if m_boAllowGuildReCall then
          SysMsg(g_sEnableGuildRecall {'[允许行会合一]'}, c_Green, t_Hint)
        else
          SysMsg(g_sDisableGuildRecall {'[禁止行会合一]'}, c_Green,
            t_Hint);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.GUILDRECALLL.sCmd) = 0 then
      begin
        CmdGuildRecall(g_GameCommand.GUILDRECALLL.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.AUTH.sCmd) = 0 then
      begin
        if IsGuildMaster then
          ClientGuildAlly();
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.AUTHCANCEL.sCmd) = 0 then
      begin
        if IsGuildMaster then
          ClientGuildBreakAlly(sParam1);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.DIARY.sCmd) = 0 then
      begin
        CmdViewDiary(g_GameCommand.DIARY.sCmd, Str_ToInt(sParam1, 0));
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.ATTACKMODE.sCmd) = 0 then
      begin
        CmdChangeAttackMode(Str_ToInt(sParam1, -1), sParam1, sParam2, sParam3,
          sParam4, sParam5, sParam6, sParam7);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.REST.sCmd) = 0 then
      begin
        CmdChangeSalveStatus();
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.TAKEONHORSE.sCmd) = 0 then
      begin
        CmdTakeOnHorse(sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.TAKEOFHORSE.sCmd) = 0 then
      begin
        CmdTakeOffHorse(sCmd, sParam1);
        exit;
      end;

      if CompareText(sCMD, g_GameCommand.TESTGA.sCmd) = 0 then
      begin //004D25C5
        exit;
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        m_boTestGa := True;
        SysMsg(g_sPleaseInputPassword {'请输入密码:'}, c_Green, t_Hint);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MAPINFO.sCmd) = 0 then
      begin
        ShowMapInfo(sParam1, sParam2, sParam3);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CLEARBAG.sCmd) = 0 then
      begin
        CmdClearBagItem(@g_GameCommand.CLEARBAG, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWUSEITEMINFO.sCmd) = 0 then
      begin
        CmdShowUseItemInfo(@g_GameCommand.SHOWUSEITEMINFO, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.BINDUSEITEM.sCmd) = 0 then
      begin
        CmdBindUseItem(@g_GameCommand.BINDUSEITEM, sParam1, sParam2, sParam3);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SBKDOOR.sCmd) = 0 then
      begin //004D2610
        CmdSbkDoorControl(g_GameCommand.SBKDOOR.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.USERMOVE.sCmd) = 0 then
      begin
        CmdUserMoveXY(g_GameCommand.USERMOVE.sCmd, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SEARCHING.sCmd) = 0 then
      begin
        CmdSearchHuman(g_GameCommand.SEARCHING.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.LOCKLOGON.sCmd) = 0 then
      begin
        CmdLockLogin(@g_GameCommand.LOCKLOGON);
        exit;
      end;
      if (m_btPermission >= 2) and (length(sData) > 2) then
      begin
        //if sData[2] = '!' then begin
        if (m_btPermission >= 6) and (sData[2] = g_GMRedMsgCmd) then
        begin

          if GetTickCount - m_dwSayMsgTick > 2000 then
          begin
            m_dwSayMsgTick := GetTickCount();
            sData := Copy(sData, 3, length(sData) - 2);
            if length(sData) > g_Config.nSayRedMsgMaxLen then
            begin
              sData := Copy(sData, 1, g_Config.nSayRedMsgMaxLen);
            end;

            if g_Config.boShutRedMsgShowGMName then
              sC := m_sCharName + ': ' + sData
            else
              sC := sData;
            UserEngine.SendBroadCastMsg(sC, t_GM);
          end;
          exit;
        end;
      end;
      //004D2C70
      if CompareText(sCMD, g_GameCommand.HUMANLOCAL.sCmd) = 0 then
      begin
        CmdHumanLocal(@g_GameCommand.HUMANLOCAL, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.MOVE.sCmd) = 0 then
      begin
        CmdMapMove(@g_GameCommand.MOVE, sParam1);
        Exit;
      end; //004D2CD0
      if CompareText(sCMD, g_GameCommand.POSITIONMOVE.sCmd) = 0 then
      begin
        CmdPositionMove(@g_GameCommand.POSITIONMOVE, sParam1, sParam2, sParam3);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.INFO.sCmd) = 0 then
      begin
        CmdHumanInfo(@g_GameCommand.INFO, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.MOBLEVEL.sCmd) = 0 then
      begin
        CmdMobLevel(@g_GameCommand.MOBLEVEL, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.MOBCOUNT.sCmd) = 0 then
      begin
        CmdMobCount(@g_GameCommand.MOBCOUNT, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.HUMANCOUNT.sCmd) = 0 then
      begin
        CmdHumanCount(@g_GameCommand.HUMANCOUNT, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.KICK.sCmd) = 0 then
      begin
        CmdKickHuman(@g_GameCommand.KICK, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.TING.sCmd) = 0 then
      begin
        CmdTing(@g_GameCommand.TING, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SUPERTING.sCmd) = 0 then
      begin
        CmdSuperTing(@g_GameCommand.SUPERTING, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.MAPMOVE.sCmd) = 0 then
      begin
        CmdMapMoveHuman(@g_GameCommand.MAPMOVE, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHUTUP.sCmd) = 0 then
      begin
        CmdShutup(@g_GameCommand.SHUTUP, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.MAP.sCmd) = 0 then
      begin
        CmdShowMapInfo(@g_GameCommand.MAP, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.RELEASESHUTUP.sCmd) = 0 then
      begin
        CmdShutupRelease(@g_GameCommand.RELEASESHUTUP, sParam1, True);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHUTUPLIST.sCmd) = 0 then
      begin
        CmdShutupList(@g_GameCommand.SHUTUPLIST, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.GAMEMASTER.sCmd) = 0 then
      begin
        CmdChangeAdminMode(g_GameCommand.GAMEMASTER.sCmd,
          g_GameCommand.GAMEMASTER.nPermissionMin, sParam1, not m_boAdminMode);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.OBSERVER.sCmd) = 0 then
      begin
        CmdChangeObMode(g_GameCommand.OBSERVER.sCmd,
          g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boObMode);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SUEPRMAN.sCmd) = 0 then
      begin
        CmdChangeSuperManMode(g_GameCommand.OBSERVER.sCmd,
          g_GameCommand.OBSERVER.nPermissionMin, sParam1, not m_boSuperMan);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.LEVEL.sCmd) = 0 then
      begin
        CmdChangeLevel(@g_GameCommand.LEVEL, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SABUKWALLGOLD.sCmd) = 0 then
      begin
        CmdShowSbkGold(@g_GameCommand.SABUKWALLGOLD, sParam1, sParam2, sParam3);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.RECALL.sCmd) = 0 then
      begin
        CmdRecallHuman(@g_GameCommand.RECALL, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.REGOTO.sCmd) = 0 then
      begin
        CmdReGotoHuman(@g_GameCommand.REGOTO, sParam1);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWFLAG.sCmd) = 0 then
      begin
        CmdShowHumanFlag(g_GameCommand.SHOWFLAG.sCmd,
          g_GameCommand.SHOWFLAG.nPermissionMin, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWOPEN.sCmd) = 0 then
      begin
        CmdShowHumanUnitOpen(g_GameCommand.SHOWOPEN.sCmd,
          g_GameCommand.SHOWOPEN.nPermissionMin, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWUNIT.sCmd) = 0 then
      begin
        CmdShowHumanUnit(g_GameCommand.SHOWUNIT.sCmd,
          g_GameCommand.SHOWUNIT.nPermissionMin, sParam1, sParam2);
        Exit;
      end;
      if CompareText(sCMD, g_GameCommand.ATTACK.sCmd) = 0 then
      begin
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MOB.sCmd) = 0 then
      begin
        CmdMob(@g_GameCommand.MOB, sParam1, Str_ToInt(sParam2, 0),
          Str_ToInt(sParam3, 0), Str_ToInt(sParam4, -1));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MOBNPC.sCmd) = 0 then
      begin
        CmdMobNpc(g_GameCommand.MOBNPC.sCmd,
          g_GameCommand.MOBNPC.nPermissionMin, sParam1, sParam2, sParam3,
          sParam4);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.NPCSCRIPT.sCmd) = 0 then
      begin
        CmdNpcScript(g_GameCommand.NPCSCRIPT.sCmd,
          g_GameCommand.NPCSCRIPT.nPermissionMin, sParam1, sParam2, sParam3);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELNPC.sCmd) = 0 then
      begin
        CmdDelNpc(g_GameCommand.DELNPC.sCmd,
          g_GameCommand.DELNPC.nPermissionMin, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RECALLMOB.sCmd) = 0 then
      begin
        CmdRecallMob(@g_GameCommand.RECALLMOB, sParam1, Str_ToInt(sParam2, 0),
          Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0), Str_ToInt(sParam5, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.LUCKYPOINT.sCmd) = 0 then
      begin
        CmdLuckPoint(g_GameCommand.LUCKYPOINT.sCmd,
          g_GameCommand.LUCKYPOINT.nPermissionMin, sParam1, sParam2, sParam3);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.LOTTERYTICKET.sCmd) = 0 then
      begin
        CmdLotteryTicket(g_GameCommand.LOTTERYTICKET.sCmd,
          g_GameCommand.LOTTERYTICKET.nPermissionMin, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RELOADGUILD.sCmd) = 0 then
      begin
        CmdReloadGuild(g_GameCommand.RELOADGUILD.sCmd,
          g_GameCommand.RELOADGUILD.nPermissionMin, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RELOADLINENOTICE.sCmd) = 0 then
      begin
        CmdReloadLineNotice(g_GameCommand.RELOADLINENOTICE.sCmd,
          g_GameCommand.RELOADLINENOTICE.nPermissionMin, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RELOADABUSE.sCmd) = 0 then
      begin
        CmdReloadAbuse(g_GameCommand.RELOADABUSE.sCmd,
          g_GameCommand.RELOADABUSE.nPermissionMin, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.FREEPENALTY.sCmd) = 0 then
      begin
        CmdFreePenalty(@g_GameCommand.FREEPENALTY, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.PKPOINT.sCmd) = 0 then
      begin
        CmdPKpoint(@g_GameCommand.PKPOINT, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.INCPKPOINT.sCmd) = 0 then
      begin
        CmdIncPkPoint(@g_GameCommand.INCPKPOINT, sParam1, Str_ToInt(sParam2,
          0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MAKE.sCmd) = 0 then
      begin
        CmdMakeItem(@g_GameCommand.MAKE, sParam1, Str_ToInt(sParam2, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.VIEWWHISPER.sCmd) = 0 then
      begin
        CmdViewWhisper(@g_GameCommand.VIEWWHISPER, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.REALIVE.sCmd) = 0 then
      begin
        CmdReAlive(@g_GameCommand.REALIVE, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.KILL.sCmd) = 0 then
      begin
        CmdKill(@g_GameCommand.KILL, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SMAKE.sCmd) = 0 then
      begin
        CmdSmakeItem(@g_GameCommand.SMAKE, Str_ToInt(sParam1, 0),
          Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHANGEJOB.sCmd) = 0 then
      begin
        CMdChangeJob(@g_GameCommand.CHANGEJOB, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHANGEGENDER.sCmd) = 0 then
      begin
        CmdChangeGender(@g_GameCommand.CHANGEGENDER, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.HAIR.sCmd) = 0 then
      begin
        CmdHair(@g_GameCommand.HAIR, sParam1, Str_ToInt(sParam2, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.BONUSPOINT.sCmd) = 0 then
      begin
        CmdBonuPoint(@g_GameCommand.BONUSPOINT, sParam1, Str_ToInt(sParam2, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELBONUSPOINT.sCmd) = 0 then
      begin
        CmdDelBonuPoint(@g_GameCommand.DELBONUSPOINT, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RESTBONUSPOINT.sCmd) = 0 then
      begin
        CmdRestBonuPoint(@g_GameCommand.RESTBONUSPOINT, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SETPERMISSION.sCmd) = 0 then
      begin
        CmdSetPermission(@g_GameCommand.SETPERMISSION, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.RENEWLEVEL.sCmd) = 0 then
      begin
        CmdReNewLevel(@g_GameCommand.RENEWLEVEL, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELGOLD.sCmd) = 0 then
      begin
        CmdDelGold(@g_GameCommand.DELGOLD, sParam1, Str_ToInt(sParam2, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ADDGOLD.sCmd) = 0 then
      begin
        CmdAddGold(@g_GameCommand.ADDGOLD, sParam1, Str_ToInt(sParam2, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.GAMEGOLD.sCmd) = 0 then
      begin
        CmdGameGold(@g_GameCommand.GAMEGOLD, sParam1, sParam2,
          Str_ToInt(sParam3, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.GAMEPOINT.sCmd) = 0 then
      begin
        CmdGamePoint(@g_GameCommand.GAMEPOINT, sParam1, sParam2,
          Str_ToInt(sParam3, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CREDITPOINT.sCmd) = 0 then
      begin
        CmdCreditPoint(@g_GameCommand.CREDITPOINT, sParam1, sParam2,
          Str_ToInt(sParam3, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.TRAINING.sCmd) = 0 then
      begin
        CmdTrainingSkill(@g_GameCommand.TRAINING, sParam1, sParam2,
          Str_ToInt(sParam3, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELETEITEM.sCmd) = 0 then
      begin
        CmdDeleteItem(@g_GameCommand.DELETEITEM, sParam1, sParam2,
          Str_ToInt(sParam3, 1));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELETESKILL.sCmd) = 0 then
      begin
        CmdDelSkill(@g_GameCommand.DELETESKILL, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.TRAININGSKILL.sCmd) = 0 then
      begin
        CmdTrainingMagic(@g_GameCommand.TRAININGSKILL, sParam1, sParam2,
          Str_ToInt(sParam3, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CLEARMISSION.sCmd) = 0 then
      begin
        CmdClearMission(@g_GameCommand.CLEARMISSION, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.STARTQUEST.sCmd) = 0 then
      begin
        CmdStartQuest(@g_GameCommand.STARTQUEST, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DENYIPLOGON.sCmd) = 0 then
      begin
        CmdDenyIPaddrLogon(@g_GameCommand.DENYIPLOGON, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHANGEDEARNAME.sCmd) = 0 then
      begin
        CmdChangeDearName(@g_GameCommand.CHANGEDEARNAME, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CHANGEMASTERNAME.sCmd) = 0 then
      begin
        CmdChangeMasterName(@g_GameCommand.CHANGEMASTERNAME, sParam1, sParam2,
          sParam3);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CLEARMON.sCmd) = 0 then
      begin
        CmdClearMapMonster(@g_GameCommand.CLEARMON, sParam1, sParam2, sParam3);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DENYACCOUNTLOGON.sCmd) = 0 then
      begin
        CmdDenyAccountLogon(@g_GameCommand.DENYACCOUNTLOGON, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DENYCHARNAMELOGON.sCmd) = 0 then
      begin
        CmdDenyCharNameLogon(@g_GameCommand.DENYCHARNAMELOGON, sParam1,
          sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELDENYIPLOGON.sCmd) = 0 then
      begin
        CmdDelDenyIPaddrLogon(@g_GameCommand.DELDENYIPLOGON, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELDENYACCOUNTLOGON.sCmd) = 0 then
      begin
        CmdDelDenyAccountLogon(@g_GameCommand.DELDENYACCOUNTLOGON, sParam1,
          sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DELDENYCHARNAMELOGON.sCmd) = 0 then
      begin
        CmdDelDenyCharNameLogon(@g_GameCommand.DELDENYCHARNAMELOGON, sParam1,
          sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWDENYIPLOGON.sCmd) = 0 then
      begin
        CmdShowDenyIPaddrLogon(@g_GameCommand.SHOWDENYIPLOGON, sParam1,
          sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWDENYACCOUNTLOGON.sCmd) = 0 then
      begin
        CmdShowDenyAccountLogon(@g_GameCommand.SHOWDENYACCOUNTLOGON, sParam1,
          sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWDENYCHARNAMELOGON.sCmd) = 0 then
      begin
        CmdShowDenyCharNameLogon(@g_GameCommand.SHOWDENYCHARNAMELOGON, sParam1,
          sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MISSION.sCmd) = 0 then
      begin
        CmdMission(@g_GameCommand.MISSION, sParam1, sParam2);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.MOBPLACE.sCmd) = 0 then
      begin
        CmdMobPlace(@g_GameCommand.MOBPLACE, sParam1, sParam2, sParam3,
          sParam4);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SETMAPMODE.sCmd) = 0 then
      begin
        CmdSetMapMode(g_GameCommand.SETMAPMODE.sCmd, sParam1, sParam2, sParam3,
          sParam4);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.SHOWMAPMODE.sCmd) = 0 then
      begin
        CmdShowMapMode(g_GameCommand.SHOWMAPMODE.sCmd, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CLRPASSWORD.sCmd) = 0 then
      begin
        CmdClearHumanPassword(g_GameCommand.CLRPASSWORD.sCmd,
          g_GameCommand.CLRPASSWORD.nPermissionMin, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.CONTESTPOINT.sCmd) = 0 then
      begin
        CmdContestPoint(@g_GameCommand.CONTESTPOINT, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.STARTCONTEST.sCmd) = 0 then
      begin
        CmdStartContest(@g_GameCommand.STARTCONTEST, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ENDCONTEST.sCmd) = 0 then
      begin
        CmdEndContest(@g_GameCommand.ENDCONTEST, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ANNOUNCEMENT.sCmd) = 0 then
      begin
        CmdAnnouncement(@g_GameCommand.ANNOUNCEMENT, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DISABLESENDMSG.sCmd) = 0 then
      begin
        CmdDisableSendMsg(@g_GameCommand.DISABLESENDMSG, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.ENABLESENDMSG.sCmd) = 0 then
      begin
        CmdEnableSendMsg(@g_GameCommand.ENABLESENDMSG, sParam1);
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.REFINEWEAPON.sCmd) = 0 then
      begin
        CmdRefineWeapon(@g_GameCommand.REFINEWEAPON, Str_ToInt(sParam1, 0),
          Str_ToInt(sParam2, 0), Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
        exit;
      end;
      if CompareText(sCMD, g_GameCommand.DISABLESENDMSGLIST.sCmd) = 0 then
      begin
        CmdDisableSendMsgList(@g_GameCommand.DISABLESENDMSGLIST);
        exit;
      end;
      if m_btPermission > 4 then
      begin
        if CompareText(sCMD, g_GameCommand.BACKSTEP.sCmd) = 0 then
        begin
          CmdBackStep(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 1));
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.BALL.sCmd) = 0 then
        begin //精神波
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.CHANGELUCK.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.HUNGER.sCmd) = 0 then
        begin
          CmdHunger(g_GameCommand.HUNGER.sCmd, sParam1, Str_ToInt(sParam2, 0));
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.NAMECOLOR.sCmd) = 0 then
        begin
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.TRANSPARECY.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.LEVEL0.sCmd) = 0 then
        begin
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.SETFLAG.sCmd) = 0 then
        begin //004D3BDD
          PlayObject := UserEngine.GeTPlayObject(sParam1);
          if PlayObject <> nil then
          begin
            nFlag := Str_ToInt(sParam2, 0);
            nValue := Str_ToInt(sParam3, 0);
            PlayObject.SetQuestFlagStatus(nFlag, nValue);
            if PlayObject.GetQuestFalgStatus(nFlag) = 1 then
            begin
              SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) +
                '] = ON', c_Green, t_Hint);
            end
            else
            begin
              SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) +
                '] = OFF', c_Green, t_Hint);
            end;
          end
          else
          begin
            SysMsg('@' + g_GameCommand.SETFLAG.sCmd +
              ' 人物名称 标志号 数字(0 - 1)', c_Red, t_Hint);
          end;
          exit;
        end;
        {if CompareText(sCMD,g_GameCommand.SETOPEN.sCmd) = 0 then begin
          PlayObject:=UserEngine.GeTPlayObject(sParam1);
          if PlayObject <> nil then begin
            nFlag:=Str_ToInt(sParam2,0);
            nValue:=Str_ToInt(sParam3,0);
            PlayObject.SetQuestUnitOpenStatus(nFlag,nValue);
            if PlayObject.GetQuestUnitOpenStatus(nFlag) = 1 then begin
              SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON',c_Green,t_Hint);
            end else begin
              SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF',c_Green,t_Hint);
            end;
          end else begin
            SysMsg('@' + g_GameCommand.SETOPEN.sCmd + ' 人物名称 标志号 数字(0 - 1)',c_Red,t_Hint);
          end;
          exit;
        end;  }
        {if CompareText(sCMD,g_GameCommand.SETUNIT.sCmd) = 0 then begin
          PlayObject:=UserEngine.GeTPlayObject(sParam1);
          if PlayObject <> nil then begin
            nFlag:=Str_ToInt(sParam2,0);
            nValue:=Str_ToInt(sParam3,0);
            PlayObject.SetQuestUnitStatus(nFlag,nValue);
            if PlayObject.GetQuestUnitStatus(nFlag) = 1 then begin
              SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = ON',c_Green,t_Hint);
            end else begin
              SysMsg(PlayObject.m_sCharName + ': [' + IntToStr(nFlag) + '] = OFF',c_Green,t_Hint);
            end;
          end else begin
            SysMsg('@' + g_GameCommand.SETUNIT.sCmd + ' 人物名称 标志号 数字(0 - 1)',c_Red,t_Hint);
          end;
          exit;
        end; }
        if CompareText(sCMD, g_GameCommand.RECONNECTION.sCmd) = 0 then
        begin
          CmdReconnection(sCmd, sParam1, sParam2);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.DISABLEFILTER.sCmd) = 0 then
        begin
          CmdDisableFilter(sCmd, sParam1);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.CHGUSERFULL.sCmd) = 0 then
        begin
          CmdChangeUserFull(sCmd, sParam1);
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.CHGZENFASTSTEP.sCmd) = 0 then
        begin
          CmdChangeZenFastStep(sCmd, sParam1);
          exit;
        end;

        if CompareText(sCMD, g_GameCommand.OXQUIZROOM.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.GSA.sCmd) = 0 then
        begin
          exit;
        end;
        if CompareText(sCMD, g_GameCommand.CHANGEITEMNAME.sCmd) = 0 then
        begin
          CmdChangeItemName(g_GameCommand.CHANGEITEMNAME.sCmd, sParam1, sParam2,
            sParam3);
          exit;
        end;
        if (m_btPermission >= 5) or (g_Config.boTestServer) then
        begin

          if CompareText(sCMD, g_GameCommand.FIREBURN.sCmd) = 0 then
          begin
            CmdFireBurn(Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0),
              Str_ToInt(sParam3, 0));
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.TESTFIRE.sCmd) = 0 then
          begin
            CmdTestFire(sCmd, Str_ToInt(sParam1, 0), Str_ToInt(sParam2, 0),
              Str_ToInt(sParam3, 0), Str_ToInt(sParam4, 0));
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.TESTSTATUS.sCmd) = 0 then
          begin
            CmdTestStatus(sCmd, Str_ToInt(sParam1, -1), Str_ToInt(sParam2, 0));
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.DELGAMEGOLD.sCmd) = 0 then
          begin
            CmdDelGameGold(g_GameCommand.DELGAMEGOLD.sCmd, sParam1,
              Str_ToInt(sParam2, 0));
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.ADDGAMEGOLD.sCmd) = 0 then
          begin
            CmdAddGameGold(g_GameCommand.ADDGAMEGOLD.sCmd, sParam1,
              Str_ToInt(sParam2, 0));
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.TESTGOLDCHANGE.sCmd) = 0 then
          begin
            exit;
          end;

          if CompareText(sCMD, g_GameCommand.RELOADADMIN.sCmd) = 0 then
          begin
            CmdReLoadAdmin(g_GameCommand.RELOADADMIN.sCmd);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADNPC.sCmd) = 0 then
          begin
            CmdReloadNpc(sParam1);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADMANAGE.sCmd) = 0 then
          begin
            CmdReloadManage(@g_GameCommand.RELOADMANAGE, sParam1);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADROBOTMANAGE.sCmd) = 0 then
          begin
            CmdReloadRobotManage();
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADROBOT.sCmd) = 0 then
          begin
            CmdReloadRobot();
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADMONITEMS.sCmd) = 0 then
          begin
            CmdReLoadMonitems();
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADDIARY.sCmd) = 0 then
          begin
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADITEMDB.sCmd) = 0 then
          begin
            FrmDB.LoadItemsDB();
            SysMsg('物品数据库重新加载完成。', c_Green, t_Hint);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADMAGICDB.sCmd) = 0 then
          begin
            FrmDB.LoadMagicDB();
            SysMsg('魔法数据库重新加载完成。', c_Green, t_Hint);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADMONSTERDB.sCmd) = 0 then
          begin
            FrmDB.LoadMonsterDB();
            SysMsg('怪物数据库重新加载完成。', c_Green, t_Hint);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.RELOADMINMAP.sCmd) = 0 then
          begin
            FrmDB.LoadMiniMap();
            g_MapManager.ReSetMinMap();
            SysMsg('小地图配置重新加载完成。', c_Green, t_Hint);
            exit;
          end;

          if CompareText(sCMD, g_GameCommand.ADJUESTLEVEL.sCmd) = 0 then
          begin
            CmdAdjuestLevel(@g_GameCommand.ADJUESTLEVEL, sParam1,
              Str_ToInt(sParam2, 1));
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.ADJUESTEXP.sCmd) = 0 then
          begin
            CmdAdjuestExp(@g_GameCommand.ADJUESTEXP, sParam1, sParam2);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.ADDGUILD.sCmd) = 0 then
          begin
            CmdAddGuild(@g_GameCommand.ADDGUILD, sParam1, sParam2);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.DELGUILD.sCmd) = 0 then
          begin
            CmdDelGuild(@g_GameCommand.DELGUILD, sParam1);
            exit;
          end;
          if (CompareText(sCMD, g_GameCommand.CHANGESABUKLORD.sCmd) = 0) then
          begin
            CmdChangeSabukLord(@g_GameCommand.CHANGESABUKLORD, sParam1, sParam2,
              True);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.FORCEDWALLCONQUESTWAR.sCmd) = 0
            then
          begin
            CmdForcedWallconquestWar(@g_GameCommand.FORCEDWALLCONQUESTWAR,
              sParam1);
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.ADDTOITEMEVENT.sCmd) = 0 then
          begin
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.ADDTOITEMEVENTASPIECES.sCmd) = 0
            then
          begin
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.ITEMEVENTLIST.sCmd) = 0 then
          begin
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.STARTINGGIFTNO.sCmd) = 0 then
          begin
            exit;
          end;
          if CompareText(sCMD, g_GameCommand.DELETEALLITEMEVENT.sCmd) = 0 then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.STARTITEMEVENT.sCmd) = 0 then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.ITEMEVENTTERM.sCmd) = 0 then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.ADJUESTTESTLEVEL.sCmd) = 0
            then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.OPDELETESKILL.sCmd) = 0 then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.CHANGEWEAPONDURA.sCmd) = 0
            then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.RELOADGUILDALL.sCmd) = 0 then
          begin
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.SPIRIT.sCmd) = 0 then
          begin
            CmdSpirtStart(g_GameCommand.SPIRIT.sCmd, sParam1);
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.SPIRITSTOP.sCmd) = 0 then
          begin
            CmdSpirtStop(g_GameCommand.SPIRITSTOP.sCmd, sParam1);
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.TESTSERVERCONFIG.sCmd) = 0
            then
          begin
            SendServerConfig();
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.SERVERSTATUS.sCmd) = 0 then
          begin
            SendServerStatus();
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.TESTGETBAGITEM.sCmd) = 0 then
          begin
            CmdTestGetBagItems(@g_GameCommand.TESTGETBAGITEM, sParam1);
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.MOBFIREBURN.sCmd) = 0 then
          begin
            CmdMobFireBurn(@g_GameCommand.MOBFIREBURN, sParam1, sParam2,
              sParam3, sParam4, sParam5, sParam6);
            exit;
          end
          else if CompareText(sCMD, g_GameCommand.TESTSPEEDMODE.sCmd) = 0 then
          begin
            CmdTestSpeedMode(@g_GameCommand.TESTSPEEDMODE);
            exit;
          end
        end;
      end; //004D52B5
      SysMsg('@' + sCMD +
        ' 此命令不正确，或没有足够的权限！！！', c_Red,
        t_Hint);
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg, [sData]));
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ProcessUserLineMsg');
  end;
end;
// else begin//004D4D8B

procedure TPlayObject.ProcessSayMsg(sData: string);
var
  boDisableSayMsg: Boolean;
  sC, sCryCryMsg, sParam1: string;
  sDestMsg: array[0..80] of Char;
  //  I:integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject.ProcessSayMsg Msg = %s';
begin
  try
    try
      try
        if Assigned(m_HookFilterMsg) then
        begin
          //GetMem(sDestMsg,80);
          m_HookFilterMsg(Self, PChar(sData), @sDestMsg, SizeOf(sDestMsg));
          sData := string(sDestMsg);
          //FreeMem(sDestMsg);
        end;
      except
        MainOutMessage('[Exception] TPlayObject.ProcessSayMsg->HookApi');
      end;
      if length(sData) > g_Config.nSayMsgMaxLen then
      begin
        sData := Copy(sData, 1, g_Config.nSayMsgMaxLen);
      end;

      if {(sData = m_sOldSayMsg) and}((GetTickCount - m_dwSayMsgTick) <
        g_Config.dwSayMsgTime {3 * 1000}) then
      begin
        Inc(m_nSayMsgCount);
        if m_nSayMsgCount >= g_Config.nSayMsgCount {2} then
        begin
          m_boDisableSayMsg := True;
          m_dwDisableSayMsgTick := GetTickCount + g_Config.dwDisableSayMsgTime
            {60 * 1000};
          SysMsg(format(g_sDisableSayMsg, [g_Config.dwDisableSayMsgTime div (60
              * 1000)]), c_Red, t_Hint);
          //'[由于你重复发相同的内容，%d分钟内你将被禁止发言...]'
        end;
      end
      else
      begin //004D4DF6
        m_dwSayMsgTick := GetTickCount();
        m_nSayMsgCount := 0;
      end;

      if GetTickCount >= m_dwDisableSayMsgTick then
        m_boDisableSayMsg := False;
      boDisableSayMsg := m_boDisableSayMsg;
      g_DenySayMsgList.Lock;
      try
        if g_DenySayMsgList.GetIndex(m_sCharName) >= 0 then
          boDisableSayMsg := True;
      finally
        g_DenySayMsgList.UnLock;
      end;

      if not (boDisableSayMsg or m_PEnvir.Flag.boNOCHAT) then
      begin
        //Log it..
        try
          g_ChatLoggingList.Lock;
          g_ChatLoggingList.Add('[' + DateTimeToStr(Now) + '] ' + m_sCharName +
            ': ' + sData);
        finally
          g_ChatLoggingList.unLock;
        end;

        m_sOldSayMsg := sData;
        //MainOutMessage(sData);
        if sData[1] = '/' then
        begin
          sC := Copy(sData, 2, length(sData) - 1);
          //MainOutMessage(sc);
          if CompareText(Trim(sC), Trim(g_GameCommand.WHO.sCmd)) = 0 then
          begin
            if (m_btPermission < g_GameCommand.WHO.nPermissionMin) then
            begin
              SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
              exit;
            end;
            //MainOutMessage(sc);
            HearMsg(format(g_sOnlineCountMsg, [UserEngine.PlayObjectCount,
              (UserEngine.PlayObjectCount - UserEngine.OffLinePlayCount),
                UserEngine.OffLinePlayCount]));
            exit;
          end; //004D4F03
          if CompareText(Trim(sC), Trim(g_GameCommand.TOTAL.sCmd)) = 0 then
          begin
            if (m_btPermission < g_GameCommand.TOTAL.nPermissionMin) then
            begin
              SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
              exit;
            end;
            HearMsg(format(g_sTotalOnlineCountMsg, [g_nTotalHumCount]));
            exit;
          end; //004D4F5B
          sC := GetValidStr3(sC, sParam1, [' ']);
          if not m_boFilterSendMsg then
            Whisper(sParam1, sC);
          exit;
        end;
        if sData[1] = '!' then
        begin
          if length(sData) >= 2 then
          begin
            if sData[2] = '!' then
            begin
              sC := Copy(sData, 3, length(sData) - 2);
              SendGroupText(m_sCharName + ': ' + sC);
              exit;
            end;
            if sData[2] = '~' then
            begin
              if m_MyGuild <> nil then
              begin
                sC := Copy(sData, 3, length(sData) - 2);
                TGuild(m_MyGuild).SendGuildMsg(m_sCharName + ': ' + sC);
                UserEngine.SendServerGroupMsg(SS_208, nServerIndex,
                  TGuild(m_MyGuild).sGuildName + '/' + m_sCharName + '/' + sC);
              end;
              exit;
            end;
          end; //004D512C
          if not m_PEnvir.Flag.boQUIZ then
          begin
            if (GetTickCount - m_dwShoutMsgTick) > 10 * 1000 then
            begin
              if m_Abil.Level <= g_Config.nCanShoutMsgLevel then
              begin
                //SysMsg('你的等级要在' + IntToStr(g_nCanShoutMsgLevel + 1) + '级以上才能用此功能！！！',c_Red,t_Hint);
                SysMsg(format(g_sYouNeedLevelMsg, [g_Config.nCanShoutMsgLevel +
                  1]), c_Red, t_Hint);

                exit;
              end;
              m_dwShoutMsgTick := GetTickCount();
              sC := Copy(sData, 2, length(sData) - 1);
              sCryCryMsg := '(!)' + m_sCharName + ': ' + sC;
              if m_boFilterSendMsg then
              begin
                SendMsg(nil, RM_CRY, 0, 0, $FFFF, 0, sCryCryMsg);
              end
              else
              begin
                UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 50,
                  g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, sCryCryMsg);
              end;
              exit;
            end;
            //SysMsg(IntToStr(10 - (GetTickCount - m_dwShoutMsgTick) div 1000) + '  Secondstillyoucanshout.',c_Red,t_Hint);
            SysMsg(format(g_sYouCanSendCyCyLaterMsg, [10 - (GetTickCount -
                m_dwShoutMsgTick) div 1000]), c_Red, t_Hint);

            exit;
          end;
          SysMsg(g_sThisMapDisableSendCyCyMsg
            {'本地图不允许喊话！！！'}, c_Red, t_Hint);
          exit;
        end; //004D5299
        if m_boFilterSendMsg then
        begin //如果禁止发信息，则只向自己发信息
          SendMsg(Self, RM_HEAR, 0, g_Config.btHearMsgFColor,
            g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sData);
        end
        else
        begin
          inherited;
        end;
        //      ProcessSayMsg(sData);
        exit;
      end;
      SysMsg(g_sYouIsDisableSendMsg {'禁止聊天'}, c_Red, t_Hint);
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg, [sData]));
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ProcessSayMsg');
  end;
end;

function TPlayObject.ClientHitXY(wIdent: Word; nX, nY, nDir: Integer;
  boLateDelivery: Boolean; var dwDelayTime: LongWord): Boolean; //004CB7F8
var
  n14, n18: Integer;
  StdItem: TItem;
  dwAttackTime, dwCheckTime: LongWord;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ClientHitXY';
begin
  try

    Result := False;
    dwDelayTime := 0;
    try
      if not m_boCanHit then
        exit;

      if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
        g_Config.ClientConf.boParalyCanHit) then
        exit; //防麻
      if not boLateDelivery then
      begin
        if not CheckActionStatus(wIdent, dwDelayTime) then
        begin
          m_boFilterAction := False;
          exit;
        end;
        m_boFilterAction := True;
        dwAttackTime := _MAX(0, Integer(g_Config.dwHitIntervalTime) - m_nHitSpeed
          * g_Config.ClientConf.btItemSpeed); //防止负数出错
        dwCheckTime := GetTickCount - m_dwAttackTick;
        if dwCheckTime < dwAttackTime then
        begin
          Inc(m_dwAttackCount);
          dwDelayTime := dwAttackTime - dwCheckTime;
          if dwDelayTime > g_Config.dwDropOverSpeed then
          begin
            if m_dwAttackCount >= 4 then
            begin
              m_dwAttackTick := GetTickCount();
              m_dwAttackCount := 0;
              dwDelayTime := g_Config.dwDropOverSpeed;
              if m_boTestSpeedMode then
                SysMsg('攻击忙复位！！！' + IntTOStr(dwDelayTime),
                  c_Red, t_Hint);
            end
            else
              m_dwAttackCount := 0;
            exit;
          end
          else
          begin
            if m_boTestSpeedMode then
              SysMsg('攻击步忙！！！' + IntTOStr(dwDelayTime), c_Red,
                t_Hint);
            exit;
          end;
        end;
      end;
      {
      if (GetTickCount - m_dwAttackTick) > (900 - m_btHitSpeed * 60) then begin
        m_dwAttackCount:=0;
        if m_dwAttackCountA > 0 then Dec(m_dwAttackCountA);
      end else begin
        Inc(m_dwAttackCount);
        Inc(m_dwAttackCountA);
      end;

      if (m_dwAttackCount >= 4) or (m_dwAttackCountA >= 6) then begin
        m_dwAttackTick:=GetTickCount();
        Inc(m_dwOverSpeedCount);
        //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
        SysMsg('攻击超速！！！',c_Red,t_Hint);
        if boViewHackMessage then
          MainOutMessage('[11000-Hit] ' + m_sCharName + ' ' + DateToStr(Now));
        exit;
      end;
      }
    //  if not m_boDeath then begin
      if (nX = m_nCurrX) and (nY = m_nCurrY) then
      begin
        Result := True;
        m_dwAttackTick := GetTickCount();
        if (wIdent = CM_HEAVYHIT) and (m_UseItems[U_WEAPON].Dura > 0) then
        begin //挖矿
          if GetFrontPosition(n14, n18) and not m_PEnvir.CanWalk(n14, n18, False)
            then
          begin //sub_004B2790
            StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
            if (StdItem <> nil) and (StdItem.Shape = 19) then
            begin
              if PileStones2(n14, n18) then
                SendSocket(nil, '=DIG');
              Dec(m_nHealthTick, 30);
              Dec(m_nSpellTick, 50);
              m_nSpellTick := _MAX(0, m_nSpellTick);
              Dec(m_nPerHealth, 2);
              Dec(m_nPerSpell, 2);
              exit;
            end;
          end;
        end;
        if wIdent = CM_HIT then
          AttackDir(nil, 0, nDir); //基本攻击
        if wIdent = CM_HEAVYHIT then
          AttackDir(nil, 1, nDir);
        if wIdent = CM_BIGHIT then
          AttackDir(nil, 2, nDir);
        if wIdent = CM_POWERHIT then
          AttackDir(nil, 3, nDir);
        if wIdent = CM_LONGHIT then
          AttackDir(nil, 4, nDir); //刺杀剑法
        if wIdent = CM_WIDEHIT then
          AttackDir(nil, 5, nDir); //半月
        if wIdent = CM_FIREHIT then
          AttackDir(nil, 7, nDir); //烈火
        if wIdent = CM_CRSHIT then
          AttackDir(nil, 8, nDir);
        if wIdent = CM_TWINHIT then
          AttackDir(nil, 9, nDir);
        if wIdent = CM_LONGSWORD1 then
          AttackDir(nil, 10, nDir);
        if wIdent = CM_LONGSWORD2 then
          AttackDir(nil, 11, nDir);
        if wIdent = CM_LONGFIRESWORD then
          AttackDir(nil, 13, nDir);
        if (m_MagicPowerHitSkill <> nil) and (m_UseItems[U_WEAPON].Dura > 0)
          then
        begin
          Dec(m_btAttackSkillCount);
          if m_btAttackSkillPointCount = m_btAttackSkillCount then
          begin
            m_boPowerHit := True;
            SendSocket(nil, '+PWR');
          end;
          if m_btAttackSkillCount <= 0 then
          begin
            m_btAttackSkillCount := 7 - m_MagicPowerHitSkill.btLevel;
            m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
          end;
        end;
        Dec(m_nHealthTick, 30);
        Dec(m_nSpellTick, 100);
        m_nSpellTick := _MAX(0, m_nSpellTick);
        Dec(m_nPerHealth, 2);
        Dec(m_nPerSpell, 2); //004CBB62
      end;
      //  end else Result:=False;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg);
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientHitXY');
  end;
end;

function TPlayObject.ClientHorseRunXY(wIdent: Word; nX, nY: Integer;
  boLateDelivery: Boolean;
  var dwDelayTime: LongWord): Boolean;
var
  n14: Integer;
  dwCheckTime: LongWord;
begin
  try
    Result := False;
    dwDelayTime := 0;

    if not m_boCanRun then
      exit;
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
      g_Config.ClientConf.boParalyCanRun) then
      exit; //防麻
    if not boLateDelivery then
    begin

      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMoveTick;
      if dwCheckTime < g_Config.dwRunIntervalTime then
      begin
        Inc(m_dwMoveCount);
        dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
        if dwDelayTime > g_Config.dwDropOverSpeed then
        begin
          if m_dwMoveCount >= 4 then
          begin
            m_dwMoveTick := GetTickCount();
            m_dwMoveCount := 0;
            dwDelayTime := g_Config.dwDropOverSpeed;
            if m_boTestSpeedMode then
              SysMsg('马跑步忙复位！！！' + IntTOStr(dwDelayTime),
                c_Red, t_Hint);
          end
          else
            m_dwMoveCount := 0;
          exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('马跑步忙！！！' + IntTOStr(dwDelayTime), c_Red,
              t_Hint);
          exit;
        end;
      end;
    end;

    m_dwMoveTick := GetTickCount();
    m_bo316 := False;
{$IF DEBUG = 1}
    SysMsg(format('当前X:%d 当前Y:%d 目标X:%d 目标Y:%d', [m_nCurrX,
      m_nCurrY, nX, nY]), c_Green, t_Hint);
{$IFEND}
    n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
    if HorseRunTo(n14, False) then
    begin
      if m_boTransparent and (m_boHideMode) then
        m_wStatusTimeArr[STATE_TRANSPARENT {0 0x70}] := 1; //004CB212

      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result := True;
      Dec(m_nHealthTick, 60);
      Dec(m_nSpellTick, 10);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth);
      Dec(m_nPerSpell);
      //MapEventCheck(OS_HORSERUN,'');    //地图事件触发
    end
    else
    begin
      m_dwMoveCount := 0;
      m_dwMoveCountA := 0;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientHorseRunXY');
  end;
end;

function TPlayObject.ClientSpellXY(wIdent: Word; nKey: Integer; nTargetX,
  nTargetY: Integer; TargeTBaseObject: TBaseObject; boLateDelivery: Boolean; var
  dwDelayTime: LongWord): Boolean; //004CBCEC
var
  UserMagic: pTUserMagic;
  nSpellPoint: Integer;
  n14: Integer;
  BaseObject: TBaseObject;
  dwCheckTime: LongWord;
  boIsWarrSkill: Boolean;
begin
  try
    Result := False;
    dwDelayTime := 0;

    if not m_boCanSpell then
      exit;
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
      g_Config.ClientConf.boParalyCanSpell) then
      exit; //防麻

    UserMagic := GetMagicInfo(nKey);
    if UserMagic = nil then
      exit;
    if m_PEnvir.Flag.boMission then
    begin
      SysMsg('本地图不允许使用任何技能！！！', c_Red, t_System);
      exit;
    end;
    if m_PEnvir.Flag.boNOTALLOWUSEMAGIC then
    begin
      if m_PEnvir.CheckNotMagic(UserMagic.MagicInfo.sMagicName) then
      begin
        SysMsg(Format('本地图不允许使用技能[%s]！！！',
          [UserMagic.MagicInfo.sMagicName]), c_Red, t_System);
        exit;
      end;
    end;
    boIsWarrSkill := MagicManager.IsWarrSkill(UserMagic.wMagIdx);

    if not boLateDelivery and not boIsWarrSkill then
    begin
      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMagicAttackTick;
      if dwCheckTime < m_dwMagicAttackInterval then
      begin
        Inc(m_dwMagicAttackCount);
        dwDelayTime := m_dwMagicAttackInterval - dwCheckTime;
        if dwDelayTime > g_Config.dwMagicHitIntervalTime div 3 then
        begin
          if m_dwMagicAttackCount >= 4 then
          begin
            m_dwMagicAttackTick := GetTickCount();
            m_dwMagicAttackCount := 0;
            dwDelayTime := g_Config.dwMagicHitIntervalTime div 3;
            if m_boTestSpeedMode then
              SysMsg('魔法忙复位！！！' + IntTOStr(dwDelayTime), c_Red,
                t_Hint);
          end
          else
            m_dwMagicAttackCount := 0;
          exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('魔法忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
          exit;
        end;
      end;
    end;

    Dec(m_nSpellTick, 450);
    m_nSpellTick := _MAX(0, m_nSpellTick);

    if boIsWarrSkill then
    begin
      //m_dwMagicAttackInterval:=0;
      //m_dwMagicAttackInterval:=g_Config.dwMagicHitIntervalTime; //01/21 改成此行
    end
    else
    begin
      m_dwMagicAttackInterval := LongWord(UserMagic.MagicInfo.dwDelayTime) +
        g_Config.dwMagicHitIntervalTime;
    end;
    m_dwMagicAttackTick := GetTickCount();
    case UserMagic.wMagIdx of //
      SKILL_ERGUM {12}:
        begin //刺杀剑法
          if m_MagicErgumSkill <> nil then
          begin
            if not m_boUseThrusting then
            begin
              ThrustingOnOff(True);
              SendSocket(nil, '+LNG');
            end
            else
            begin
              ThrustingOnOff(False);
              SendSocket(nil, '+ULNG');
            end;
          end;
          Result := True;
        end;
      SKILL_BANWOL {25}:
        begin //半月弯刀
          {if m_MagicCrsSkill <> nil then begin
            if m_boCrsHitkill then begin
              SkillCrsOnOff(False);
              SendSocket(nil,'+UCRS');
            end;
          end;}

          if m_MagicBanwolSkill <> nil then
          begin
            if not m_boUseHalfMoon then
            begin
              HalfMoonOnOff(True);
              SendSocket(nil, '+WID');
            end
            else
            begin
              HalfMoonOnOff(False);
              SendSocket(nil, '+UWID');
            end;
          end;
          Result := True;
        end;
      SKILL_REDBANWOL {56}:
        begin
          if m_MagicRedBanwolSkill <> nil then
          begin
            if not m_boRedUseHalfMoon then
            begin
              RedHalfMoonOnOff(True);
              SendSocket(nil, '+WID');
            end
            else
            begin
              RedHalfMoonOnOff(False);
              SendSocket(nil, '+UWID');
            end;
          end;
          Result := True;
        end;
      SKILL_73 {73}:
        begin //逐日剑法
          if m_MagicLongFireSwordSkill <> nil then
          begin
            if AllowLongFireHitSkill then
            begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil, '+LFIR');
              end;
            end;
          end;
          Result := True;
        end;
      SKILL_FIRESWORD {26}:
        begin //烈火剑法
          if m_MagicFireSwordSkill <> nil then
          begin
            if AllowFireHitSkill then
            begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil, '+FIR');
              end;
            end;
          end;
          Result := True;
        end;
      SKILL_MOOTEBO {27}:
        begin //野蛮冲撞
          Result := True;
          if (GetTickCount - m_dwDoMotaeboTick) > 3 * 1000 then
          begin
            m_dwDoMotaeboTick := GetTickCount();
            m_btDirection := nTargetX;
            nSpellPoint := GetSpellPoint(UserMagic);
            if m_WAbil.MP >= nSpellPoint then
            begin
              if nSpellPoint > 0 then
              begin
                DamageSpell(nSpellPoint);
                HealthSpellChanged();
              end;
              if DoMotaebo(m_btDirection, UserMagic.btLevel) then
              begin
                if UserMagic.btLevel < 3 then
                begin
                  if UserMagic.MagicInfo.TrainLevel[UserMagic.btLevel] <
                    m_Abil.Level then
                  begin
                    TrainSkill(UserMagic, Random(3) + 1);
                    if not CheckMagicLevelup(UserMagic) then
                    begin

                      SendDelayMsg(Self,
                        RM_MAGIC_LVEXP,
                        0,
                        UserMagic.MagicInfo.wMagicId,
                        UserMagic.btLevel,
                        UserMagic.nTranPoint,
                        '', 1000);
                    end;
                  end;
                end;
              end;
            end;
          end; //004CC1B5
        end;
      SKILL_CROSSMOON:
        begin //抱月刀法

          if m_MagicCrsSkill <> nil then
          begin
            if not m_boCrsHitkill then
            begin
              SkillCrsOnOff(True);
              SendSocket(nil, '+CRS');
            end
            else
            begin
              SkillCrsOnOff(False);
              SendSocket(nil, '+UCRS');
            end;
          end;
          Result := True;
        end;
      SKILL_TWINBLADE:
        begin //狂风斩
          AllowTwinHitSkill;
          Result := True;
          {if m_MagicTwnHitSkill <> nil then begin
            if AllowTwinHitSkill then begin
              nSpellPoint:=GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then begin
                if nSpellPoint > 0 then begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                SendSocket(nil,'+TWN');
              end;
            end;
          end; }

          {if m_MagicTwnHitSkill <> nil then begin
            if not m_boTwinHitSkill then begin
              SkillTwinOnOff(True);
              SendSocket(nil,'+TWN');
            end else begin
              SkillTwinOnOff(False);
              SendSocket(nil,'+UTWN');
            end;
          end;
          Result:=True;}
        end;
      43:
        begin //开天斩
          if m_MagicLongSwordSkill <> nil then
          begin
            if AllowLongSwordSkill then
            begin
              nSpellPoint := GetSpellPoint(UserMagic);
              if m_WAbil.MP >= nSpellPoint then
              begin
                if nSpellPoint > 0 then
                begin
                  DamageSpell(nSpellPoint);
                  HealthSpellChanged();
                end;
                if m_boLongSwordSkillCls then
                  SendSocket(nil, '+LZW')
                else
                  SendSocket(nil, '+LAW');
              end;
            end;
          end;
          Result := True;
          {if m_MagicLongSwordSkill <> nil then begin
            if not m_bo43kill then begin
              Skill43OnOff(True);
              SendSocket(nil,'+CID');
            end else begin
              Skill43OnOff(False);
              SendSocket(nil,'+UCID');
            end;
          end;
          Result:=True;}
        end;
    else
      begin
        n14 := GetNextDirection(m_nCurrX, m_nCurrY, nTargetX, nTargetY);
        m_btDirection := n14;
        BaseObject := nil;
        //检查目标角色，与目标座标误差范围，如果在误差范围内则修正目标座标
        if CretInNearXY(TargeTBaseObject, nTargetX, nTargetY) then
        begin
          BaseObject := TargeTBaseObject;
          nTargetX := BaseObject.m_nCurrX;
          nTargetY := BaseObject.m_nCurrY;
        end;

        if not DoSpell(UserMagic, nTargetX, nTargetY, BaseObject) then
        begin
          SendRefMsg(RM_MAGICFIREFAIL, 0, 0, 0, 0, '');
        end;
        Result := True;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientSpellXY');
  end;
end;

//004C42C0

function TBaseObject.RunTo(btDir: Byte; boFlag: boolean; nDestX, nDestY:
  Integer): Boolean;
var
  nOldX, nOldY: Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::RunTo';
begin
  try
    Result := False;
    try
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      m_btDirection := btDir;
      case btDir of
        DR_UP {0}:
          begin
            if (m_nCurrY > 1) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY - 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY - 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX,
              m_nCurrY - 2, True) > 0) then
            begin

              Dec(m_nCurrY, 2);
            end;
          end;
        DR_UPRIGHT {1}:
          begin
            if (m_nCurrX < m_PEnvir.Header.wWidth - 2) and
              (m_nCurrY > 1) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 1, m_nCurrY - 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 2, m_nCurrY - 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX +
              2, m_nCurrY - 2, True) > 0) then
            begin

              Inc(m_nCurrX, 2);
              Dec(m_nCurrY, 2);
            end;
          end;
        DR_RIGHT {2}:
          begin
            if (m_nCurrX < m_PEnvir.Header.wWidth - 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 1, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 2, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX +
              2, m_nCurrY, True) > 0) then
            begin

              Inc(m_nCurrX, 2);
            end;
          end;
        DR_DOWNRIGHT {3}:
          begin
            if (m_nCurrX < m_PEnvir.Header.wWidth - 2) and
              (m_nCurrY < m_PEnvir.Header.wHeight - 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 1, m_nCurrY + 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 2, m_nCurrY + 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX +
              2, m_nCurrY + 2, True) > 0) then
            begin

              Inc(m_nCurrX, 2);
              Inc(m_nCurrY, 2);
            end;
          end;
        DR_DOWN {4}:
          begin
            if (m_nCurrY < m_PEnvir.Header.wHeight - 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY + 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY + 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX,
              m_nCurrY + 2, True) > 0) then
            begin

              Inc(m_nCurrY, 2);
            end;
          end;
        DR_DOWNLEFT {5}:
          begin
            if (m_nCurrX > 1) and
              (m_nCurrY < m_PEnvir.Header.wHeight - 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 1, m_nCurrY + 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 2, m_nCurrY + 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX -
              2, m_nCurrY + 2, True) > 0) then
            begin

              Dec(m_nCurrX, 2);
              Inc(m_nCurrY, 2);
            end;
          end;
        DR_LEFT {6}:
          begin
            if (m_nCurrX > 1) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 1, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 2, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX -
              2, m_nCurrY, True) > 0) then
            begin

              Dec(m_nCurrX, 2);
            end;
          end;
        DR_UPLEFT {7}:
          begin
            if (m_nCurrX > 1) and
              (m_nCurrY > 1) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 1, m_nCurrY - 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 2, m_nCurrY - 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX -
              2, m_nCurrY - 2, True) > 0) then
            begin

              Dec(m_nCurrX, 2);
              Dec(m_nCurrY, 2);
            end;
          end;
      end;
      if ((m_nCurrX <> nOldX) or (m_nCurrY <> nOldY))
        {and ((m_nCurrX = nDestX) and (m_nCurrY = nDestY))}then
      begin
        if Walk(RM_RUN) then
          Result := True
        else
        begin
          m_nCurrX := nOldX;
          m_nCurrY := nOldY;
          m_PEnvir.MoveToMovingObject(nOldX, nOldY, Self, m_nCurrX, m_nCurrX,
            True);
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.RunTo');
  end;
end;

//004C42C0

function TPlayObject.HorseRunTo(btDir: Byte; boFlag: boolean): Boolean;
var
  n10, n14: Integer;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::HorseRunTo';
begin
  try
    Result := False;
    try
      n10 := m_nCurrX;
      n14 := m_nCurrY;
      m_btDirection := btDir;
      case btDir of
        DR_UP {0}:
          begin
            if (m_nCurrY > 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY - 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY - 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY - 3,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX,
              m_nCurrY - 3, True) > 0) then
            begin

              Dec(m_nCurrY, 3);
            end;
          end;
        DR_UPRIGHT {1}:
          begin
            if (m_nCurrX < m_PEnvir.Header.wWidth - 3) and
              (m_nCurrY > 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 1, m_nCurrY - 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 2, m_nCurrY - 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 3, m_nCurrY - 3,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX +
              3, m_nCurrY - 3, True) > 0) then
            begin

              Inc(m_nCurrX, 3);
              Dec(m_nCurrY, 3);
            end;
          end;
        DR_RIGHT {2}:
          begin
            if (m_nCurrX < m_PEnvir.Header.wWidth - 3) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 1, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 2, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 3, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX +
              3, m_nCurrY, True) > 0) then
            begin

              Inc(m_nCurrX, 3);
            end;
          end;
        DR_DOWNRIGHT {3}:
          begin
            if (m_nCurrX < m_PEnvir.Header.wWidth - 3) and
              (m_nCurrY < m_PEnvir.Header.wHeight - 3) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 1, m_nCurrY + 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 2, m_nCurrY + 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX + 3, m_nCurrY + 3,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX +
              3, m_nCurrY + 3, True) > 0) then
            begin

              Inc(m_nCurrX, 3);
              Inc(m_nCurrY, 3);
            end;
          end;
        DR_DOWN {4}:
          begin
            if (m_nCurrY < m_PEnvir.Header.wHeight - 3) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY + 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY + 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX, m_nCurrY + 3,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX,
              m_nCurrY + 3, True) > 0) then
            begin

              Inc(m_nCurrY, 3);
            end;
          end;
        DR_DOWNLEFT {5}:
          begin
            if (m_nCurrX > 2) and
              (m_nCurrY < m_PEnvir.Header.wHeight - 3) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 1, m_nCurrY + 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 2, m_nCurrY + 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 3, m_nCurrY + 3,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX -
              3, m_nCurrY + 3, True) > 0) then
            begin

              Dec(m_nCurrX, 3);
              Inc(m_nCurrY, 3);
            end;
          end;
        DR_LEFT {6}:
          begin
            if (m_nCurrX > 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 1, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 2, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 3, m_nCurrY,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX -
              3, m_nCurrY, True) > 0) then
            begin

              Dec(m_nCurrX, 3);
            end;
          end;
        DR_UPLEFT {7}:
          begin
            if (m_nCurrX > 2) and
              (m_nCurrY > 2) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 1, m_nCurrY - 1,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 2, m_nCurrY - 2,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.CanWalkEx(Self, m_nCurrX - 3, m_nCurrY - 3,
              g_Config.boDiableHumanRun or ((m_btPermission > 9) and
              g_Config.boGMRunAll) {True})) and
              (m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, m_nCurrX -
              3, m_nCurrY - 3, True) > 0) then
            begin

              Dec(m_nCurrX, 3);
              Dec(m_nCurrY, 3);
            end;
          end;
      end;
      //    SysMsg(format('原X:%d 原Y:%d 新X:%d 新Y:%d',[n10,n14,m_nCurrX,m_nCurrY]),c_Green,t_Hint);
      if (m_nCurrX <> n10) or (m_nCurrY <> n14) then
      begin
        if Walk(RM_HORSERUN) then
          Result := True
        else
        begin
          m_nCurrX := n10;
          m_nCurrY := n14;
          m_PEnvir.MoveToMovingObject(n10, n14, Self, m_nCurrX, m_nCurrX, True)
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HorseRunTo');
  end;
end;

function TPlayObject.ClientRunXY(wIdent: Word; nX, nY: Integer; nFlag: Integer;
  var dwDelayTime: LongWord): Boolean; //004CB11C
var
  nDir: Integer;
  dwCheckTime: LongWord;
begin
  try
    Result := False;
    dwDelayTime := 0;
    if not m_boCanRun then
      exit;
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
      g_Config.ClientConf.boParalyCanRun) then
      exit; //防麻

    if nFlag <> wIdent then
    begin

      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMoveTick;
      if dwCheckTime < g_Config.dwRunIntervalTime then
      begin
        Inc(m_dwMoveCount);
        dwDelayTime := g_Config.dwRunIntervalTime - dwCheckTime;
        if dwDelayTime > g_Config.dwRunIntervalTime div 3 then
        begin
          if m_dwMoveCount >= 4 then
          begin
            m_dwMoveTick := GetTickCount();
            m_dwMoveCount := 0;
            dwDelayTime := g_Config.dwRunIntervalTime div 3;
            if m_boTestSpeedMode then
              SysMsg('跑步忙复位！！！' + IntTOStr(dwDelayTime), c_Red,
                t_Hint);
          end
          else
            m_dwMoveCount := 0;
          exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('跑步忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
          exit;
        end;
      end;
    end;
    {
    if (GetTickCount - m_dwMoveTick) < 600 then begin
      Inc(m_dwMoveCount);
      Inc(m_dwMoveCountA);
    end else begin
      m_dwMoveCount:=0;
      if m_dwMoveCountA > 0 then Dec(m_dwMoveCountA);
    end;
    }
    m_dwMoveTick := GetTickCount();
    //  if (m_dwMoveCount < 4) and (m_dwMoveCountA < 6) then begin
    m_bo316 := False;
    nDir := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
    if RunTo(nDir, False, nX, nY) then
    begin
      if m_boTransparent and (m_boHideMode) then
        m_wStatusTimeArr[STATE_TRANSPARENT {0 0x70}] := 1; //004CB212

      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result := True;
      Dec(m_nHealthTick, 60);
      Dec(m_nSpellTick, 10);
      m_nSpellTick := _MAX(0, m_nSpellTick);
      Dec(m_nPerHealth);
      Dec(m_nPerSpell);
      //MapEventCheck(OS_RUN,'');    //地图事件触发
    end
    else
    begin
      m_dwMoveCount := 0;
      m_dwMoveCountA := 0;
    end;
    {
      end else begin
        Inc(m_dwOverSpeedCount);
        //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
        SysMsg('跑步超速！！！',c_Red,t_Hint);
        if boViewHackMessage then begin
          MainOutMessage('[11002-Run] ' + m_sCharName + ' ' + DateToStr(Now));
        end;
      end;
    }
  except
    MainOutMessage('[Exception] TPlayObject.ClientRunXY');
  end;
end;

function TPlayObject.ClientWalkXY(wIdent: Word; nX, nY: Integer; boLateDelivery:
  Boolean; var dwDelayTime: LongWord): Boolean; //004CAF08
var
  n14: Integer;
  dwCheckTime: LongWord;
begin
  try
    Result := False;
    dwDelayTime := 0;
    if not m_boCanWalk then
      exit;
    if m_boDeath or ((m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) and not
      g_Config.ClientConf.boParalyCanWalk) then
      exit; //防麻

    if not boLateDelivery then
    begin
      if not CheckActionStatus(wIdent, dwDelayTime) then
      begin
        m_boFilterAction := False;
        exit;
      end;
      m_boFilterAction := True;
      dwCheckTime := GetTickCount - m_dwMoveTick;
      if dwCheckTime < g_Config.dwWalkIntervalTime then
      begin
        Inc(m_dwMoveCount);
        dwDelayTime := g_Config.dwWalkIntervalTime - dwCheckTime;
        if dwDelayTime > g_Config.dwWalkIntervalTime div 3 then
        begin
          if m_dwMoveCount >= 4 then
          begin
            m_dwMoveTick := GetTickCount();
            m_dwMoveCount := 0;
            dwDelayTime := g_Config.dwWalkIntervalTime div 3;
            if m_boTestSpeedMode then
              SysMsg('走路忙复位！！！' + IntTOStr(dwDelayTime), c_Red,
                t_Hint);
          end
          else
            m_dwMoveCount := 0;
          exit;
        end
        else
        begin
          if m_boTestSpeedMode then
            SysMsg('走路忙！！！' + IntTOStr(dwDelayTime), c_Red, t_Hint);
          exit;
        end;
      end;
    end;
    {
    if (GetTickCount - m_dwMoveTick) < 600 then begin
      Inc(m_dwMoveCount);
      Inc(m_dwMoveCountA);
    end else begin
      m_dwMoveCount:=0;
      if m_dwMoveCountA > 0 then Dec(m_dwMoveCountA);
    end;
    }
    m_dwMoveTick := GetTickCount();
    //  if (m_dwMoveCount < 4) and (m_dwMoveCountA < 6) then begin
    m_bo316 := False;
    //n18:=m_nCurrX;
    //n1C:=m_nCurrY;
    n14 := GetNextDirection(m_nCurrX, m_nCurrY, nX, nY);
    if g_Config.boJsCheckFail then
    begin
      if (n14 = 0) and (m_nStep = 0) then
        Inc(m_nStep)
      else if (n14 = 4) and (m_nStep = 1) then
        Inc(m_nStep)
      else if (n14 = 6) and (m_nStep = 2) then
        Inc(m_nStep)
      else if (n14 = 2) and (m_nStep = 3) then
        Inc(m_nStep)
      else if (n14 = 1) and (m_nStep = 4) then
        Inc(m_nStep)
      else if (n14 = 5) and (m_nStep = 5) then
        Inc(m_nStep)
      else if (n14 = 7)
        and (m_nStep = 6) then
        Inc(m_nStep)
      else if (n14 = 3)
        and (m_nStep = 7) then
        Inc(m_nStep)
      else
      begin
        Dec(m_nGameGold, m_nStep);
        GameGoldChanged;
        m_nStep := 0;
      end;
      //SysMsg(IntTOStr(m_nStep),c_Green,t_Hint);
      if m_nStep <> 0 then
      begin
        Inc(m_nGameGold);
        GameGoldChanged;
      end;
    end;

    if WalkTo(n14, False) then
    begin
      if m_bo316 or ((m_nCurrX = nX) and (m_nCurrY = nY)) then
        Result := True;
      Dec(m_nHealthTick, 10);
      //MapEventCheck(OS_WALK,'');    //地图事件触发
    end
    else
    begin
      m_dwMoveCount := 0;
      m_dwMoveCountA := 0;
    end;
    {
    end else begin
      Inc(m_dwOverSpeedCount);
      //if m_dwOverSpeedCount > 8 then m_boEmergencyClose:=True;
      SysMsg('走步超速！！！',c_Red,t_Hint);
      if boViewHackMessage then begin
        MainOutMessage('[11002-Walk] ' + m_sCharName + ' ' + DateToStr(Now));
      end;
    end;
    }
  except
    MainOutMessage('[Exception] TPlayObject.ClientWalkXY');
  end;
end;
//004BC900

procedure TPlayObject.ThrustingOnOff(boSwitch: Boolean);
begin
  try
    m_boUseThrusting := boSwitch;
    if m_boUseThrusting then
    begin
      SysMsg(sThrustingOn, c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sThrustingOff, c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ThrustingOnOff');
  end;
end;
//004BC980

procedure TPlayObject.HalfMoonOnOff(boSwitch: Boolean);
begin
  try
    m_boUseHalfMoon := boSwitch;
    if m_boUseHalfMoon then
    begin
      SysMsg(sHalfMoonOn, c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sHalfMoonOff, c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HalfMoonOnOff');
  end;
end;

procedure TPlayObject.RedHalfMoonOnOff(boSwitch: Boolean);
begin
  try
    m_boRedUseHalfMoon := boSwitch;
    if m_boRedUseHalfMoon then
    begin
      SysMsg(sRedHalfMoonOn, c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sRedHalfMoonOff, c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.RedHalfMoonOnOff');
  end;
end;

procedure TPlayObject.SkillCrsOnOff(boSwitch: Boolean);
begin
  try
    m_boCrsHitkill := boSwitch;
    if m_boCrsHitkill then
    begin
      SysMsg(sCrsHit2On, c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sCrsHit2Off, c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SkillCrsOnOff');
  end;
end;
{$REGION '没用的'}
{procedure TPlayObject.SkillTwinOnOff(boSwitch: Boolean);
begin
  m_boTwinHitSkill:=boSwitch;
  if m_boTwinHitSkill then begin
    SysMsg(sTwinHitOn,c_Green,t_Hint);
  end else begin
    SysMsg(sTwinHitOff,c_Green,t_Hint);
  end;
end; }

{procedure TPlayObject.Skill43OnOff(boSwitch: Boolean);
begin
Try
  m_bo43kill:=boSwitch;
  if m_bo43kill then begin
    SysMsg('开启破空剑',c_Green,t_Hint);
  end else begin
    SysMsg('关闭破空剑',c_Green,t_Hint);
  end;
Except
  MainOutMessage('[Exception] TPlayObject.Skill43OnOff');
End;
end;    }
{$ENDREGION}
function TPlayObject.AllowLongFireHitSkill(): Boolean;
begin
  try
    Result := False;
    if (GetTickCount - m_dwLatestLongFireHitTick) >
      g_Config.nLongFireHitSkillTime then
    begin
      m_dwLatestLongFireHitTick := GetTickCount();
      m_boLongFireHitSkill := True;
      SysMsg(sLongFireSpiritsSummoned, c_Green, t_Hint);
      Result := True;
    end
    else
    begin
      SysMsg(sLongFireSpiritsFail, c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.AllowLongFireHitSkill');
  end;
end;

function TPlayObject.AllowFireHitSkill(): Boolean; //004BCA00
begin
  try
    Result := False;
    if (GetTickCount - m_dwLatestFireHitTick) > g_Config.nFireHitSkillTime then
    begin
      m_dwLatestFireHitTick := GetTickCount();
      m_boFireHitSkill := True;
      SysMsg(sFireSpiritsSummoned, c_Green, t_Hint);
      Result := True;
    end
    else
    begin
      SysMsg(sFireSpiritsFail, c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.AllowFireHitSkill');
  end;
end;

function TPlayObject.AllowTwinHitSkill(): Boolean;
begin
  try
    Result := False;
    m_boTwinHitSkill2 := not m_boTwinHitSkill2;
    if m_boTwinHitSkill2 then
    begin
      SysMsg(sTwinSkillSummoned, c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sTwinSkillsFail, c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.AllowTwinHitSkill');
  end;
end;

function TPlayObject.AllowLongSwordSkill(): Boolean;
begin
  try
    Result := False;
    if (GetTickCount - m_dwLatestLongSwordTick) > g_Config.nLongSwordTime then
    begin
      m_dwLatestLongSwordTick := GetTickCount();
      m_boLongSwordSkill := True;
      SysMsg(sLongSwordSummoned, c_Green, t_Hint);
      Result := True;
      if (Random(10) - (g_Config.nLongSwordRate div 10)) < 0 then
        m_boLongSwordSkillCls := True
      else
        m_boLongSwordSkillCls := False;
    end
    else
    begin
      SysMsg(sLongSwordsFail, c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.AllowLongSwordSkill');
  end;
end;

procedure TBaseObject.MapRandomMove(sMapName: string; nInt: Integer); //004BCB54
var
  Envir: TEnvirnoment;
  nX, nY, nEgdey: Integer;
begin
  try
    //  oEnvir:=m_PEnvir;
    Envir := g_MapManager.FindMap(sMapName);
    if Envir <> nil then
    begin
      if Envir.Header.wHeight < 150 then
      begin
        if Envir.Header.wHeight < 30 then
        begin
          nEgdey := 2;
        end
        else
          nEgdey := 20;
      end
      else
        nEgdey := 50;
      nX := Random(Envir.Header.wWidth - nEgdey - 1) + nEgdey;
      nY := Random(Envir.Header.wHeight - nEgdey - 1) + nEgdey;
      SpaceMove(sMapName, nX, nY, nInt);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.MapRandomMove');
  end;
end;

procedure TPlayObject.ClientClickNPC(NPC: Integer); //004DBA10
var
  NormNpc: TNormNpc;
begin
  try
    if not m_boCanDeal then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sCanotTryDealMsg);
      exit;
    end;
    if m_boDeath or m_boGhost then
      exit;

    NormNpc := UserEngine.FindMerchant(TObject(NPC));
    if NormNpc = nil then
      NormNpc := UserEngine.FindNPC(TObject(NPC));

    if NormNpc <> nil then
    begin
      if (NormNpc.m_PEnvir = m_PEnvir) and (abs(NormNpc.m_nCurrX - m_nCurrX) <=
        15) and (abs(NormNpc.m_nCurrY - m_nCurrY) <= 15) then
      begin
        NormNpc.Click(Self);
        if m_nChickNpc < 100 then
          Inc(m_nChickNpc);
      end;
    end; //004DBA9C
  except
    MainOutMessage('[Exception] TPlayObject.ClientClickNPC');
  end;
end;

//004C4DB8

function TBaseObject.AddItemToBag(UserItem: PTUserItem): Boolean;
begin
  try
    Result := False;
    if m_boHero then
    begin
      if m_ItemList.Count < GetHeroBagCount then
      begin
        m_ItemList.Add(UserItem);
        WeightChanged();
        Result := True;
      end;
    end
    else
    begin
      if m_ItemList.Count < MAXBAGITEM then
      begin
        m_ItemList.Add(UserItem);
        WeightChanged();
        Result := True;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.AddItemToBag');
  end;
end;

//4C9BD0

function TPlayObject.GetRangeHumanCount: Integer;
begin
  try
    Result := UserEngine.GetMapOfRangeHumanCount(m_PEnvir, m_nCurrX, m_nCurrY,
      10);
  except
    MainOutMessage('[Exception] TPlayObject.GetRangeHumanCount:');
  end;
end;

procedure TBaseObject.sub_4C713C(Magic: pTUserMagic); //004C713C
begin
  try
    if Magic.MagicInfo.wMagicId = 28 then
      if Magic.btLevel >= 2 then
        m_boAbilSeeHealGauge := True;
  except
    MainOutMessage('[Exception] TBaseObject.sub_4C713C');
  end;
end;

procedure TPlayObject.GetHomePoint;
var
  I: Integer;
  StartPoint: pTStartPoint;
begin
  try
    try
      g_StartPoint.Lock;
      for I := 0 to g_StartPoint.Count - 1 do
      begin
        StartPoint := g_StartPoint.Items[I];
        if StartPoint.Envir = m_PEnvir then
        begin
          if (abs(m_nCurrX - StartPoint.nX) < 50) and (abs(m_nCurrY -
            StartPoint.nY) < 50) then
          begin
            m_sHomeMap := StartPoint.sMapName;
            m_nHomeX := StartPoint.nX;
            m_nHomeY := StartPoint.nY;
            break;
          end;
        end;
      end;
      if PKLevel >= 2 then
      begin
        m_sHomeMap := g_Config.sRedHomeMap;
        m_nHomeX := g_Config.nRedHomeX;
        m_nHomeY := g_Config.nRedHomeY;
      end;
    finally
      g_StartPoint.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetHomePoint');
  end;
end;
{$REGION '没用的'}
{function TPlayObject.GetStartPoint(var StartPoint:pTStartPoint):Boolean;
var
  i    :Integer;
  Point:pTStartPoint;
begin
Try
  Result:=False;
  if (m_PEnvir.sMapName = g_Config.sRedHomeMap) and
     (abs(m_nCurrX - g_Config.nRedHomeX) < g_Config.nSafeZoneSize) and
     (abs(m_nCurrY - g_Config.nRedHomeY) < g_Config.nSafeZoneSize) then begin
    StartPoint:=@g_RedStartPoint;
    StartPoint.sMapName:=m_PEnvir.sMapName;
    StartPoint.Envir:=m_PEnvir;
    StartPoint.nX:=g_Config.nRedHomeX;
    StartPoint.nY:=g_Config.nRedHomeY;
    Result:=True;
    exit;
  end;
  g_StartPoint.Lock;
  try
    for I := 0 to g_StartPoint.Count - 1 do begin
      Point:=g_StartPoint.Items[I];
      if Point.Envir = m_PEnvir then begin
        if (abs(m_nCurrX - Point.nX) < g_Config.nSafeZoneSize) and (abs(m_nCurrY - Point.nY) < g_Config.nSafeZoneSize) then begin
          StartPoint:=Point;
          Result:=True;
          break;
        end;
      end;
    end;
  finally
    g_StartPoint.UnLock;
  end;
Except
  MainOutMessage('[Exception] TPlayObject.GetStartPoint');
End;
end;     }

{procedure TPlayObject.MobPlace(sX, sY, sMonName, sCount: String); //004C1508
begin
Try

Except
  MainOutMessage('[Exception] TPlayObject.MobPlace');
End;
end;    }
{$ENDREGION}
function TBaseObject.GetQuestFalgStatus(nFlag: integer): Integer; //004C1490
var
  n10, n14: Integer;
begin
  try
    Result := 0;
    Dec(nFlag);
    if nFlag < 0 then
      exit;
    n10 := nFlag div 8;
    n14 := (nFlag mod 8);
    if (n10 - SizeOf(TQuestFlag)) < 0 then
    begin
      if ((128 shr n14) and (m_QuestFlag[n10])) <> 0 then
        Result := 1
      else
        Result := 0;
    end;

    //note: swapped the results around...
  except
    MainOutMessage('[Exception] TBaseObject.GetQuestFalgStatus');
  end;
end;

procedure TBaseObject.SetQuestFlagStatus(nFlag: Integer; nValue: Integer);
//004C1508
var
  n10, n14: Integer;
  bt15: Byte;
begin
  try
    Dec(nFlag);
    if nFlag < 0 then
      exit;
    n10 := nFlag div 8;
    n14 := (nFlag mod 8);
    if (n10 - SizeOf(TQuestFlag)) < 0 then
    begin
      bt15 := m_QuestFlag[n10];
      if nValue = 0 then
      begin
        m_QuestFlag[n10] := (not (128 shr n14)) and (bt15);
      end
      else
      begin
        m_QuestFlag[n10] := (128 shr n14) or (bt15);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SetQuestFlagStatus');
  end;
end;
{$REGION '没用的'}
{function TBaseObject.GetQuestUnitOpenStatus(nFlag: integer): Integer;//004C159C
var
  n10,n14:Integer;
begin
Try
  Result:=0;
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    if ((128 shr n14) and (m_QuestUnitOpen[n10])) <> 0 then Result:=1
    else Result:=0;
  end;
Except
  MainOutMessage('[Exception] TBaseObject.GetQuestUnitOpenStatus');
End;
end;  }
{$ENDREGION}
//取得英雄背包数量

function TBaseObject.GetHeroBagCount(): Integer;
begin
  try
    Result := m_HeroBagCount;
  except
    MainOutMessage('[Exception] TBaseObject.GetHeroBagCount');
  end;
end;
 {$REGION '没用的'}
{procedure TBaseObject.SetQuestUnitOpenStatus(nFlag:Integer;nValue:Integer);//004C1614
var
  n10,n14:Integer;
  bt15:Byte;
begin
Try
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    bt15:=m_QuestUnitOpen[n10];
    if nValue = 0 then begin
      m_QuestUnitOpen[n10]:=(not (128 shr n14)) and (bt15);
    end else begin
      m_QuestUnitOpen[n10]:=(128 shr n14) or (bt15);
    end;
  end;
Except
  MainOutMessage('[Exception] TBaseObject.SetQuestUnitOpenStatus');
End;
end;  }

{function TBaseObject.GetQuestUnitStatus(nFlag: integer): Integer;//004C16A8
var
  n10,n14:Integer;
begin
Try
  Result:=0;
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    if ((128 shr n14) and (m_QuestUnit[n10])) <> 0 then Result:=1
    else Result:=0;
  end;
Except
  MainOutMessage('[Exception] TBaseObject.GetQuestUnitStatus');
End;
end;  }

{procedure TBaseObject.SetQuestUnitStatus(nFlag:Integer;nValue:Integer);//004C1720
var
  n10,n14:Integer;
  bt15:Byte;
begin
Try
  Dec(nFlag);
  if nFlag < 0 then exit;
  n10:=nFlag div 8;
  n14:=(nFlag mod 8);
  if (n10 - SizeOf(TQuestUnit)) < 0 then begin
    bt15:=m_QuestUnit[n10];
    if nValue = 0 then begin
      m_QuestUnit[n10]:=(not (128 shr n14)) and (bt15);
    end else begin
      m_QuestUnit[n10]:=(128 shr n14) or (bt15);
    end;
  end;
Except
  MainOutMessage('[Exception] TBaseObject.SetQuestUnitStatus');
End;
end;  }
{$ENDREGION}

procedure TPlayObject.CmdTrainingMagic(Cmd: pTGameCmd; sHumanName, sSkillName:
  string;
  nLevel: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sHumanName <> '') and (sHumanName[1] = '?')) or (sHumanName = '') or
      (sSkillName = '') or (nLevel < 0) or not (nLevel in [0..3]) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称  技能名称 修炼等级(0-3)', c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    Magic := UserEngine.FindMagic(sSkillName, m_boHero);
    if Magic = nil then
    begin
      SysMsg(format('%s 技能名称不正确！！！', [sSkillName]), c_Red,
        t_Hint);
      exit;
    end;

    if PlayObject.IsTrainingSkill(Magic.wMagicId) then
    begin
      SysMsg(format('%s 技能已修炼过了！！！', [sSkillName]), c_Red,
        t_Hint);
      exit;
    end;
    New(UserMagic);
    UserMagic.MagicInfo := Magic;
    UserMagic.wMagIdx := Magic.wMagicId;
    UserMagic.btLevel := nLevel;
    UserMagic.btKey := 0;
    UserMagic.nTranPoint := 0;
    PlayObject.m_MagicList.Add(UserMagic);
    PlayObject.SendAddMagic(UserMagic);
    PlayObject.RecalcAbilitys;
    PlayObject.SendMsg(PlayObject, RM_SUBABILITY, 0, 0, 0, 0, '');
    SysMsg(format('%s 的 %s 技能修炼成功！！！', [sHumanName,
      sSkillName]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdTrainingMagic');
  end;
end;

procedure TPlayObject.CmdTrainingSkill(Cmd: pTGameCmd; sHumanName, sSkillName:
  string;
  nLevel: Integer);
var
  I: Integer;
  UserMagic: pTUserMagic;
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or (sSkillName = '') or (nLevel <= 0) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称  技能名称 修炼等级(0-3)', c_Red, t_Hint);
      exit;
    end;
    nLevel := _MIN(3, nLevel);
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format('%s不在线，或在其它服务器上！！',
        [sHumanName]), c_Red, t_Hint);
      exit;
    end;

    for I := 0 to PlayObject.m_MagicList.Count - 1 do
    begin
      UserMagic := PlayObject.m_MagicList.Items[I];
      if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then
      begin
        UserMagic.btLevel := nLevel;
        PlayObject.SendMsg(PlayObject,
          RM_MAGIC_LVEXP,
          0,
          UserMagic.MagicInfo.wMagicId,
          UserMagic.btLevel,
          UserMagic.nTranPoint,
          '');
        PlayObject.SysMsg(format('%s的修改炼等级为%d', [sSkillName,
          nLevel]), c_Green, t_Hint);
        SysMsg(format('%s的技能%s修炼等级为%d', [sHumanName, sSkillName,
          nLevel]), c_Green, t_Hint);
        break;
      end;
    end;
    PlayObject.RecalcHitSpeed;
    PlayObject.SendMsg(PlayObject, RM_SUBABILITY, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.CmdTrainingSkill');
  end;
end;

procedure TPlayObject.CmdAddGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sHumName = '') or (nPoint <= 0) then
    begin
      SysMsg('命令格式: @' + sCmd + ' 人物名称  金币数量', c_Red,
        t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      if (PlayObject.m_nGameGold + nPoint) < 2000000 then
      begin
        Inc(PlayObject.m_nGameGold, nPoint);
      end
      else
      begin
        nPoint := 2000000 - PlayObject.m_nGameGold;
        PlayObject.m_nGameGold := 2000000;
      end;
      PlayObject.GoldChanged();
      SysMsg(sHumName + '的游戏点已增加' + IntToStr(nPoint) + '.',
        c_Green, t_Hint);
      PlayObject.SysMsg('游戏点已增加' + IntToStr(nPoint) + '.', c_Green,
        t_Hint);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdAddGameGold');
  end;
end;

procedure TPlayObject.CmdDelGameGold(sCmd, sHumName: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sHumName = '') or (nPoint <= 0) then
      exit;
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      if PlayObject.m_nGameGold > nPoint then
      begin
        Dec(PlayObject.m_nGameGold, nPoint);
      end
      else
      begin
        nPoint := PlayObject.m_nGameGold;
        PlayObject.m_nGameGold := 0;
      end;
      PlayObject.GoldChanged();
      SysMsg(sHumName + '的游戏点已减少' + IntToStr(nPoint) + '.',
        c_Green, t_Hint);
      PlayObject.SysMsg('游戏点已减少' + IntToStr(nPoint) + '.', c_Green,
        t_Hint);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelGameGold');
  end;
end;

procedure TPlayObject.CmdGameGold(Cmd: pTGameCmd; sHumanName: string; sCtr:
  string; nGold: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  try
    Ctr := '1';
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sCtr <> '') then
    begin
      Ctr := sCtr[1];
    end;

    if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nGold < 0) or (nGold
      > 200000000) or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandGameGoldHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    case sCtr[1] of
      '=': PlayObject.m_nGameGold := nGold;
      '+': Inc(PlayObject.m_nGameGold, nGold);
      '-': Dec(PlayObject.m_nGameGold, nGold);
    end;
    if g_boGameLogGameGold then
    begin
      AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEGOLD,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGameGoldName,
          nGold,
          sCtr[1],
          m_sCharName]));
    end;
    GameGoldChanged();
    PlayObject.SysMsg(format(g_sGameCommandGameGoldHumanMsg,
      [g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold,
      g_Config.sGameGoldName]), c_Green, t_Hint);
    SysMsg(format(g_sGameCommandGameGoldGMMsg, [sHumanName,
      g_Config.sGameGoldName, nGold, PlayObject.m_nGameGold,
        g_Config.sGameGoldName]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdGameGold');
  end;
end;

procedure TPlayObject.CmdGamePoint(Cmd: pTGameCmd; sHumanName, sCtr: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
begin
  try
    Ctr := '1';
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sCtr <> '') then
    begin
      Ctr := sCtr[1];
    end;

    if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or
      (nPoint > 100000000) or ((sHumanName <> '') and (sHumanName[1] = '?'))
        then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandGamePointHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    case sCtr[1] of
      '=': PlayObject.m_nGamePoint := nPoint;
      '+': Inc(PlayObject.m_nGamePoint, nPoint);
      '-': Dec(PlayObject.m_nGamePoint, nPoint);
    end;
    if g_boGameLogGamePoint then
    begin
      AddGameDataLog(format(g_sGameLogMsg1, [LOG_GAMEPOINT,
        PlayObject.m_sMapName,
          PlayObject.m_nCurrX,
          PlayObject.m_nCurrY,
          PlayObject.m_sCharName,
          g_Config.sGamePointName,
          nPoint,
          sCtr[1],
          m_sCharName]));
    end;
    GameGoldChanged();
    PlayObject.SysMsg(format(g_sGameCommandGamePointHumanMsg, [nPoint,
      PlayObject.m_nGamePoint]), c_Green, t_Hint);
    SysMsg(format(g_sGameCommandGamePointGMMsg, [sHumanName, nPoint,
      PlayObject.m_nGamePoint]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdGamePoint');
  end;
end;

procedure TPlayObject.CmdCreditPoint(Cmd: pTGameCmd; sHumanName, sCtr: string;
  nPoint: Integer);
var
  PlayObject: TPlayObject;
  Ctr: Char;
  //nCreditpoint:Integer;
begin
  try
    Ctr := '1';
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sCtr <> '') then
    begin
      Ctr := sCtr[1];
    end;

    if (sHumanName = '') or not (Ctr in ['=', '+', '-']) or (nPoint < 0) or
      (nPoint > High(Byte)) or ((sHumanName <> '') and (sHumanName[1] = '?'))
        then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandCreditPointHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GetPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    case sCtr[1] of
      '=':
        begin
          if nPoint >= 0 then
          begin
            PlayObject.m_btCreditPoint := nPoint;
          end
          else
            PlayObject.m_btCreditPoint := 0;
        end;
      '+':
        begin
          Inc(PlayObject.m_btCreditPoint, nPoint);
          if PlayObject.m_btCreditPoint < 0 then
            PlayObject.m_btCreditPoint := 0;
          {nCreditpoint:=PlayObject.m_btCreditPoint + nPoint;
          if nPoint in [0..255] then
            PlayObject.m_btCreditPoint:=nCreditpoint; }
        end;
      '-':
        begin
          if PlayObject.m_btCreditPoint > nPoint then
          begin
            Dec(PlayObject.m_btCreditPoint, nPoint);
          end
          else
          begin
            PlayObject.m_btCreditPoint := 0;
          end;
        end;
    end;
    PlayObject.SysMsg(format(g_sGameCommandCreditPointHumanMsg, [nPoint,
      PlayObject.m_btCreditPoint]), c_Green, t_Hint);
    SysMsg(format(g_sGameCommandCreditPointGMMsg, [sHumanName, nPoint,
      PlayObject.m_btCreditPoint]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdCreditPoint');
  end;
end;

procedure TPlayObject.CmdAddGold(Cmd: pTGameCmd; sHumName: string; nCount:
  Integer); //004CD550
var
  PlayObject: TPlayObject;
  nServerIndex: integer;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sHumName = '') or (nCount <= 0) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称  金币数量',
        c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      if (PlayObject.m_nGold + nCount) < PlayObject.m_nGoldMax then
      begin
        Inc(PlayObject.m_nGold, nCount);
      end
      else
      begin
        nCount := PlayObject.m_nGoldMax - PlayObject.m_nGold;
        PlayObject.m_nGold := PlayObject.m_nGoldMax;
      end;
      PlayObject.GoldChanged();
      SysMsg(sHumName + '的金币已增加' + IntToStr(nCount) + '.', c_Green,
        t_Hint);
      //004CD6F6
      if g_boGameLogGold then
        AddGameDataLog('14' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(nCount) + #9 +
          '1' + #9 +
          sHumName);
    end
    else
    begin
      if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then
      begin
        SysMsg(sHumName + ' 现在' + IntToStr(nServerIndex) +
          '号服务器上', c_Green, t_Hint);
      end
      else
      begin
        FrontEngine.AddChangeGoldList(m_sCharName, sHumName, nCount);
        SysMsg(sHumName +
          ' 现在不在线，等其上线时金币将自动增加', c_Green,
          t_Hint);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdAddGold');
  end;
end;

procedure TPlayObject.CmdAddGuild(Cmd: pTGameCmd; sGuildName, sGuildChief:
  string); //004CEBA0
var
  Human: TPlayObject;
  boAddState: Boolean;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if nServerIndex <> 0 then
    begin
      SysMsg('这个命令只能使用在主服务器上', c_Red, t_Hint);
      exit;
    end;
    if (sGuildName = '') or (sGuildChief = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称 掌门人名称',
        c_Red, t_Hint);
      exit;
    end;

    boAddState := False;
    Human := UserEngine.GeTPlayObject(sGuildChief);
    if Human = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sGuildChief]), c_Red,
        t_Hint);
      exit;
    end;
    if g_GuildManager.MemberOfGuild(sGuildChief) = nil then
    begin
      if g_GuildManager.AddGuild(sGuildName, sGuildChief) then
      begin
        UserEngine.SendServerGroupMsg(SS_205, nServerIndex, sGuildName + '/' +
          sGuildChief);
        SysMsg('行会名称: ' + sGuildName + ' 掌门人: ' + sGuildChief,
          c_Green, t_Hint);
        boAddState := True;
      end;
    end; //004CECB4
    if boAddState then
    begin
      Human.m_MyGuild :=
        TObject(g_GuildManager.MemberOfGuild(Human.m_sCharName));
      if Human.m_MyGuild <> nil then
      begin
        Human.m_sGuildRankName := TGuild(Human.m_MyGuild).GetRankName(self,
          Human.m_nGuildRankNo);
        Human.RefShowName();
      end;
    end; //004CED14
    {
    if boAddState then begin
      SysMsg('YouScrewedUp',c_Red,t_Hint);
    end;
    }
  except
    MainOutMessage('[Exception] TPlayObject.CmdAddGuild');
  end;
end;

procedure TPlayObject.CmdAdjuestExp(Cmd: pTGameCmd; sHumanName, sExp: string);
var
  PlayObject: TPlayObject;
  dwExp: LongWord;
  dwOExp: LongWord;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 经验值', c_Red,
        t_Hint);
      exit;
    end;
    dwExp := Str_ToInt(sExp, 0);

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      dwOExp := PlayObject.m_Abil.Exp;
      PlayObject.m_Abil.Exp := dwExp;
      PlayObject.HasLevelUp(1);
      SysMsg(sHumanName + ' 经验调整完成。', c_Green, t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[经验调整] ' + m_sCharName + '(' +
          PlayObject.m_sCharName + ' ' + IntToStr(dwOExp) + ' -> ' +
          IntToStr(PlayObject.m_Abil.Exp) + ')');
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdAdjuestExp');
  end;
end;

procedure TPlayObject.CmdSignMove(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if PlayObject.m_sDieMap <> '' then
      begin
        Playobject.SpaceMove(m_sDieMap, m_nDieX, m_nDieY, 0);
        m_sDieMap := '';
      end
      else
        SysMsg(format('%s 没有死亡地点记录！！！', [sHumanName]),
          c_Red, t_Hint);
    end
    else
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdSignMove');
  end;
end;

procedure TPlayObject.CmdHeroFealty(Cmd: pTGameCmd; sHumanName: string; nLevel:
  Word);
var
  PlayObject: TPlayObject;
  nOLevel: integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (nLevel > 10000) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 忠诚(0..10000)', c_Red, t_Hint);
      exit;
    end;
    if m_Hero <> nil then
    begin
      PlayObject := TPlayObject(m_Hero);
      nOLevel := PlayObject.m_nGloryPoint;
      //PlayObject.m_nGloryPoint:=;
      if nOLevel <> nLevel then
        PlayObject.HeroChangeGlory(nLevel, 2);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdHeroFealty');
  end;
end;

procedure TPlayObject.CmdHeroLevel(Cmd: pTGameCmd; sHumanName: string; nLevel:
  Integer);
var
  PlayObject: TPlayObject;
  nOLevel: integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 等级', c_Red,
        t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if PlayObject.m_Hero <> nil then
      begin
        nOLevel := PlayObject.m_Hero.m_Abil.Level;
        PlayObject.m_Hero.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
        PlayObject.m_Hero.HasLevelUp(1);
        SysMsg(Format('%s(%s) 的等级调整完成。', [sHumanName,
          PlayObject.m_Hero.m_sCharName]), c_Green, t_Hint);
        if g_Config.boShowMakeItemMsg then
          MainOutMessage(Format('[英雄等级调整] %s(%s %d -> %d)',
            [m_sCharName, sHumanName, nOLevel,
            PlayObject.m_Hero.m_Abil.Level]));
      end
      else
        SysMsg(format('%s 的英雄不在线！！！', [sHumanName]), c_Red,
          t_Hint);
    end
    else
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdHeroLevel');
  end;
end;

procedure TPlayObject.CmdAdjuestLevel(Cmd: pTGameCmd; sHumanName: string;
  nLevel: Integer);
var
  PlayObject: TPlayObject;
  nOLevel: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sHumanName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 等级', c_Red,
        t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      nOLevel := PlayObject.m_Abil.Level;
      PlayObject.m_Abil.Level := _MAX(1, _MIN(MAXUPLEVEL, nLevel));
      PlayObject.HasLevelUp(1);
      SysMsg(sHumanName + ' 等级调整完成。', c_Green, t_Hint);
      if g_Config.boShowMakeItemMsg then
        MainOutMessage('[等级调整] ' + m_sCharName + '(' +
          PlayObject.m_sCharName + ' ' + IntToStr(nOLevel) + ' -> ' +
          IntToStr(PlayObject.m_Abil.Level) + ')');
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdAdjuestLevel');
  end;
end;

procedure TPlayObject.CmdAdjustExp(Human: TPlayObject; nExp: Integer); //004CDDAC
begin
  try
    if (m_btPermission < 6) then
      exit;
  except
    MainOutMessage('[Exception] TPlayObject.CmdAdjustExp');
  end;
end;

procedure TPlayObject.CmdBackStep(sCmd: string; nType, nCount: Integer);
begin
  try
    if (m_btPermission < 6) then
      exit;
    nType := _MIN(nType, 8);
    if nType = 0 then
    begin
      CharPushed(GetBackDir(m_btDirection), nCount);
    end
    else
    begin
      CharPushed(RanDom(nType), nCount);
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdBackStep');
  end;
end;

procedure TPlayObject.CmdBonuPoint(Cmd: pTGameCmd; sHumName: string; nCount:
  Integer);
var
  PlayObject: TPlayObject;
  sMsg: string;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 属性点数(不输入为查看点数)', c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GetPlayObject(sHumName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
      exit;
    end;
    if (nCount > 0) then
    begin
      PlayObject.m_nBonusPoint := nCount;
      PlayObject.SendMsg(self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      exit;
    end;
    sMsg :=
      format('未分配点数:%d 已分配点数:(DC:%d MC:%d SC:%d AC:%d MAC:%d HP:%d MP:%d HIT:%d SPEED:%d)',
      [PlayObject.m_nBonusPoint,
      PlayObject.m_BonusAbil.DC,
        PlayObject.m_BonusAbil.MC,
        PlayObject.m_BonusAbil.SC,
        PlayObject.m_BonusAbil.AC,
        PlayObject.m_BonusAbil.MAC,
        PlayObject.m_BonusAbil.HP,
        PlayObject.m_BonusAbil.MP,
        PlayObject.m_BonusAbil.Hit,
        PlayObject.m_BonusAbil.Speed
        ]);
    SysMsg(format('%s的属性点数为:%s', [sHumName, sMsg]), c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdBonuPoint');
  end;
end;

procedure TPlayObject.CmdChangeAdminMode(sCmd: string; nPermission: Integer;
  sParam1: string; boFlag: Boolean);
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;

    m_boAdminMode := boFlag;
    if m_boAdminMode then
      SysMsg(sGameMasterMode, c_Green, t_Hint)
    else
      SysMsg(sReleaseGameMasterMode, c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeAdminMode');
  end;
end;

//烟花效果

procedure TPlayObject.CmdShowEffect(Cmd: pTGameCmd; nParam: Integer);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    SendRefMsg(RM_SHOWEFFECT, nParam, Integer(Self), m_nCurrX, m_nCurrY, '');
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowEffect');
  end;
end;

//千里传音

procedure TPlayObject.CmdAllSysMsg(sParam: string);
var
  AmuletStdItem: TItem;
begin
  try
    if (m_UseItems[U_CHARM].wIndex > 0) and (m_UseItems[U_CHARM].Dura > 0) then
    begin
      AmuletStdItem := UserEngine.GetStdItem(m_UseItems[U_CHARM].wIndex);
      if (AmuletStdItem.StdMode = 7) and (AmuletStdItem.Shape = 0) then
      begin
        if m_UseItems[U_CHARM].Dura > 1000 then
        begin
          Dec(m_UseItems[U_CHARM].Dura, 1000);
          SendMsg(Self, RM_DURACHANGE, U_CHARM, m_UseItems[U_CHARM].Dura,
            m_UseItems[U_CHARM].DuraMax, 0, '');
        end
        else
        begin
          m_UseItems[U_CHARM].Dura := 0;
          SendDelItems(@m_UseItems[U_CHARM]);
          m_UseItems[U_CHARM].wIndex := 0;
        end;
        if sParam <> '' then
          UserEngine.SendBroadCastMsg(m_sCharName + ': ' + sParam, t_Cudt);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdAllSysMsg');
  end;
end;

procedure TPlayObject.CmdHeroState();
var
  sMsg: string;
begin
  try
    if m_Hero <> nil then
    begin
      case m_Hero.m_btAttatckMode of
        0:
          begin
            m_Hero.m_btAttatckMode := 1; //跟随
            sMsg := sHeroFollow;
          end;
        1:
          begin
            m_Hero.m_btAttatckMode := 2; //休息
            sMsg := sHeroRest;
          end;
        2:
          begin
            m_Hero.m_btAttatckMode := 0; //攻击
            sMsg := sHeroAttack;
          end;
      else
        begin
          m_btAttatckMode := 0;
          sMsg := sHeroAttack;
        end;
      end;
      SysMsg(sMsg, c_Blue, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdHeroState');
  end;
end;

procedure TPlayObject.CmdChangeAttackMode(nMode: Integer; sParam1, sParam2,
  sParam3, sParam4, sParam5, sParam6, sParam7: string);
begin
  try
    if (nMode >= HAM_ALL) and (nMode <= HAM_PKATTACK) then
      m_btAttatckMode := nMode
    else
    begin
      if m_btAttatckMode < HAM_PKATTACK then
        Inc(m_btAttatckMode)
      else
        m_btAttatckMode := HAM_ALL;
    end;
    if m_dwClientTickEx > 20070801 then
    begin
      case m_btAttatckMode of
        HAM_ALL: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[全体攻击模式]'); //[攻击模式: 全体攻击]
        HAM_PEACE: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[和平攻击模式]'); //[攻击模式: 和平攻击]
        HAM_DEAR: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[夫妻攻击模式]'); //[攻击模式: 夫妻攻击]
        HAM_MASTER: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[师徒攻击模式]'); //[攻击模式: 师徒攻击]
        HAM_GROUP: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[编组攻击模式]'); //[攻击模式: 编组攻击]
        HAM_GUILD: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[行会攻击模式]'); //[攻击模式: 行会攻击]
        HAM_PKATTACK: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
            '[红名攻击模式]'); //[攻击模式: 红名攻击]
      end;
    end
    else
    begin
      case m_btAttatckMode of
        HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint);
        //[攻击模式: 全体攻击]
        HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint);
        //[攻击模式: 和平攻击]
        HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint);
        //[攻击模式: 夫妻攻击]
        HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint);
        //[攻击模式: 师徒攻击]
        HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint);
        //[攻击模式: 编组攻击]
        HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint);
        //[攻击模式: 行会攻击]
        HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint);
        //[攻击模式: 红名攻击]
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeAttackMode');
  end;
end;

procedure TPlayObject.CmdChangeDearName(Cmd: pTGameCmd; sHumanName, sDearName:
  string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or (sDearName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 配偶名称(如果为 无 则清除)', c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if CompareText(sDearName, '无') = 0 then
      begin
        PlayObject.m_sDearName := '';
        PlayObject.RefShowName;
        SysMsg(sHumanName + ' 的配偶名清除成功。', c_Green, t_Hint);
      end
      else
      begin
        PlayObject.m_sDearName := sDearName;
        PlayObject.RefShowName;
        SysMsg(sHumanName + ' 的配偶名更改成功。', c_Green, t_Hint);
      end;
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeDearName');
  end;
end;

procedure TPlayObject.CmdChangeGender(Cmd: pTGameCmd; sHumanName, sSex: string);
var
  PlayObject: TPlayObject;
  nSex: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    nSex := -1;
    if (sSex = '男') or (sSex = 'Man') or (sSex = '0') then
    begin
      nSex := 0;
    end;
    if (sSex = '女') or (sSex = 'Woman') or (sSex = '1') then
    begin
      nSex := 1;
    end;
    if (sHumanName = '') or (nSex = -1) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 性别(男、女)',
        c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if PlayObject.m_btGender <> nSex then
      begin
        PlayObject.m_btGender := nSex;
        PlayObject.FeatureChanged();
        SysMsg(PlayObject.m_sCharName + ' 的性别已改变。', c_Green,
          t_Hint);
      end
      else
      begin
        SysMsg(PlayObject.m_sCharName + ' 的性别未改变！！！', c_Red,
          t_Hint);
      end;
    end
    else
    begin
      SysMsg(sHumanName + '没有在线！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeGender');
  end;
end;

procedure TPlayObject.CmdChangeItemName(sCmd, sMakeIndex, sItemIndex, sItemName:
  string);
var
  nMakeIndex, nItemIndex: Integer;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sMakeIndex = '') or (sItemIndex = '') or (sItemName = '') then
    begin
      SysMsg('命令格式: @' + sCmd +
        ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
      exit;
    end;
    nMakeIndex := Str_ToInt(sMakeIndex, -1);
    nItemIndex := Str_ToInt(sItemIndex, -1);
    if (nMakeIndex <= 0) or (nItemIndex < 0) then
    begin
      SysMsg('命令格式: @' + sCmd +
        ' 物品编号 物品ID号 物品名称', c_Red, t_Hint);
      exit;
    end;

    if ItemUnit.AddCustomItemName(nMakeIndex, nItemIndex, sItemName) then
    begin
      ItemUnit.SaveCustomItemName();
      SysMsg('物品名称设置成功。', c_Green, t_Hint);
      exit;
    end;

    SysMsg('此物品，已经设置了其它的名称！！！', c_Red,
      t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeItemName');
  end;
end;

procedure TPlayObject.CmdChangeJob(Cmd: pTGameCmd; sHumanName, sJobName:
  string);
//004CC714
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;

    if (sHumanName = '') or (sJobName = '') then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandChangeJobHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if CompareText(sJobName, sWarrior2) = 0 then
        PlayObject.m_btJob := jWarr;
      if CompareText(sJobName, sWizard2) = 0 then
        PlayObject.m_btJob := jWizard;
      if CompareText(sJobName, sTaos2) = 0 then
        PlayObject.m_btJob := jTaos;
      PlayObject.HasLevelUp(1);
      PlayObject.SysMsg(g_sGameCommandChangeJobHumanMsg, c_Green, t_Hint);
      SysMsg(format(g_sGameCommandChangeJobMsg, [sHumanName]), c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeJob');
  end;
end;

procedure TPlayObject.CmdChangeLevel(Cmd: pTGameCmd; sParam1: string);
var
  nOLevel: Integer;
  nLevel: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
      exit;
    end;

    nLevel := Str_ToInt(sParam1, 1);
    nOLevel := m_Abil.Level;
    m_Abil.Level := _MIN(MAXUPLEVEL, nLevel);
    HasLevelUp(1);
    if g_Config.boShowMakeItemMsg then
    begin
      MainOutMessage(format(g_sGameCommandLevelConsoleMsg, [m_sCharName,
        nOLevel, m_Abil.Level]));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeLevel');
  end;
end;

procedure TPlayObject.CmdChangeMasterName(Cmd: pTGameCmd; sHumanName,
  sMasterName, sIsMaster: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or (sMasterName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 师徒名称(如果为 无 则清除)', c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if CompareText(sMasterName, '无') = 0 then
      begin
        PlayObject.m_sMasterName := '';
        PlayObject.RefShowName;
        PlayObject.m_boMaster := False;
        SysMsg(sHumanName + ' 的师徒名清除成功。', c_Green, t_Hint);
      end
      else
      begin
        PlayObject.m_sMasterName := sMasterName;
        if (sIsMaster <> '') and (sIsMaster[1] = '1') then
          PlayObject.m_boMaster := True
        else
          PlayObject.m_boMaster := False;
        PlayObject.RefShowName;
        SysMsg(sHumanName + ' 的师徒名更改成功。', c_Green, t_Hint);
      end;
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeMasterName');
  end;
end;

procedure TPlayObject.CmdChangeObMode(sCmd: string; nPermission: Integer;
  sParam1: string; boFlag: Boolean);
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    if boFlag then
    begin
      SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
      //01/21 强行发送刷新数据到客户端，解决GM登录隐身有影子问题
    end;
    m_boObMode := boFlag;
    if m_boObMode then
    begin
      SysMsg(sObserverMode, c_Green, t_Hint);
    end
    else
      SysMsg(g_sReleaseObserverMode, c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeObMode');
  end;
end;

procedure TPlayObject.CmdChangeSabukLord(Cmd: pTGameCmd; sCastleName,
  sGuildName: string; boFlag: Boolean); //004CFE1C
var
  Guild: TGuild;
  Castle: TUserCastle;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;

    if (sCastleName = '') or (sGuildName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称 行会名称', c_Red,
        t_Hint);
      exit;
    end;
    Castle := g_CastleManager.Find(sCastleName);
    if Castle = nil then
    begin
      SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCastleName]),
        c_Red, t_Hint);
      exit;
    end;

    Guild := g_GuildManager.FindGuild(sGuildName);
    if Guild <> nil then
    begin
      //4CFEC7
      AddGameDataLog('27' + #9 +
        Castle.m_sOwnGuild + #9 +
        '0' + #9 +
        '1' + #9 +
        'sGuildName' + #9 +
        m_sCharName + #9 +
        '0' + #9 +
        '1' + #9 +
        '0');
      Castle.GetCastle(Guild);
      if boFlag then
        UserEngine.SendServerGroupMsg(SS_211, nServerIndex, sGuildName);
      SysMsg(Castle.m_sName + ' 所属行会已经更改为 ' + sGuildName,
        c_Green, t_Hint);
    end
    else
    begin
      SysMsg('行会 ' + sGuildName + '还没建立！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeSabukLord');
  end;
end;

procedure TPlayObject.CmdChangeSalveStatus; //更改宝宝状态
begin
  try
    if (m_SlaveList.Count > 0) or (m_Clone <> nil) then
    begin
      m_boSlaveRelax := not m_boSlaveRelax;
      if m_boSlaveRelax then
        SysMsg(sPetRest, c_Green, t_Hint)
      else
        SysMsg(sPetAttack, c_Green, t_Hint)
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeSalveStatus');
  end;
end;

procedure TPlayObject.CmdChangeSuperManMode(sCmd: string; nPermission: Integer;
  sParam1: string; boFlag: Boolean);
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    m_boSuperMan := boFlag;
    if m_boSuperMan then
      SysMsg(sSupermanMode, c_Green, t_Hint)
    else
      SysMsg(sReleaseSupermanMode, c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeSuperManMode');
  end;
end;

procedure TPlayObject.CmdChangeUserFull(sCmd, sUserCount: string);
var
  nCount: Integer;
begin
  try
    if (m_btPermission < 6) then
      exit;
    nCount := Str_ToInt(sUserCount, -1);
    if (sUserCount = '') or (nCount < 1) or ((sUserCount <> '') and
      (sUserCount[1] = '?')) then
    begin
      SysMsg('设置服务器最高上线人数。', c_Red, t_Hint);
      SysMsg('命令格式: @' + sCmd + ' 人数', c_Red, t_Hint);
      exit;
    end;
    g_Config.nUserFull := nCount;
    SysMsg(format('服务器上线人数限制: %d', [nCount]), c_Green,
      t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeUserFull');
  end;
end;

procedure TPlayObject.CmdChangeZenFastStep(sCmd, sFastStep: string);
var
  nFastStep: Integer;
begin
  try
    if (m_btPermission < 6) then
      exit;
    nFastStep := Str_ToInt(sFastStep, -1);
    if (sFastStep = '') or (nFastStep < 1) or ((sFastStep <> '') and
      (sFastStep[1] = '?')) then
    begin
      SysMsg('设置怪物行动速度。', c_Red, t_Hint);
      SysMsg('命令格式: @' + sCmd + ' 速度', c_Red, t_Hint);
      exit;
    end;
    g_Config.nZenFastStep := nFastStep;
    SysMsg(format('怪物行动速度: %d', [nFastStep]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdChangeZenFastStep');
  end;
end;

procedure TBaseObject.ClearStorageItem();
var
  I: Integer;
  UserItem: pTUserItem;
begin
  try
    for I := 0 to m_StorageItemList.Count - 1 do
    begin
      UserItem := m_StorageItemList.Items[I];
      Dispose(UserItem);
    end;
    m_StorageItemList.Clear;
  except
    MainOutMessage('[Exception] TBaseObject.ClearStorageItem');
  end;
end;

procedure TBaseObject.ClearBagItem();
var
  I: Integer;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  try
    DelList := nil;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if DelList = nil then
        DelList := TStringList.Create;
      DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex),
        TObject(UserItem.MakeIndex));
      Dispose(UserItem);
    end;
    m_ItemList.Clear;
    if (DelList <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TBaseObject.ClearBagItem');
  end;
end;

procedure TPlayObject.CmdClearBagItem(Cmd: pTGameCmd; sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  DelList: TStringList;
begin
  try
    DelList := nil;
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '人物名称']),
        c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;

    for I := 0 to PlayObject.m_ItemList.Count - 1 do
    begin
      UserItem := PlayObject.m_ItemList.Items[I];
      if DelList = nil then
        DelList := TStringList.Create;
      DelList.AddObject(UserEngine.GetStdItemName(UserItem.wIndex),
        TObject(UserItem.MakeIndex));
      Dispose(UserItem);
    end;
    PlayObject.m_ItemList.Clear;
    if DelList <> nil then
    begin
      PlayObject.SendMsg(PlayObject, RM_SENDDELITEMLIST, 0, Integer(DelList), 0,
        0, '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdClearBagItem');
  end;
end;

procedure TPlayObject.CmdClearHumanPassword(sCmd: string; nPermission: Integer;
  sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < nPermission) then
      exit;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg('清除玩家的仓库密码！！！', c_Red, t_Hint);
      SysMsg(format('命令格式: @%s 人物名称', [sCmd]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      exit;
    end;
    PlayObject.m_boPasswordLocked := False;
    PlayObject.m_boUnLockStoragePwd := False;
    PlayObject.m_sStoragePwd := '';
    PlayObject.SysMsg('你的保护密码已被清除！！！', c_Green,
      t_Hint);
    SysMsg(format('%s的保护密码已被清除！！！', [sHumanName]),
      c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdClearHumanPassword');
  end;
end;

procedure TPlayObject.CmdClearMapMonster(Cmd: pTGameCmd; sMapName, sMonName,
  sItems: string);
var
  I, II: Integer;
  MonList: TList;
  Envir: TEnvirnoment;
  nMonCount: Integer;
  boKillAll: Boolean;
  boKillAllMap: Boolean;
  boNotItem: Boolean;
  BaseObject: TBaseObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMapName = '') or (sMonName = '') or (sItems = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 地图号(* 为所有) 怪物名称(* 为所有) 掉物品(0,1)',
        c_Red,
        t_Hint);
      exit;
    end;
    boKillAll := False;
    boKillAllMap := False;
    boNotItem := True;
    nMonCount := 0;
    Envir := nil;
    if sMonName = '*' then
      boKillAll := True;
    if sMapName = '*' then
      boKillAllMap := True;
    if sItems = '1' then
      boNotItem := False;

    MonList := TList.Create;
    for I := 0 to g_MapManager.Count - 1 do
    begin
      Envir := TEnvirnoment(g_MapManager.Items[I]);
      if (Envir <> nil) and (boKillAllMap or (CompareText(Envir.sMapName,
        sMapName) = 0)) then
      begin
        UserEngine.GetMapMonster(Envir, MonList);
        for II := 0 to MonList.Count - 1 do
        begin
          BaseObject := TBaseObject(MonList.Items[II]);
          if boKillAll or (CompareText(sMonName, BaseObject.m_sCharName) = 0)
            then
          begin
            BaseObject.m_boNoItem := boNotItem;
            BaseObject.m_boRun := True;
            BaseObject.m_WAbil.HP := 0;
            Inc(nMonCount);
          end;
        end;
      end;
    end;
    MonList.Free;
    if Envir = nil then
    begin
      SysMsg('输入的地图不存在！！！', c_Red, t_Hint);
      exit;
    end;

    SysMsg('已清除怪物数: ' + IntTOStr(nMonCount), c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdClearMapMonster');
  end;
end;

procedure TPlayObject.CmdClearMission(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称)', c_Red, t_Hint);
      exit;
    end;
    if sHumanName[1] = '?' then
    begin
      SysMsg('此命令用于清除人物的任务标志。', c_Blue, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format('%s不在线，或在其它服务器上！！',
        [sHumanName]), c_Red, t_Hint);
      exit;
    end;
    FillChar(PlayObject.m_QuestFlag, SizeOf(TQuestFlag), 0);
    SysMsg(format('%s的任务标志已经全部清零。', [sHumanName]),
      c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdClearMission');
  end;
end;

procedure TPlayObject.CmdContestPoint(Cmd: pTGameCmd; sGuildName: string);
//004CEF08
var
  //  I: Integer;
  Guild: TGuild;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then
    begin
      SysMsg('查看行会战的得分数。', c_Red, t_Hint);
      SysMsg(format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red,
        t_Hint);
      exit;
    end;
    Guild := g_GuildManager.FindGuild(sGuildName);
    if Guild <> nil then
    begin
      SysMsg(format('%s 的得分为: %d', [sGuildName, Guild.nContestPoint]),
        c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format('行会: %s 不存在！！！', [sGuildName]), c_Green,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdContestPoint');
  end;
end;

procedure TPlayObject.CmdStartContest(Cmd: pTGameCmd; sParam1: string);
//004CF008
var
  I, II: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
  s20: string;
  Guild: TGuild;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg('开始行会争霸赛。', c_Red, t_Hint);
      SysMsg(format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
      exit;
    end;

    if not m_PEnvir.Flag.boFight3Zone then
    begin
      SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
      exit;
    end;
    List10 := TList.Create;
    List14 := TList.Create;
    UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
    for I := 0 to List10.Count - 1 do
    begin
      PlayObject := TPlayObject(List10.Items[I]);
      if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then
      begin
        PlayObject.m_nFightZoneDieCount := 0;
        if PlayObject.m_MyGuild = nil then
          Continue;
        bo19 := False;
        for II := 0 to List14.Count - 1 do
        begin
          PlayObjectA := TPlayObject(List14.Items[II]);
          if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
            bo19 := True;
        end;
        if not bo19 then
        begin
          List14.Add(PlayObject.m_MyGuild);
        end;
      end;
    end;
    SysMsg('行会争霸赛已经开始。', c_Green, t_Hint);
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
      g_Config.btCryMsgFColor, g_Config.btCryMsgBColor,
      '- 行会战争已爆发。');
    s20 := '';
    for I := 0 to List14.Count - 1 do
    begin
      Guild := TGuild(List14.Items[I]);
      Guild.StartTeamFight();
      for II := 0 to List10.Count - 1 do
      begin
        PlayObject := TPlayObject(List10.Items[I]);
        if PlayObject.m_MyGuild = Guild then
        begin
          Guild.AddTeamFightMember(PlayObject.m_sCharName);
        end;
      end;
      s20 := s20 + Guild.sGuildName + ' ';
    end;
    UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
      g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, ' -参加的门派:' +
      s20);
    List10.Free;
    List14.Free;
  except
    MainOutMessage('[Exception] TPlayObject.CmdStartContest');
  end;
end;

procedure TPlayObject.CmdEndContest(Cmd: pTGameCmd; sParam1: string); //004CF364
var
  I, II: Integer;
  List10, List14: TList;
  PlayObject, PlayObjectA: TPlayObject;
  bo19: Boolean;
  //  s20:String;
  Guild: TGuild;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg('结束行会争霸赛。', c_Red, t_Hint);
      SysMsg(format('命令格式: @%s', [Cmd.sCmd]), c_Red, t_Hint);
      exit;
    end;

    if not m_PEnvir.Flag.boFight3Zone then
    begin
      SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
      exit;
    end;
    List10 := TList.Create;
    List14 := TList.Create;
    UserEngine.GetMapRageHuman(m_PEnvir, m_nCurrX, m_nCurrY, 1000, List10);
    for I := 0 to List10.Count - 1 do
    begin
      PlayObject := TPlayObject(List10.Items[I]);
      if not PlayObject.m_boObMode or not PlayObject.m_boAdminMode then
      begin
        if PlayObject.m_MyGuild = nil then
          Continue;
        bo19 := False;
        for II := 0 to List14.Count - 1 do
        begin
          PlayObjectA := TPlayObject(List14.Items[II]);
          if PlayObject.m_MyGuild = PlayObjectA.m_MyGuild then
            bo19 := True;
        end;
        if not bo19 then
        begin
          List14.Add(PlayObject.m_MyGuild);
        end;
      end;
    end;
    for I := 0 to List14.Count - 1 do
    begin
      Guild := TGuild(List14.Items[I]);
      Guild.EndTeamFight();
      UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
        g_Config.btCryMsgFColor, g_Config.btCryMsgBColor,
        format(' - %s 行会争霸赛已结束。', [Guild.sGuildName]));
    end;
    List10.Free;
    List14.Free;
  except
    MainOutMessage('[Exception] TPlayObject.CmdEndContest');
  end;
end;

procedure TPlayObject.CmdAllowGroupReCall(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('此命令用于允许或禁止编组传送功能。', c_Red,
        t_Hint);
      exit;
    end;

    m_boAllowGroupReCall := not m_boAllowGroupReCall;
    if m_boAllowGroupReCall then
      SysMsg(g_sEnableGroupRecall {'[允许天地合一]'}, c_Green, t_Hint)
    else
      SysMsg(g_sDisableGroupRecall {'[禁止天地合一]'}, c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdAllowGroupReCall');
  end;
end;

procedure TPlayObject.CmdAnnouncement(Cmd: pTGameCmd; sGuildName: string);
//004CF564
var
  I: Integer;
  Guild: TGuild;
  //  PlayObject:TPlayObject;
  sHumanName: string;
  nPoint: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sGuildName = '') or ((sGuildName <> '') and (sGuildName[1] = '?')) then
    begin
      SysMsg('查看行会争霸赛结果。', c_Red, t_Hint);
      SysMsg(format('命令格式: @%s 行会名称', [Cmd.sCmd]), c_Red,
        t_Hint);
      exit;
    end;

    if not m_PEnvir.Flag.boFight3Zone then
    begin
      SysMsg('此命令不能在当前地图中使用！！！', c_Red, t_Hint);
      exit;
    end;
    Guild := g_GuildManager.FindGuild(sGuildName);
    if Guild <> nil then
    begin
      UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
        g_Config.btCryMsgFColor, g_Config.btCryMsgBColor,
        format(' - %s 行会争霸赛结果: ', [Guild.sGuildName]));
      for I := 0 to Guild.TeamFightDeadList.Count - 1 do
      begin
        nPoint := Integer(Guild.TeamFightDeadList.Objects[I]);
        sHumanName := Guild.TeamFightDeadList.Strings[I];
        UserEngine.CryCry(RM_CRY,
          m_PEnvir,
          m_nCurrX,
          m_nCurrY,
          1000,
          g_Config.btCryMsgFColor,
          g_Config.btCryMsgBColor,
          format(' - %s  : %d 分/死亡%d次。 ', [sHumanName, HiWord(nPoint),
          LoWord(nPoint)]));
      end;
    end;
    UserEngine.CryCry(RM_CRY,
      m_PEnvir,
      m_nCurrX,
      m_nCurrY,
      1000,
      g_Config.btCryMsgFColor,
      g_Config.btCryMsgBColor,
      format(' - [%s] : %d 分。', [Guild.sGuildName, Guild.nContestPoint]));
    UserEngine.CryCry(RM_CRY,
      m_PEnvir,
      m_nCurrX,
      m_nCurrY,
      1000,
      g_Config.btCryMsgFColor,
      g_Config.btCryMsgBColor,
      '------------------------------------');
  except
    MainOutMessage('[Exception] TPlayObject.CmdAnnouncement');
  end;
end;

procedure TPlayObject.CmdDearRecall(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('命令格式: @' + sCmd +
        ' (夫妻传送，将对方传送到自己身边，对方必须允许传送。)',
        c_Green, t_Hint);
      exit;
    end;
    if m_sDearName = '' then
    begin
      SysMsg('你没有结婚！！！', c_Red, t_Hint);
      exit;
    end;
    if m_PEnvir.Flag.boNODEARRECALL then
    begin
      SysMsg('本地图禁止夫妻传送！！！', c_Red, t_Hint);
      exit;
    end;

    if m_DearHuman = nil then
    begin
      if m_btGender = gMan then
      begin
        SysMsg('你的老婆不在线！！！', c_Red, t_Hint);
      end
      else
      begin
        SysMsg('你的老公不在线！！！', c_Red, t_Hint);
      end;
      exit;
    end;
    if GetTickCount - m_dwDearRecallTick < 10000 then
    begin
      SysMsg('稍等伙才能再次使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    m_dwDearRecallTick := GetTickCount();
    if m_DearHuman.m_boCanDearRecall then
    begin
      RecallHuman(m_DearHuman.m_sCharName);
    end
    else
    begin
      SysMsg(m_DearHuman.m_sCharName + ' 不允许传送！！！', c_Red,
        t_Hint);
      exit;
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdDearRecall');
  end;
end;

procedure TPlayObject.CmdMasterRecall(sCmd, sParam: string);
var
  I: Integer;
  MasterHuman: TPlayObject;
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('命令格式: @' + sCmd +
        ' (师徒传送，师父可以将徒弟传送到自己身边，徒弟必须允许传送。)',
        c_Green, t_Hint);
      exit;
    end;
    if not m_boMaster then
    begin
      SysMsg('只能师父才能使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    if m_MasterList.Count = 0 then
    begin
      SysMsg('你的徒弟一个都不在线！！！', c_Red, t_Hint);
      exit;
    end;
    if m_PEnvir.Flag.boNOMASTERRECALL then
    begin
      SysMsg('本地图禁止师徒传送！！！', c_Red, t_Hint);
      exit;
    end;
    if GetTickCount - m_dwMasterRecallTick < 10000 then
    begin
      SysMsg('稍等伙才能再次使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    for I := 0 to m_MasterList.Count - 1 do
    begin
      MasterHuman := TPlayObject(m_MasterList.Items[I]);
      if MasterHuman.m_boCanMasterRecall then
      begin
        RecallHuman(MasterHuman.m_sCharName);
      end
      else
      begin
        SysMsg(MasterHuman.m_sCharName + ' 不允许传送！！！', c_Red,
          t_Hint);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdMasterRecall');
  end;
end;

procedure TPlayObject.CmdDelBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sHumName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), 0);
      PlayObject.m_nBonusPoint := 0;
      PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      PlayObject.HasLevelUp(0);
      PlayObject.SysMsg('分配点数已清除！！！', c_Red, t_Hint);
      SysMsg(sHumName + ' 的分配点数已清除.', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelBonuPoint');
  end;
end;

procedure TPlayObject.CmdReNewLevel(Cmd: pTGameCmd; sHumanName, sLevel: string);
var
  PlayObject: TPlayObject;
  nLevel: Integer;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 点数(为空则查看)', c_Red, t_Hint);
      exit;
    end;
    nLevel := Str_ToInt(sLevel, -1);
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      if (nLevel >= 0) and (nLevel <= 255) then
      begin
        PlayObject.m_btReLevel := nLevel;
        PlayObject.RefShowName();
      end;
      SysMsg(sHumanName + ' 的转生等级为 ' +
        IntToStr(PlayObject.m_btReLevel), c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sHumanName + ' 没在线上！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReNewLevel');
  end;
end;

procedure TPlayObject.CmdRestBonuPoint(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
  nTotleUsePoint: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sHumName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      nTotleUsePoint := PlayObject.m_BonusAbil.DC +
        PlayObject.m_BonusAbil.MC +
        PlayObject.m_BonusAbil.SC +
        PlayObject.m_BonusAbil.AC +
        PlayObject.m_BonusAbil.MAC +
        PlayObject.m_BonusAbil.HP +
        PlayObject.m_BonusAbil.MP +
        PlayObject.m_BonusAbil.Hit +
        PlayObject.m_BonusAbil.Speed +
        PlayObject.m_BonusAbil.X2;
      FillChar(PlayObject.m_BonusAbil, SizeOf(TNakedAbility), 0);

      Inc(PlayObject.m_nBonusPoint, nTotleUsePoint);
      PlayObject.SendMsg(PlayObject, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      PlayObject.HasLevelUp(0);
      PlayObject.SysMsg('分配点数已复位！！！', c_Red, t_Hint);
      SysMsg(sHumName + ' 的分配点数已复位.', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdRestBonuPoint');
  end;
end;

procedure TPlayObject.CmdSbkDoorControl(sCmd, sParam: string);
begin
  try

  except
    MainOutMessage('[Exception] TPlayObject.CmdSbkDoorControl');
  end;
end;

procedure TPlayObject.CmdSearchDear(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('此命令用于查询配偶当前所在位置。', c_Red, t_Hint);
      exit;
    end;
    if m_sDearName = '' then
    begin
      SysMsg(g_sYouAreNotMarryedMsg {'你都没结婚查什么？'}, c_Red,
        t_Hint);
      exit;
    end;
    if m_DearHuman = nil then
    begin
      if m_btGender = gMan then
      begin
        SysMsg(g_sYourWifeNotOnlineMsg {'你的老婆还没有上线！！！'},
          c_Red, t_Hint);
      end
      else
      begin
        SysMsg(g_sYourHusbandNotOnlineMsg
          {'你的老公还没有上线！！！'}, c_Red, t_Hint);
      end;
      exit;
    end;

    if m_btGender = gMan then
    begin
      SysMsg(g_sYourWifeNowLocateMsg {'你的老婆现在位于:'}, c_Green,
        t_Hint);
      SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '('
        + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY)
        +
        ')', c_Green, t_Hint);
      m_DearHuman.SysMsg(g_sYourHusbandSearchLocateMsg
        {'你的老公正在找你，他现在位于:'}, c_Green, t_Hint);
      m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' +
        IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(g_sYourHusbandNowLocateMsg {'你的老公现在位于:'}, c_Red,
        t_Hint);
      SysMsg(m_DearHuman.m_sCharName + ' ' + m_DearHuman.m_PEnvir.sMapDesc + '('
        + IntToStr(m_DearHuman.m_nCurrX) + ':' + IntToStr(m_DearHuman.m_nCurrY)
        +
        ')', c_Green, t_Hint);
      m_DearHuman.SysMsg(g_sYourWifeSearchLocateMsg
        {'你的老婆正在找你，她现在位于:'}, c_Green, t_Hint);
      m_DearHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' +
        IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdSearchDear');
  end;
end;

procedure TPlayObject.CmdSearchMaster(sCmd, sParam: string);
var
  I: Integer;
  Human: TPlayObject;
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('此命令用于查询师徒当前所在位置。', c_Red, t_Hint);
      exit;
    end;
    if m_sMasterName = '' then
    begin
      SysMsg(g_sYouAreNotMasterMsg, c_Red, t_Hint);
      exit;
    end;
    if m_boMaster then
    begin
      if m_MasterList.Count <= 0 then
      begin
        SysMsg(g_sYourMasterListNotOnlineMsg, c_Red, t_Hint);
        exit;
      end;
      SysMsg(g_sYourMasterListNowLocateMsg, c_Green, t_Hint);
      for I := 0 to m_MasterList.Count - 1 do
      begin
        Human := TPlayObject(m_MasterList.Items[I]);
        SysMsg(Human.m_sCharName + ' ' + Human.m_PEnvir.sMapDesc + '(' +
          IntToStr(Human.m_nCurrX) + ':' + IntToStr(Human.m_nCurrY) + ')',
          c_Green, t_Hint);
        Human.SysMsg(g_sYourMasterSearchLocateMsg, c_Green, t_Hint);
        Human.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' +
          IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
      end;
    end
    else
    begin
      if m_MasterHuman = nil then
      begin
        SysMsg(g_sYourMasterNotOnlineMsg, c_Red, t_Hint);
        exit;
      end;
      SysMsg(g_sYourMasterNowLocateMsg, c_Red, t_Hint);
      SysMsg(m_MasterHuman.m_sCharName + ' ' + m_MasterHuman.m_PEnvir.sMapDesc +
        '(' + IntToStr(m_MasterHuman.m_nCurrX) + ':' +
        IntToStr(m_MasterHuman.m_nCurrY) + ')', c_Green, t_Hint);
      m_MasterHuman.SysMsg(g_sYourMasterListSearchLocateMsg, c_Green, t_Hint);
      m_MasterHuman.SysMsg(m_sCharName + ' ' + m_PEnvir.sMapDesc + '(' +
        IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) + ')', c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdSearchMaster');
  end;
end;

procedure TPlayObject.CmdSetPermission(Cmd: pTGameCmd; sHumanName, sPermission:
  string);
var
  nPerission: Integer;
  PlayObject: TPlayObject;
resourcestring
  sOutFormatMsg = '[权限调整] %s (%s %d -> %d)';
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    nPerission := Str_ToInt(sPermission, 0);
    if (sHumanName = '') or not (nPerission in [0..10]) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 权限等级(0 - 10)', c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    if g_Config.boShowMakeItemMsg then
      MainOutMessage(format(sOutFormatMsg, [m_sCharName, PlayObject.m_sCharName,
        PlayObject.m_btPermission, nPerission]));
    PlayObject.m_btPermission := nPerission;
    SysMsg(sHumanName + ' 当前权限为: ' +
      IntToStr(PlayObject.m_btPermission), c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdSetPermission');
  end;
end;

procedure TPlayObject.CmdShowHumanFlag(sCmd: string; nPermission: Integer;
  sHumanName, sFlag: string);
var
  PlayObject: TPlayObject;
  nFlag: Integer;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandShowHumanFlagHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    nFlag := Str_ToInt(sFlag, 0);
    if PlayObject.GetQuestFalgStatus(nFlag) = 1 then
    begin
      SysMsg(format(g_sGameCommandShowHumanFlagONMsg, [PlayObject.m_sCharName,
        nFlag]), c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sGameCommandShowHumanFlagOFFMsg, [PlayObject.m_sCharName,
        nFlag]), c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowHumanFlag');
  end;
end;

procedure TPlayObject.CmdShowHumanUnit(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
var
  PlayObject: TPlayObject;
  nUnit: Integer;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    nUnit := Str_ToInt(sUnit, 0);
    if PlayObject.GetQuestFalgStatus(nUnit) = 1 then
    begin
      SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName,
        nUnit]), c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName,
        nUnit]), c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowHumanUnit');
  end;
end;

procedure TPlayObject.CmdShowHumanUnitOpen(sCmd: string; nPermission: Integer;
  sHumanName, sUnit: string);
var
  PlayObject: TPlayObject;
  nUnit: Integer;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandShowHumanUnitHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    nUnit := Str_ToInt(sUnit, 0);
    if PlayObject.GetQuestFalgStatus(nUnit) = 1 then
    begin
      SysMsg(format(g_sGameCommandShowHumanUnitONMsg, [PlayObject.m_sCharName,
        nUnit]), c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sGameCommandShowHumanUnitOFFMsg, [PlayObject.m_sCharName,
        nUnit]), c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowHumanUnitOpen');
  end;
end;

procedure TPlayObject.CmdShowMapInfo(Cmd: pTGameCmd; sParam1: string);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    SysMsg(format(g_sGameCommandMapInfoMsg, [m_PEnvir.sMapName,
      m_PEnvir.sMapDesc]), c_Green, t_Hint);
    SysMsg(format(g_sGameCommandMapInfoSizeMsg, [m_PEnvir.Header.wWidth,
      m_PEnvir.Header.wHeight]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowMapInfo');
  end;
end;

procedure TPlayObject.CmdShowMapMode(sCmd, sMapName: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sMapName = '') then
    begin
      SysMsg('命令格式: @' + sCmd + ' 地图号', c_Red, t_Hint);
      exit;
    end;
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) then
    begin
      SysMsg(sMapName + ' 不存在！！！', c_Red, t_Hint);
      exit;
    end;
    sMsg := '地图模式: ' + Envir.GetEnvirInfo;
    SysMsg(sMsg, c_Blue, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowMapMode');
  end;
end;

procedure TPlayObject.CmdSetMapMode(sCmd, sMapName, sMapMode, sParam1,
  sParam2: string);
var
  Envir: TEnvirnoment;
  sMsg: string;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sMapName = '') or (sMapMode = '') then
    begin
      SysMsg('命令格式: @' + sCmd + ' 地图号 模式', c_Red, t_Hint);
      exit;
    end;
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) then
    begin
      SysMsg(sMapName + ' 不存在！！！', c_Red, t_Hint);
      exit;
    end;
    if CompareText(sMapMode, 'SAFE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boSAFE := True;
      end
      else
      begin
        Envir.Flag.boSAFE := False;
      end;
    end
    else if CompareText(sMapMode, 'DARK') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boDarkness := True;
      end
      else
      begin
        Envir.Flag.boDarkness := False;
      end;
    end
    else if CompareText(sMapMode, 'FIGHT') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boFightZone := True;
      end
      else
      begin
        Envir.Flag.boFightZone := False;
      end;
    end
    else if CompareText(sMapMode, 'FIGHT3') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boFight3Zone := True;
      end
      else
      begin
        Envir.Flag.boFight3Zone := False;
      end;
    end
    else if CompareText(sMapMode, 'DAY') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boDayLight := True;
      end
      else
      begin
        Envir.Flag.boDayLight := False;
      end;
    end
    else if CompareText(sMapMode, 'QUIZ') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boQUIZ := True;
      end
      else
      begin
        Envir.Flag.boQUIZ := False;
      end;
    end
    else if CompareText(sMapMode, 'NORECONNECT') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNORECONNECT := True;
        Envir.Flag.sNoReconnectMap := sParam1;
      end
      else
      begin
        Envir.Flag.boNORECONNECT := False;
      end;
    end
    else if CompareText(sMapMode, 'MUSIC') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boMUSIC := True;
        Envir.Flag.sMusic := sParam1;
      end
      else
      begin
        Envir.Flag.boMUSIC := False;
      end;
    end
    else if CompareText(sMapMode, 'EXPRATE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boEXPRATE := True;
        Envir.Flag.nEXPRATE := Str_ToInt(sParam1, -1);
      end
      else
      begin
        Envir.Flag.boEXPRATE := False;
      end;
    end
    else if CompareText(sMapMode, 'PKWINLEVEL') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boPKWINLEVEL := True;
        Envir.Flag.nPKWINLEVEL := Str_ToInt(sParam1, -1);
      end
      else
      begin
        Envir.Flag.boPKWINLEVEL := False;
      end;
    end
    else if CompareText(sMapMode, 'PKWINEXP') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boPKWINEXP := True;
        Envir.Flag.nPKWINEXP := Str_ToInt(sParam1, -1);
      end
      else
      begin
        Envir.Flag.boPKWINEXP := False;
      end;
    end
    else if CompareText(sMapMode, 'PKLOSTLEVEL') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boPKLOSTLEVEL := True;
        Envir.Flag.nPKLOSTLEVEL := Str_ToInt(sParam1, -1);
      end
      else
      begin
        Envir.Flag.boPKLOSTLEVEL := False;
      end;
    end
    else if CompareText(sMapMode, 'PKLOSTEXP') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boPKLOSTEXP := True;
        Envir.Flag.nPKLOSTEXP := Str_ToInt(sParam1, -1);
      end
      else
      begin
        Envir.Flag.boPKLOSTEXP := False;
      end;
    end
    else if CompareText(sMapMode, 'DECHP') = 0 then
    begin
      if (sParam1 <> '') and (sParam2 <> '') then
      begin
        Envir.Flag.boDECHP := True;
        Envir.Flag.nDECHPTIME := Str_ToInt(sParam1, -1);
        Envir.Flag.nDECHPPOINT := Str_ToInt(sParam2, -1);
      end
      else
      begin
        Envir.Flag.boDECHP := False;
      end;
    end
    else if CompareText(sMapMode, 'DECGAMEGOLD') = 0 then
    begin
      if (sParam1 <> '') and (sParam2 <> '') then
      begin
        Envir.Flag.boDECGAMEGOLD := True;
        Envir.Flag.nDECGAMEGOLDTIME := Str_ToInt(sParam1, -1);
        Envir.Flag.nDECGAMEGOLD := Str_ToInt(sParam2, -1);
      end
      else
      begin
        Envir.Flag.boDECGAMEGOLD := False;
      end;
    end
    else if CompareText(sMapMode, 'INCGAMEGOLD') = 0 then
    begin
      if (sParam1 <> '') and (sParam2 <> '') then
      begin
        Envir.Flag.boINCGAMEGOLD := True;
        Envir.Flag.nINCGAMEGOLDTIME := Str_ToInt(sParam1, -1);
        Envir.Flag.nINCGAMEGOLD := Str_ToInt(sParam2, -1);
      end
      else
      begin
        Envir.Flag.boINCGAMEGOLD := False;
      end;
    end
    else if CompareText(sMapMode, 'INCGAMEPOINT') = 0 then
    begin
      if (sParam1 <> '') and (sParam2 <> '') then
      begin
        Envir.Flag.boINCGAMEPOINT := True;
        Envir.Flag.nINCGAMEPOINTTIME := Str_ToInt(sParam1, -1);
        Envir.Flag.nINCGAMEPOINT := Str_ToInt(sParam2, -1);
      end
      else
      begin
        Envir.Flag.boINCGAMEGOLD := False;
      end;
    end
    else if CompareText(sMapMode, 'RUNHUMAN') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boRUNHUMAN := True;
      end
      else
      begin
        Envir.Flag.boRUNHUMAN := False;
      end;
    end
    else if CompareText(sMapMode, 'RUNMON') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boRUNMON := True;
      end
      else
      begin
        Envir.Flag.boRUNMON := False;
      end;
    end
    else if CompareText(sMapMode, 'NEEDHOLE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNEEDHOLE := True;
      end
      else
      begin
        Envir.Flag.boNEEDHOLE := False;
      end;
    end
    else if CompareText(sMapMode, 'NORECALL') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNORECALL := True;
      end
      else
      begin
        Envir.Flag.boNORECALL := False;
      end;
    end
    else if CompareText(sMapMode, 'NOGUILDRECALL') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNOGUILDRECALL := True;
      end
      else
      begin
        Envir.Flag.boNOGUILDRECALL := False;
      end;
    end
    else if CompareText(sMapMode, 'NODEARRECALL') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNODEARRECALL := True;
      end
      else
      begin
        Envir.Flag.boNODEARRECALL := False;
      end;
    end
    else if CompareText(sMapMode, 'NOMASTERRECALL') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNOMASTERRECALL := True;
      end
      else
      begin
        Envir.Flag.boNOMASTERRECALL := False;
      end;
    end
    else if CompareText(sMapMode, 'NORANDOMMOVE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNORANDOMMOVE := True;
      end
      else
      begin
        Envir.Flag.boNORANDOMMOVE := False;
      end;
    end
    else if CompareText(sMapMode, 'NODRUG') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNODRUG := True;
      end
      else
      begin
        Envir.Flag.boNODRUG := False;
      end;
    end
    else if CompareText(sMapMode, 'MINE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boMINE := True;
      end
      else
      begin
        Envir.Flag.boMINE := False;
      end;
    end
    else if CompareText(sMapMode, 'MINE2') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boMINE2 := True;
      end
      else
      begin
        Envir.Flag.boMINE2 := False;
      end;
    end
    else if CompareText(sMapMode, 'NOTHROWITEM') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNOTHROWITEM := True;
      end
      else
      begin
        Envir.Flag.boNOTHROWITEM := False;
      end;
    end
    else if CompareText(sMapMode, 'NODROPITEM') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNODROPITEM := True;
      end
      else
      begin
        Envir.Flag.boNODROPITEM := False;
      end;
    end
    else if CompareText(sMapMode, 'NOPOSITIONMOVE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNOPOSITIONMOVE := True;
      end
      else
      begin
        Envir.Flag.boNOPOSITIONMOVE := False;
      end;
    end
    else if CompareText(sMapMode, 'NOHORSE') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNOHORSE := True;
      end
      else
      begin
        Envir.Flag.boNOHORSE := False;
      end;
    end
    else if CompareText(sMapMode, 'NOCHAT') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boNOCHAT := True;
      end
      else
      begin
        Envir.Flag.boNOCHAT := False;
      end;
    end
    else if CompareText(sMapMode, 'SHOP') = 0 then
    begin
      if (sParam1 <> '') then
      begin
        Envir.Flag.boSHOP := True;
      end
      else
      begin
        Envir.Flag.boSHOP := False;
      end;
    end;
    sMsg := 'Environment: ' + Envir.GetEnvirInfo;
    SysMsg(sMsg, c_Blue, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdSetMapMode');
  end;
end;

procedure TPlayObject.CmdDeleteItem(Cmd: pTGameCmd; sHumanName, sItemName:
  string; nCount: Integer); //004CDFF8
var
  I: Integer;
  PlayObject: TPlayObject;
  nItemCount: Integer;
  StdItem: TItem;
  UserItem: pTUserItem;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or (sItemName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 物品名称 数量)', c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    nItemCount := 0;
    for I := PlayObject.m_ItemList.Count - 1 downto 0 do
    begin //Jason 0714
      UserItem := PlayObject.m_ItemList.Items[I];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if (StdItem <> nil) and (CompareText(sItemName, StdItem.Name) = 0) then
      begin
        PlayObject.SendDelItems(UserItem);
        Dispose(UserItem);
        PlayObject.m_ItemList.Delete(I);
        Inc(nItemCount);
        if nItemCount >= nCount then
          break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDeleteItem');
  end;
end;

procedure TPlayObject.CmdDelGold(Cmd: pTGameCmd; sHumName: string; nCount:
  Integer); //004CD27C
var
  PlayObject: TPlayObject;
  nServerIndex: integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumName = '') or (nCount <= 0) then
      exit;
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      if PlayObject.m_nGold > nCount then
      begin
        Dec(PlayObject.m_nGold, nCount);
      end
      else
      begin
        nCount := PlayObject.m_nGold;
        PlayObject.m_nGold := 0;
      end;
      PlayObject.GoldChanged();
      SysMsg(sHumName + '的金币已减少' + IntToStr(nCount) + '.', c_Green,
        t_Hint);
      //004CD409
      if g_boGameLogGold then
        AddGameDataLog('13' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          sSTRING_GOLDNAME + #9 +
          IntToStr(nCount) + #9 +
          '1' + #9 +
          sHumName);
    end
    else
    begin
      if UserEngine.FindOtherServerUser(sHumName, nServerIndex) then
      begin
        SysMsg(sHumName + '现在' + IntToStr(nServerIndex) + '号服务器上',
          c_Green, t_Hint);
      end
      else
      begin
        FrontEngine.AddChangeGoldList(m_sCharName, sHumName, -nCount);
        SysMsg(sHumName +
          '现在不在线，等其上线时金币将自动减少', c_Green,
          t_Hint);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelGold');
  end;
end;

procedure TPlayObject.CmdDelGuild(Cmd: pTGameCmd; sGuildName: string); //004CEDEC
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if nServerIndex <> 0 then
    begin
      SysMsg('只能在主服务器上才可以使用此命令删除行会！！！', c_Red, t_Hint);
      exit;
    end;
    if sGuildName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 行会名称', c_Red, t_Hint);
      exit;
    end;
    if g_GuildManager.DelGuild(sGuildName) then
    begin
      UserEngine.SendServerGroupMsg(SS_206, nServerIndex, sGuildName);
    end
    else
    begin
      SysMsg('没找到' + sGuildName + '这个行会！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelGuild');
  end;
end;

procedure TPlayObject.CmdDelNpc(sCmd: string; nPermission: Integer; sParam1:
  string);
var
  BaseObject: TBaseObject;
  I: Integer;
resourcestring
  sDelOK = '删除NPC成功...';
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    BaseObject := GetPoseCreate();
    if BaseObject <> nil then
    begin
      for I := 0 to UserEngine.m_MerchantList.Count - 1 do
      begin
        if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then
        begin
          BaseObject.m_boGhost := True;
          BaseObject.m_dwGhostTick := GetTickCount();
          BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
          SysMsg(sDelOK, c_Red, t_Hint);
          exit;
        end;
      end;
      for I := 0 to UserEngine.QuestNPCList.Count - 1 do
      begin
        if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then
        begin
          BaseObject.m_boGhost := True;
          BaseObject.m_dwGhostTick := GetTickCount();
          BaseObject.SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
          SysMsg(sDelOK, c_Red, t_Hint);
          exit;
        end;
      end;
    end;
    SysMsg(g_sGameCommandDelNpcMsg, c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelNpc');
  end;
end;

procedure TPlayObject.CmdDelSkill(Cmd: pTGameCmd; sHumanName, sSkillName:
  string);
var
  I: Integer;
  PlayObject: TPlayObject;
  boDelAll: Boolean;
  UserMagic: pTUserMagic;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or (sSkillName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 技能名称)',
        c_Red, t_Hint);
      exit;
    end;
    if CompareText(sSkillName, 'All') = 0 then
      boDelAll := True
    else
      boDelAll := False;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;

    for I := PlayObject.m_MagicList.Count - 1 downto 0 do
    begin
      UserMagic := PlayObject.m_MagicList.Items[I];
      if boDelAll then
      begin
        PlayObject.SendDelMagic(UserMagic);
        Dispose(UserMagic);
        PlayObject.m_MagicList.Delete(I);
      end
      else
      begin
        if CompareText(UserMagic.MagicInfo.sMagicName, sSkillName) = 0 then
        begin
          PlayObject.SendDelMagic(UserMagic);
          Dispose(UserMagic);
          PlayObject.m_MagicList.Delete(I);
          PlayObject.SysMsg(format('技能%s已删除。', [sSkillName]),
            c_Green, t_Hint);
          SysMsg(format('%s的技能%s已删除。', [sHumanName, sSkillName]),
            c_Green, t_Hint);
          break;
        end;
      end;
    end;
    PlayObject.RecalcAbilitys;
    PlayObject.SendMsg(PlayObject, RM_SUBABILITY, 0, 0, 0, 0, '');
    //PlayObject.SendMsg(PlayObject,RM_ABILITY,0,0,0,0,'');
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelSkill');
  end;
end;

procedure TPlayObject.CmdDenyAccountLogon(Cmd: pTGameCmd; sAccount, sFixDeny:
  string);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sAccount = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 登录帐号 是否永久封(0,1)', c_Red, t_Hint);
      exit;
    end;
    g_DenyAccountList.Lock;
    try
      if (sFixDeny <> '') and (sFixDeny[1] = '1') then
      begin
        g_DenyAccountList.AddObject(sAccount, TObject(1));
        SaveDenyAccountList();
        SysMsg(sAccount + '已加入禁止登录帐号列表', c_Green, t_Hint);
      end
      else
      begin
        g_DenyAccountList.AddObject(sAccount, TObject(0));
        SysMsg(sAccount + '已加入临时禁止登录帐号列表', c_Green,
          t_Hint);
      end;
    finally
      g_DenyAccountList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDenyAccountLogon');
  end;
end;

procedure TPlayObject.CmdDenyCharNameLogon(Cmd: pTGameCmd; sCharName, sFixDeny:
  string);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sCharName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd +
        ' 人物名称 是否永久封(0,1)', c_Red, t_Hint);
      exit;
    end;
    g_DenyChrNameList.Lock;
    try
      if (sFixDeny <> '') and (sFixDeny[1] = '1') then
      begin
        g_DenyChrNameList.AddObject(sCharName, TObject(1));
        SaveDenyChrNameList();
        SysMsg(sCharName + '已加入禁止人物列表', c_Green, t_Hint);
      end
      else
      begin
        g_DenyChrNameList.AddObject(sCharName, TObject(0));
        SysMsg(sCharName + '已加入临时禁止人物列表', c_Green,
          t_Hint);
      end;
    finally
      g_DenyChrNameList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDenyCharNameLogon');
  end;
end;

procedure TPlayObject.CmdDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr, sFixDeny:
  string);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sIPaddr = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址 是否永久封(0,1)',
        c_Red, t_Hint);
      exit;
    end;
    g_DenyIPAddrList.Lock;
    try
      if (sFixDeny <> '') and (sFixDeny[1] = '1') then
      begin
        g_DenyIPAddrList.AddObject(sIPaddr, TObject(1));
        SaveDenyIPAddrList();
        SysMsg(sIPaddr + '已加入禁止登录IP列表', c_Green, t_Hint);
      end
      else
      begin
        g_DenyIPAddrList.AddObject(sIPaddr, TObject(0));
        SysMsg(sIPaddr + '已加入临时禁止登录IP列表', c_Green,
          t_Hint);
      end;
    finally
      g_DenyIPAddrList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDenyIPaddrLogon');
  end;
end;

procedure TPlayObject.CmdDisableFilter(sCmd, sParam1: string);
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sParam1 <> '') and (sParam1[1] = '?') then
    begin
      SysMsg('启用/禁止文字过滤功能。', c_Red, t_Hint);
      exit;
    end;
    boFilterWord := not boFilterWord;
    if boFilterWord then
    begin
      SysMsg('已启用文字过滤。', c_Green, t_Hint);
    end
    else
    begin
      SysMsg('已禁止文字过滤。', c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDisableFilter');
  end;
end;

procedure TPlayObject.CmdDelDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sAccount = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 登录帐号', c_Red, t_Hint);
      exit;
    end;
    boDelete := False;
    g_DenyAccountList.Lock;
    try
      for I := 0 to g_DenyAccountList.Count - 1 do
      begin
        if CompareText(sAccount, g_DenyAccountList.Strings[I]) = 0 then
        begin
          if Integer(g_DenyAccountList.Objects[I]) <> 0 then
            SaveDenyAccountList;
          g_DenyAccountList.Delete(I);
          SysMsg(sAccount + '已从禁止登录帐号列表中删除。',
            c_Green, t_Hint);
          boDelete := True;
          break;
        end;
      end;
    finally
      g_DenyAccountList.UnLock;
    end;
    if not boDelete then
      SysMsg(sAccount + '没有被禁止登录。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelDenyAccountLogon');
  end;
end;

procedure TPlayObject.CmdDelDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sCharName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    boDelete := False;
    g_DenyChrNameList.Lock;
    try
      for I := 0 to g_DenyChrNameList.Count - 1 do
      begin
        if CompareText(sCharName, g_DenyChrNameList.Strings[I]) = 0 then
        begin
          if Integer(g_DenyChrNameList.Objects[I]) <> 0 then
            SaveDenyChrNameList;
          g_DenyChrNameList.Delete(I);
          SysMsg(sCharName + '已从禁止登录人物列表中删除。',
            c_Green, t_Hint);
          boDelete := True;
          break;
        end;
      end;
    finally
      g_DenyChrNameList.UnLock;
    end;
    if not boDelete then
      SysMsg(sCharName + '没有被禁止登录。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelDenyCharNameLogon');
  end;
end;

procedure TPlayObject.CmdDelDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  I: Integer;
  boDelete: Boolean;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sIPaddr = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' IP地址', c_Red, t_Hint);
      exit;
    end;
    boDelete := False;
    g_DenyIPAddrList.Lock;
    try
      for I := 0 to g_DenyIPAddrList.Count - 1 do
      begin
        if CompareText(sIPaddr, g_DenyIPAddrList.Strings[I]) = 0 then
        begin
          if Integer(g_DenyIPAddrList.Objects[I]) <> 0 then
            SaveDenyIPAddrList;
          g_DenyIPAddrList.Delete(I);
          SysMsg(sIPaddr + '已从禁止登录IP列表中删除。', c_Green,
            t_Hint);
          boDelete := True;
          break;
        end;
      end;
    finally
      g_DenyIPAddrList.UnLock;
    end;
    if not boDelete then
      SysMsg(sIPaddr + '没有被禁止登录。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdDelDenyIPaddrLogon');
  end;
end;

procedure TPlayObject.CmdShowDenyAccountLogon(Cmd: pTGameCmd; sAccount,
  sFixDeny: string);
var
  I: Integer;
begin
  try
    if (m_btPermission < 6) then
      exit;
    g_DenyAccountList.Lock;
    try
      if g_DenyAccountList.Count <= 0 then
      begin
        SysMsg('禁止登录帐号列表为空。', c_Green, t_Hint);
        exit;
      end;
      for I := 0 to g_DenyAccountList.Count - 1 do
      begin
        SysMsg(g_DenyAccountList.Strings[I], c_Green, t_Hint);
      end;
    finally
      g_DenyAccountList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowDenyAccountLogon');
  end;
end;

procedure TPlayObject.CmdShowDenyCharNameLogon(Cmd: pTGameCmd; sCharName,
  sFixDeny: string);
var
  I: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    g_DenyChrNameList.Lock;
    try
      if g_DenyChrNameList.Count <= 0 then
      begin
        SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
        exit;
      end;
      for I := 0 to g_DenyChrNameList.Count - 1 do
      begin
        SysMsg(g_DenyChrNameList.Strings[I], c_Green, t_Hint);
      end;
    finally
      g_DenyChrNameList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowDenyCharNameLogon');
  end;
end;

procedure TPlayObject.CmdShowDenyIPaddrLogon(Cmd: pTGameCmd; sIPaddr,
  sFixDeny: string);
var
  I: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    g_DenyIPAddrList.Lock;
    try
      if g_DenyIPAddrList.Count <= 0 then
      begin
        SysMsg('禁止登录角色列表为空。', c_Green, t_Hint);
        exit;
      end;
      for I := 0 to g_DenyIPAddrList.Count - 1 do
      begin
        SysMsg(g_DenyIPAddrList.Strings[I], c_Green, t_Hint);
      end;
    finally
      g_DenyIPAddrList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowDenyIPaddrLogon');
  end;
end;

procedure TPlayObject.CmdDisableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sHumanName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      PlayObject.m_boFilterSendMsg := True;
    end;
    g_DisableSendMsgList.Add(sHumanName);
    SaveDisableSendMsgList();
    SysMsg(sHumanName + ' 已加入禁言列表。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdDisableSendMsg');
  end;
end;

procedure TPlayObject.CmdDisableSendMsgList(Cmd: pTGameCmd);
var
  I: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if g_DisableSendMsgList.Count <= 0 then
    begin
      SysMsg('禁言列表为空！！！', c_Red, t_Hint);
      exit;
    end;

    SysMsg('禁言列表:', c_Blue, t_Hint);
    for I := 0 to g_DisableSendMsgList.Count - 1 do
    begin
      SysMsg(g_DisableSendMsgList.Strings[I], c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdDisableSendMsgList');
  end;
end;

procedure TPlayObject.CmdEnableSendMsg(Cmd: pTGameCmd; sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sHumanName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称', c_Red, t_Hint);
      exit;
    end;
    for I := 0 to g_DisableSendMsgList.Count - 1 do
    begin
      if CompareText(sHumanName, g_DisableSendMsgList.Strings[I]) = 0 then
      begin
        PlayObject := UserEngine.GeTPlayObject(sHumanName);
        if PlayObject <> nil then
        begin
          PlayObject.m_boFilterSendMsg := False;
        end;
        g_DisableSendMsgList.Delete(I);
        SaveDisableSendMsgList();
        SysMsg(sHumanName + ' 已从禁言列表中删除。', c_Green, t_Hint);
        exit;
      end;
    end;
    SysMsg(sHumanName + ' 没有被禁言！！！', c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdEnableSendMsg');
  end;
end;

procedure TPlayObject.CmdEndGuild; //4D1A44
begin
  try
    if (m_MyGuild <> nil) then
    begin
      if (m_nGuildRankNo > 1) then
      begin
        if TGuild(m_MyGuild).IsMember(m_sCharName) and
          TGuild(m_MyGuild).DelMember(m_sCharName) then
        begin
          UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
            TGuild(m_MyGuild).sGuildName);
          m_MyGuild := nil;
          RefRankInfo(0, '');
          RefShowName(); //10/31
          SysMsg('你已经退出行会。', c_Green, t_Hint);
        end;
      end
      else
      begin
        SysMsg('行会掌门人不能这样退出行会！！！', c_Red,
          t_Hint);
      end;
    end
    else
    begin
      SysMsg('你都没加入行会！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdEndGuild');
  end;
end;

procedure TPlayObject.CmdFireBurn(nInt, nTime, nN: Integer);
var
  FireBurnEvent: TFireBurnEvent;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (nInt = 0) or (nTime = 0) or (nN = 0) then
    begin
      SysMsg('命令格式: @' + g_GameCommand.FIREBURN.sCmd + ' nInt nTime nN',
        c_Red, t_Hint);
      exit;
    end;
    FireBurnEvent := TFireBurnEvent.Create(Self, m_nCurrX, m_nCurrY, nInt,
      nTime, nN);
    g_EventManager.AddEvent(FireBurnEvent);
  except
    MainOutMessage('[Exception] TPlayObject.CmdFireBurn');
  end;
end;

procedure TPlayObject.CmdForcedWallconquestWar(Cmd: pTGameCmd; sCastleName:
  string);
var
  Castle: TUserCastle;
  s20: string;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;

    if sCastleName = '' then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 城堡名称', c_Red, t_Hint);
      exit;
    end;

    Castle := g_CastleManager.Find(sCastleName);
    if Castle <> nil then
    begin
      Castle.m_boUnderWar := not Castle.m_boUnderWar;
      if Castle.m_boUnderWar then
      begin
        Castle.m_dwStartCastleWarTick := GetTickCount();
        Castle.StartWallconquestWar();

        UserEngine.SendServerGroupMsg(SS_212, nServerIndex, '');
        s20 := '[' + Castle.m_sName + '攻城战已经开始]';
        UserEngine.SendBroadCastMsg(s20, t_System);
        UserEngine.SendServerGroupMsg(SS_204, nServerIndex, s20);
        Castle.MainDoorControl(True);
      end
      else
      begin
        Castle.StopWallconquestWar();
      end;
    end
    else
    begin
      SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCastleName]),
        c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdForcedWallconquestWar');
  end;
end;

procedure TPlayObject.CmdFreePenalty(Cmd: pTGameCmd; sHumanName: string);
//004CC528
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandFreePKHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    PlayObject.m_nPkPoint := 0;
    PlayObject.RefNameColor();
    PlayObject.SysMsg(g_sGameCommandFreePKHumanMsg, c_Green, t_Hint);
    SysMsg(format(g_sGameCommandFreePKMsg, [sHumanName]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdFreePenalty');
  end;
end;

procedure TPlayObject.CmdGroupRecall(sCMD: string);
var
  I: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
begin
  try
    if m_boRecallSuite or (m_btPermission >= 6) then
    begin
      if not m_PEnvir.Flag.boNORECALL then
      begin
        dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
        m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
        if m_btPermission >= 6 then
          m_wGroupRcallTime := 0;

        if m_wGroupRcallTime > dwValue then
        begin
          Dec(m_wGroupRcallTime, dwValue);
        end
        else
          m_wGroupRcallTime := 0;
        if m_wGroupRcallTime = 0 then
        begin
          if m_GroupOwner = Self then
          begin
            for I := 1 to m_GroupMembers.Count - 1 do
            begin
              PlayObject := TPlayObject(m_GroupMembers.Objects[I]);
              if PlayObject.m_boAllowGroupReCall then
              begin
                if PlayObject.m_PEnvir.Flag.boNORECALL then
                begin
                  SysMsg(format(g_sTheMapDisableMove, [PlayObject.m_sCharName]),
                    c_Red, t_Hint);
                end
                else
                begin
                  RecallHuman(PlayObject.m_sCharName);
                end;
              end
              else
              begin
                SysMsg(format('%s 不允许天地合一.',
                  [PlayObject.m_sCharName]), c_Red, t_Hint);
              end;
            end;
            m_dwGroupRcallTick := GetTickCount();
            m_wGroupRcallTime := g_Config.nGroupRecallTime;
          end;
        end
        else
        begin
          SysMsg(format('%d 秒钟以后才能继续使用.',
            [m_wGroupRcallTime]), c_Red, t_Hint);
        end;
      end
      else
      begin
        SysMsg('此地图禁止使用此命令！！！', c_Red, t_Hint);
      end;
    end
    else
    begin
      SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdGroupRecall');
  end;
end;

procedure TPlayObject.CmdGuildRecall(sCmd, sParam: string);
var
  I, II: Integer;
  dwValue: LongWord;
  PlayObject: TPlayObject;
  GuildRank: pTGuildRank;
  nRecallCount, nNoRecallCount: Integer;
  Castle: TUserCastle;
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('命令功能: 行会传送，行会掌门人可以将整个行会成员全部集中。', c_Red, t_Hint);
      exit;
    end;

    if not m_boGuildMove and (m_btPermission < 6) then
    begin
      SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    if not IsGuildMaster then
    begin
      SysMsg('行会掌门人才可以使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    if m_PEnvir.Flag.boNOGUILDRECALL then
    begin
      SysMsg('本地图不允许使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    Castle := g_CastleManager.InCastleWarArea(Self);

    //if UserCastle.m_boUnderWar and UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY) then begin
    if (Castle <> nil) and Castle.m_boUnderWar then
    begin
      SysMsg('攻城区域不允许使用此功能！！！', c_Red, t_Hint);
      exit;
    end;
    nRecallCount := 0;
    nNoRecallCount := 0;
    dwValue := (GetTickCount - m_dwGroupRcallTick) div 1000;
    m_dwGroupRcallTick := m_dwGroupRcallTick + dwValue * 1000;
    if m_btPermission >= 6 then
      m_wGroupRcallTime := 0;
    if m_wGroupRcallTime > dwValue then
    begin
      Dec(m_wGroupRcallTime, dwValue);
    end
    else
      m_wGroupRcallTime := 0;

    if m_wGroupRcallTime > 0 then
    begin
      SysMsg(format('%d 秒之后才可以再使用此功能！！！',
        [m_wGroupRcallTime]), c_Red, t_Hint);
      exit;
    end;

    for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
    begin
      GuildRank := TGuild(m_MyGuild).m_RankList.Items[I];
      for II := 0 to GuildRank.MemberList.Count - 1 do
      begin
        PlayObject := TPlayObject(GuildRank.MemberList.Objects[II]);
        if PlayObject <> nil then
        begin
          if PlayObject = Self then
          begin
            //          Inc(nNoRecallCount);
            Continue;
          end;
          if PlayObject.m_boAllowGuildReCall then
          begin
            if PlayObject.m_PEnvir.Flag.boNORECALL then
            begin
              SysMsg(format('%s 所在的地图不允许传送。',
                [PlayObject.m_sCharName]), c_Red, t_Hint);
            end
            else
            begin
              RecallHuman(PlayObject.m_sCharName);
              Inc(nRecallCount);
            end;
          end
          else
          begin
            Inc(nNoRecallCount);
            SysMsg(format('%s 不允许行会合一！！！',
              [PlayObject.m_sCharName]), c_Red, t_Hint);
          end;
        end;
      end;
    end;
    //  SysMsg('已传送' + IntToStr(nRecallCount) + '个成员，' + IntToStr(nNoRecallCount) + '个成员未被传送。',c_Green,t_Hint);
    SysMsg(format('已传送%d个成员，%d个成员未被传送。',
      [nRecallCount, nNoRecallCount]), c_Green, t_Hint);
    m_dwGroupRcallTick := GetTickCount();
    m_wGroupRcallTime := g_Config.nGuildRecallTime;
  except
    MainOutMessage('[Exception] TPlayObject.CmdGuildRecall');
  end;
end;

procedure TPlayObject.CmdGuildWar(sCmd, sGuildName: string); //004CE9F0
begin
  try
    if (m_btPermission < 6) then
      exit;
  except
    MainOutMessage('[Exception] TPlayObject.CmdGuildWar');
  end;
end;

procedure TPlayObject.CmdHair(Cmd: pTGameCmd; sHumanName: string; nHair:
  Integer);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or (nHair < 0) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 人物名称 类型值', c_Red,
        t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      PlayObject.m_btHair := nHair;
      PlayObject.FeatureChanged();
      SysMsg(sHumanName + ' 的头发已改变。', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdHair');
  end;
end;

procedure TPlayObject.CmdHumanInfo(Cmd: pTGameCmd; sHumanName: string);
//004CFC98
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandInfoHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    SysMsg(PlayObject.GeTBaseObjectInfo(), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdHumanInfo');
  end;
end;

procedure TPlayObject.CmdHumanLocal(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandHumanLocalHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    SysMsg(format(g_sGameCommandHumanLocalMsg, [sHumanName, m_sIPLocal
      {GetIPLocal(PlayObject.m_sIPaddr)}]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdHumanLocal');
  end;
end;

procedure TPlayObject.CmdHunger(sCmd, sHumanName: string; nHungerPoint:
  Integer);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sHumanName = '') or (nHungerPoint < 0) then
    begin
      SysMsg('命令格式: @' + sCMD + ' 人物名称 能量值', c_Red,
        t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      PlayObject.m_nHungerStatus := nHungerPoint;
      PlayObject.SendMsg(PlayObject, RM_MYSTATUS, 0, 0, 0, 0, '');
      PlayObject.RefMyStatus();
      SysMsg(sHumanName + ' 的能量值已改变。', c_Green, t_Hint);
    end
    else
    begin
      SysMsg(sHumanName + '没有在线！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdHunger');
  end;
end;

procedure TPlayObject.CmdIncPkPoint(Cmd: pTGameCmd; sHumanName: string; nPoint:
  Integer); //004BF4D4
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandIncPkPointHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    Inc(PlayObject.m_nPkPoint, nPoint);
    PlayObject.RefNameColor();
    if nPoint > 0 then
      SysMsg(format(g_sGameCommandIncPkPointAddPointMsg, [sHumanName, nPoint]),
        c_Green, t_Hint)
    else
      SysMsg(format(g_sGameCommandIncPkPointDecPointMsg, [sHumanName, -nPoint]),
        c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdIncPkPoint');
  end;
end;

procedure TPlayObject.CmdKickHuman(Cmd: pTGameCmd; sHumName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumName = '') or ((sHumName <> '') and (sHumName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandKickHumanHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      PlayObject.m_boKickFlag := True;
      PlayObject.m_boEmergencyClose := True;
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdKickHuman');
  end;
end;

procedure TPlayObject.CmdKill(Cmd: pTGameCmd; sHumanName: string);
var
  BaseObject: TBaseObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if sHumanName <> '' then
    begin
      BaseObject := UserEngine.GeTPlayObject(sHumanName);
      if BaseObject = nil then
      begin
        SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
          t_Hint);
        exit;
      end;
    end
    else
    begin
      BaseObject := GetPoseCreate();
      if BaseObject = nil then
      begin
        SysMsg('命令使用方法不正确，必须与角色面对面站好！！！', c_Red, t_Hint);
        exit;
      end;
    end;
    BaseObject.Die;
  except
    MainOutMessage('[Exception] TPlayObject.CmdKill');
  end;
end;

procedure TPlayObject.CmdLockLogin(Cmd: pTGameCmd);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if not g_Config.boLockHumanLogin then
    begin
      SysMsg('本服务器还没有启用登录锁功能！！！', c_Red,
        t_Hint);
      exit;
    end;

    if m_boLockLogon and not m_boLockLogoned then
    begin
      SysMsg('您还没有打开登录锁或还没有设置锁密码！！！',
        c_Red, t_Hint);
      exit;
    end;

    m_boLockLogon := not m_boLockLogon;
    if m_boLockLogon then
    begin
      SysMsg('已开启登录锁', c_Green, t_Hint);
    end
    else
    begin
      SysMsg('已关闭登录锁', c_Green, t_Hint);
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdLockLogin');
  end;
end;

procedure TPlayObject.CmdLotteryTicket(sCmd: string; nPerMission: Integer;
  sParam1: string);
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    SysMsg(format(g_sGameCommandLotteryTicketMsg, [g_Config.nWinLotteryCount,
      g_Config.nNoWinLotteryCount,
        g_Config.nWinLotteryLevel1,
        g_Config.nWinLotteryLevel2,
        g_Config.nWinLotteryLevel3,
        g_Config.nWinLotteryLevel4,
        g_Config.nWinLotteryLevel5,
        g_Config.nWinLotteryLevel6]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdLotteryTicket');
  end;
end;

procedure TPlayObject.CmdLuckPoint(sCmd: string; nPerMission: Integer;
  sHumanName, sCtr, sPoint: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandLuckPointHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;

    if sCtr = '' then
    begin
      SysMsg(format(g_sGameCommandLuckPointMsg, [sHumanName,
        PlayObject.m_nBodyLuckLevel, PlayObject.m_dBodyLuck,
          PlayObject.m_nLuck]),
          c_Green, t_Hint);
      exit;
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdLuckPoint');
  end;
end;

procedure TPlayObject.CmdMakeItem(Cmd: pTGameCmd; sItemName: string; nCount:
  Integer); //004CCE34
function GetRandomRange(nCount, nRate: Integer): Integer;
var
  I: Integer;
begin
  try
    Result := 0;
    for I := 0 to nCount - 1 do
      if Random(nRate) = 0 then
        Inc(Result);
  except
    MainOutMessage('[Exception] TPlayObject.CmdMakeItem.GetRandomRange');
  end;
end;

  var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: TItem;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sItemName = '') then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGamecommandMakeHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    if (nCount <= 0) then
      nCount := 1;
    if (nCount > 10) then
      nCount := 10;
    if (m_btPermission < Cmd.nPermissionMax) then
    begin
      if not CanMakeItem(sItemName) then
      begin
        SysMsg(g_sGamecommandMakeItemNameOrPerMissionNot, c_Red, t_Hint);
        exit;
      end;
      //if UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurry) then begin
      if g_CastleManager.InCastleWarArea(Self) <> nil then
      begin
        SysMsg(g_sGamecommandMakeInCastleWarRange, c_Red, t_Hint);
        exit;
      end;
      if not InSafeZone then
      begin
        SysMsg(g_sGamecommandMakeInSafeZoneRange, c_Red, t_Hint);
        exit;
      end;
      //    nCount:=1;
      exit; // jason 0714
    end;

    for I := 0 to nCount - 1 do
    begin
      if m_ItemList.Count >= MAXBAGITEM then
        exit;
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        {if (StdItem.Price >= 15000) and not g_Config.boTestServer and (m_btPermission < 5)then begin
          Dispose(UserItem);
        end else begin}// Jason 0714取消
        if Random(g_Config.nMakeRandomAddValue {10}) = 0 then
          StdItem.RandomUpgradeItem(UserItem);
        //end;
        if StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26] then
        begin
          if StdItem.Shape in [130, 131, 132] then
          begin
            StdItem.RandomUpgradeUnknownItem(UserItem);
          end;
        end;
          if StdItem.StdMode=60 then
          begin
           UserItem.btValue[10]:=48+Random(12); //酒精度
           UserItem.btValue[7]:=8+Random(5); //品质
          end;
        if m_btPermission >= Cmd.nPermissionMax then
        begin
          UserItem.MakeIndex := GetItemNumberEx();
          //制造的物品另行取得物品ID

        end;
        m_ItemList.Add(UserItem);
        SendAddItem(UserItem);
        if g_Config.boShowMakeItemMsg and (m_btPermission >= 6) then
          MainOutMessage('[制造物品] ' + m_sCharName + ' ' + sItemName + '('
            + IntToStr(UserItem.MakeIndex) + ')');
        //004CD10D
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('5' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            '0');
      end
      else
      begin //004CD114
        Dispose(UserItem);
        SysMsg(format(g_sGamecommandMakeItemNameNotFound, [sItemName]), c_Red,
          t_Hint);
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdMakeItem');
  end;
end;

procedure TPlayObject.CmdMapMove(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandMoveHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    Envir := g_MapManager.FindMap(sMapName);
    if (Envir = nil) then
    begin
      SysMsg(format(g_sTheMapNotFound, [sMapName])
        { + ' 此地图号不存在！！！'}, c_Red, t_Hint);
      exit;
    end;
    if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then
    begin
      SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
      MapRandomMove(sMapName, 0);
    end
    else
    begin
      SysMsg(format(g_sTheMapDisableMove, [sMapName, Envir.sMapDesc])
        {'地图 ' + sParam1 + ' 不允许传送！！！'}, c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdMapMove');
  end;
end;
//004CDA38

procedure TPlayObject.CmdPositionMove(Cmd: pTGameCmd; sMapName, sX, sY: string);
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  try
    try
      if (m_btPermission < Cmd.nPermissionMin) then
      begin
        SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
        exit;
      end;
      if (sMapName = '') or (sX = '') or (sY = '') or ((sMapName <> '') and
        (sMapName[1] = '?')) then
      begin
        SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
          g_sGameCommandPositionMoveHelpMsg]), c_Red, t_Hint);
        exit;
      end;
      if (m_btPermission >= Cmd.nPermissionMax) or CanMoveMap(sMapName) then
      begin
        Envir := g_MapManager.FindMap(sMapName);
        if Envir <> nil then
        begin
          nX := Str_ToInt(sX, 0);
          nY := Str_ToInt(sY, 0);
          if Envir.CanWalk(nX, nY, True) then
          begin
            SpaceMove(sMapName, nX, nY, 0);
          end
          else
          begin
            SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap, [sMapName,
              sX, sY]), c_Green, t_Hint);
          end;
        end;
      end
      else
      begin
        SysMsg(format(g_sTheMapDisableMove, [sMapName]), c_Red, t_Hint);
      end;
    except
      on e: Exception do
      begin
        MainOutMessage('[Exceptioin] TPlayObject.CmdPositionMove');
        MainOutMessage(E.Message);
      end;

    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdPositionMove');
  end;
end;

procedure TPlayObject.CmdMapMoveHuman(Cmd: pTGameCmd; sSrcMap, sDenMap: string);
var
  SrcEnvir, DenEnvir: TEnvirnoment;
  HumanList: TList;
  I: Integer;
  MoveHuman: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sDenMap = '') or (sSrcMap = '') or ((sSrcMap <> '') and (sSrcMap[1] =
      '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandMapMoveHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    SrcEnvir := g_MapManager.FindMap(sSrcMap);
    DenEnvir := g_MapManager.FindMap(sDenMap);
    if (SrcEnvir = nil) then
    begin
      SysMsg(format(g_sGameCommandMapMoveMapNotFound, [sSrcMap]), c_Red,
        t_Hint);
      exit;
    end;
    if (DenEnvir = nil) then
    begin
      SysMsg(format(g_sGameCommandMapMoveMapNotFound, [sDenMap]), c_Red,
        t_Hint);
      exit;
    end;

    HumanList := TList.Create;
    UserEngine.GetMapRageHuman(SrcEnvir, SrcEnvir.Header.wWidth div 2,
      SrcEnvir.Header.wHeight div 2, 1000, HumanList);
    for I := 0 to HumanList.Count - 1 do
    begin
      MoveHuman := TPlayObject(HumanList.Items[I]);
      if MoveHuman <> Self then
        MoveHuman.MapRandomMove(sDenMap, 0);
    end;
    HumanList.Free;
  except
    MainOutMessage('[Exception] TPlayObject.CmdMapMoveHuman');
  end;
end;

procedure TPlayObject.CmdMemberFunction(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('打开会员功能窗口.', c_Red, t_Hint);
      exit;
    end;
    NpcGotoLable(g_ManageNPC, '@Member', False);
    {if g_ManageNPC <> nil then begin
      g_ManageNPC.GotoLable(Self,'@Member',False);
    end; }
  except
    MainOutMessage('[Exception] TPlayObject.CmdMemberFunction');
  end;
end;

procedure TPlayObject.CmdMemberFunctionEx(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('打开会员功能窗口.', c_Red, t_Hint);
      exit;
    end;
    NpcGotoLable(g_FunctionNPC, '@Member', False);
    { if (g_FunctionNPC <> nil) and (not m_boHero) then begin
       g_FunctionNPC.GotoLable(Self,'@Member',False);
     end; }
  except
    MainOutMessage('[Exception] TPlayObject.CmdMemberFunctionEx');
  end;
end;

procedure TPlayObject.CmdMission(Cmd: pTGameCmd; sX, sY: string); //004CCA08
var
  nX, nY: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sX = '') or (sY = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y', c_Red, t_Hint);
      exit;
    end;
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    g_boMission := True;
    g_sMissionMap := m_sMapName;
    g_nMissionX := nX;
    g_nMissionY := nY;
    SysMsg('怪物集中目标已设定为: ' + m_sMapName + '(' +
      IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY) + ')', c_Green,
      t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdMission');
  end;
end;

procedure TPlayObject.CmdMob(Cmd: pTGameCmd; sMonName: string; nCount, nLevel:
  Integer; nExpRatio: Integer = -1); //004CC7F4
var
  I: Integer;
  nX, nY: Integer;
  Monster: TBaseObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandMobHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    if nCount <= 0 then
      nCount := 1;
    if not (nLevel in [0..10]) then
      nLevel := 0;

    nCount := _MIN(64, nCount);
    GetFrontPosition(nX, nY);
    for I := 0 to nCount - 1 do
    begin
      Monster := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, nX, nY,
        sMonName);
      if Monster <> nil then
      begin
        Monster.m_btSlaveMakeLevel := nLevel;
        Monster.m_btSlaveExpLevel := nLevel;
        Monster.RecalcAbilitys;
        Monster.RefNameColor;
        if nExpRatio <> -1 then
        begin
          nExpRatio := _MIN(100, nExpRatio);
          Monster.m_dwFightExp := Monster.m_dwFightExp * LongWord(nExpRatio);
        end;
      end
      else
      begin
        SysMsg(g_sGameCommandMobMsg, c_Red, t_Hint);
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdMob');
  end;
end;

procedure TPlayObject.CmdMobCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandMobCountHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    Envir := g_MapManager.FindMap(sMapName);
    if Envir = nil then
    begin
      SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
      exit;
    end;
    SysMsg(format(g_sGameCommandMobCountMonsterCount,
      [UserEngine.GetMapMonster(Envir, nil)]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdMobCount');
  end;
end;

procedure TPlayObject.CmdHumanCount(Cmd: pTGameCmd; sMapName: string);
var
  Envir: TEnvirnoment;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMapName = '') or ((sMapName <> '') and (sMapName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandHumanCountHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    Envir := g_MapManager.FindMap(sMapName);
    if Envir = nil then
    begin
      SysMsg(g_sGameCommandMobCountMapNotFound, c_Red, t_Hint);
      exit;
    end;
    SysMsg(format(g_sGameCommandMobCountHumanCount,
      [UserEngine.GetMapHuman(sMapName)]), c_Green, t_Hint);
    SysMsg(format(g_sGameCommandMobCountMonsterCount,
      [UserEngine.GetMapMonster(Envir, nil)]), c_Green, t_Hint);
    //  SysMsg(format(g_sGameCommandMobCountAttackCount,[Envir.AttackCount]),c_Green,t_Hint);
      //SysMsg(format(g_sGameCommandMobCountSlaveCount,[Envir.SlaveCount2]),c_Green,t_Hint);
      //SysMsg(format(g_sGameCommandMobCountMonsterCount,[UserEngine.GetMapHuman(sMapName)]),c_Green,t_Hint);
      //SysMsg(IntToStr(Envir.HumCount2),c_Green,t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdHumanCount');
  end;
end;

procedure TPlayObject.CmdMobFireBurn(Cmd: pTGameCmd; sMap, sX, sY, sType,
  sTime, sPoint: string);
var
  nX, nY, nType, nTime, nPoint: Integer;
  FireBurnEvent: TFireBurnEvent;
  Envir: TEnvirnoment;
  OldEnvir: TEnvirnoment;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMap = '') or ((sMap <> '') and (sMap[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMap, sX, sY,
        sType, sTime, sPoint]), c_Red, t_Hint);
      exit;
    end;

    nX := Str_ToInt(sX, -1);
    nY := Str_ToInt(sY, -1);
    nType := Str_ToInt(sType, -1);
    nTime := Str_ToInt(sTime, -1);
    nPoint := Str_ToInt(sPoint, -1);
    if nPoint < 0 then
      nPoint := 1;

    if (sMap = '') or (nX < 0) or (nY < 0) or (nType < 0) or (nTime < 0) or
      (nPoint < 0) then
    begin
      SysMsg(format(g_sGameCommandMobFireBurnHelpMsg, [Cmd.sCmd, sMap, sX, sY,
        sType, sTime, sPoint]), c_Red, t_Hint);
      exit;
    end;
    Envir := g_MapManager.FindMap(sMap);
    if Envir <> nil then
    begin
      OldEnvir := m_PEnvir;
      m_PEnvir := Envir;
      FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime * 1000,
        nPoint);
      g_EventManager.AddEvent(FireBurnEvent);
      m_PEnvir := OldEnvir;
      exit;
    end;
    SysMsg(format(g_sGameCommandMobFireBurnMapNotFountMsg, [Cmd.sCmd, sMap]),
      c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdMobFireBurn');
  end;
end;

procedure TPlayObject.CmdMobLevel(Cmd: pTGameCmd; Param: string); //004CFD5C
var
  I: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((Param <> '') and (Param[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
      exit;
    end;

    BaseObjectList := TList.Create;
    m_PEnvir.GetRangeBaseObject(m_nCurrX, m_nCurrY, 2, True, BaseObjectList);
    for I := 0 to BaseObjectList.Count - 1 do
    begin
      BaseObject := TBaseObject(BaseObjectList.Items[i]);
      SysMsg(BaseObject.GeTBaseObjectInfo(), c_Green, t_Hint);
    end;
    BaseObjectList.Free;
  except
    MainOutMessage('[Exception] TPlayObject.CmdMobLevel');
  end;
end;

procedure TPlayObject.CmdMobNpc(sCmd: string; nPermission: Integer; sParam1,
  sParam2, sParam3, sParam4: string);
var
  nAppr: Integer;
  boIsCastle: Boolean;
  Merchant: TMerchant;
  nX, nY: Integer;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sParam1 = '') or (sParam2 = '') or ((sParam1 <> '') and (sParam1[1] =
      '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandMobNpcHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    nAppr := Str_ToInt(sParam3, 0);
    boIsCastle := (Str_ToInt(sParam4, 0) = 1);
    if sParam1 = '' then
    begin
      SysMsg('命令格式: @' + sCmd +
        ' NPC名称 脚本文件名 外形(数字) 属沙城(0,1)', c_Red,
        t_Hint);
      exit;
    end;
    Merchant := TMerchant.Create;
    Merchant.m_sCharName := sParam1;
    Merchant.m_sMapName := m_sMapName;
    Merchant.m_PEnvir := m_PEnvir;
    Merchant.m_wAppr := nAppr;
    Merchant.m_nFlag := 0;
    Merchant.m_boCastle := boIsCastle;
    Merchant.m_sScript := sParam2;
    GetFrontPosition(nX, nY);
    Merchant.m_nCurrX := nX;
    Merchant.m_nCurrY := nY;
    Merchant.Initialize();
    UserEngine.AddMerchant(Merchant);
  except
    MainOutMessage('[Exception] TPlayObject.CmdMobNpc');
  end;
end;

procedure TPlayObject.CmdMobPlace(Cmd: pTGameCmd; sX, sY, sMonName, sCount:
  string); //004CCBB4
var
  I: Integer;
  nCount, nX, nY: Integer;
  MEnvir: TEnvirnoment;
  Mon: TBaseObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    nCount := _MIN(500, Str_ToInt(sCount, 0));
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    MEnvir := g_MapManager.FindMap(g_sMissionMap);
    if (nX <= 0) or (nY <= 0) or (sMonName = '') or (nCount <= 0) then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' X  Y 怪物名称 怪物数量',
        c_Red, t_Hint);
      exit;
    end;
    if not g_boMission or (MEnvir = nil) then
    begin
      SysMsg('还没有设定怪物集中点！！！', c_Red, t_Hint);
      SysMsg('请先用命令' + g_GameCommand.MISSION.sCmd +
        '设置怪物的集中点。', c_Red, t_Hint);
      exit;
    end;

    for I := 0 to nCount - 1 do
    begin
      Mon := UserEngine.RegenMonsterByName(g_sMissionMap, nX, nY, sMonName);
      if Mon <> nil then
      begin
        Mon.m_boMission := True;
        Mon.m_nMissionX := g_nMissionX;
        Mon.m_nMissionY := g_nMissionY;
      end
      else
        break;
    end;
    SysMsg(IntToStr(nCount) + ' 只 ' + sMonName + ' 已正在往地图 ' +
      g_sMissionMap + ' ' + IntToStr(g_nMissionX) + ':' + IntToStr(g_nMissionY)
      +
      ' 集中。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdMobPlace');
  end;
end;

procedure TPlayObject.CmdNpcScript(sCmd: string; nPermission: Integer; sParam1,
  sParam2, sParam3: string);
var
  BaseObject: TBaseObject;
  nNPCType: Integer;
  I: Integer;
  sScriptFileName: string;
  Merchant: TMerchant;
  NormNpc: TNormNpc;
  LoadList: TStringList;
  sScriptLine: string;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandNpcScriptHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    nNPCType := -1;
    BaseObject := GetPoseCreate();
    if BaseObject <> nil then
    begin
      for I := 0 to UserEngine.m_MerchantList.Count - 1 do
      begin
        if TBaseObject(UserEngine.m_MerchantList.Items[I]) = BaseObject then
        begin
          nNPCType := 0;
          break;
        end;
      end;
      for I := 0 to UserEngine.QuestNPCList.Count - 1 do
      begin
        if TBaseObject(UserEngine.QuestNPCList.Items[I]) = BaseObject then
        begin
          nNPCType := 1;
          break;
        end;
      end;
    end;
    if nNPCType < 0 then
    begin
      SysMsg('命令使用方法不正确，必须与NPC面对面，才能使用此命令！！！', c_Red, t_Hint);
      exit;
    end;

    if sParam1 = '' then
    begin
      if nNPCType = 0 then
      begin
        Merchant := TMerchant(BaseObject);
        sScriptFileName := g_Config.sEnvirDir + sMarket_Def + Merchant.m_sScript
          + '-' + Merchant.m_sMapName + '.txt';
      end;
      if nNPCType = 1 then
      begin
        NormNpc := TNormNpc(BaseObject);
        sScriptFileName := g_Config.sEnvirDir + sNpc_def + NormNpc.m_sCharName +
          '-' + NormNpc.m_sMapName + '.txt';
      end;
      if FileExists(sScriptFileName) then
      begin
        LoadList := TStringList.Create;
        try
          LoadList.LoadFromFile(sScriptFileName);
        except
          SysMsg('读取脚本文件错误: ' + sScriptFileName, c_Red, t_Hint);
        end;
        for I := 0 to LoadList.Count - 1 do
        begin
          sScriptLine := Trim(LoadList.Strings[I]);
          sScriptLine := ReplaceChar(sScriptLine, ' ', ',');
          SysMsg(IntToStr(I) + ',' + sScriptLine, c_Blue, t_Hint);
        end;
        LoadList.Free;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdNpcScript');
  end;
end;

procedure TPlayObject.CmdOPDeleteSkill(sHumanName, sSkillName: string);
//004CE938
begin
  try
    if (m_btPermission < 6) then
      exit;
  except
    MainOutMessage('[Exception] TPlayObject.CmdOPDeleteSkill');
  end;
end;

procedure TPlayObject.CmdOPTraining(sHumanName, sSkillName: string;
  nLevel: Integer); //004CC468
begin
  try
    if (m_btPermission < 6) then
      exit;
  except
    MainOutMessage('[Exception] TPlayObject.CmdOPTraining');
  end;
end;

procedure TPlayObject.CmdPKpoint(Cmd: pTGameCmd; sHumanName: string); //004CC61C
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandPKPointHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    SysMsg(format(g_sGameCommandPKPointMsg, [sHumanName,
      PlayObject.m_nPkPoint]), c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdPKpoint');
  end;
end;

procedure TPlayObject.CmdPrvMsg(sCmd: string; nPermission: Integer;
  sHumanName: string);
var
  I: Integer;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandPrvMsgHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    for I := 0 to m_BlockWhisperList.Count - 1 do
    begin
      if CompareText(m_BlockWhisperList.Strings[I], sHumanName) = 0 then
      begin
        m_BlockWhisperList.Delete(I);
        SysMsg(format(g_sGameCommandPrvMsgUnLimitMsg, [sHumanName]), c_Green,
          t_Hint);
        exit;
      end;
    end;
    m_BlockWhisperList.Add(sHumanName);
    SysMsg(format(g_sGameCommandPrvMsgLimitMsg, [sHumanName]), c_Green, t_Hint);

  except
    MainOutMessage('[Exception] TPlayObject.CmdPrvMsg');
  end;
end;

procedure TPlayObject.CmdReAlive(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandReAliveHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    PlayObject.ReAlive;
    PlayObject.m_WAbil.HP := PlayObject.m_WAbil.MaxHP;
    PlayObject.SendMsg(PlayObject, RM_ABILITY, 0, 0, 0, 0, '');

    SysMsg(format(g_sGameCommandReAliveMsg, [sHumanName]), c_Green, t_Hint);
    SysMsg(sHumanName + ' 已获重生。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdReAlive');
  end;
end;

procedure TPlayObject.CmdRecallHuman(Cmd: pTGameCmd; sHumanName: string);
//004CE250
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandRecallHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    RecallHuman(sHumanName);
  except
    MainOutMessage('[Exception] TPlayObject.CmdRecallHuman');
  end;
end;

//Mob召唤宝宝

procedure TPlayObject.CmdRecallMob(Cmd: pTGameCmd; sMonName: string; nCount,
  nLevel, nAutoChangeColor, nFixColor: Integer); //004CC8C4
var
  I: Integer;
  n10, n14: Integer;
  Mon: TBaseObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sMonName = '') or ((sMonName <> '') and (sMonName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandRecallMobHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    if nLevel >= 10 then
      nLevel := 0;
    if nCount <= 0 then
      nCount := 1;
    for I := 0 to nCount - 1 do
    begin
      if m_SlaveList.Count >= 20 then
        break;
      GetFrontPosition(n10, n14);
      Mon := UserEngine.RegenMonsterByName(m_PEnvir.sMapName, n10, n14,
        sMonName, Self);
      if Mon <> nil then
      begin
        Mon.m_Master2 := Self;
        if m_AllMaster <> nil then
          Mon.m_AllMaster := m_AllMaster
        else
          Mon.m_AllMaster := Self;
        Mon.m_dwMasterRoyaltyTick := GetTickCount + 24 * 60 * 60 * 1000;
        Mon.m_btSlaveMakeLevel := 3;
        Mon.m_btSlaveExpLevel := nLevel;
        if nAutoChangeColor = 1 then
        begin
          Mon.m_boAutoChangeColor := True;
        end
        else if nFixColor > 0 then
        begin
          Mon.m_boFixColor := True;
          Mon.m_nFixColorIdx := nFixColor - 1;
        end;

        Mon.RecalcAbilitys();
        Mon.RefNameColor();
        m_SlaveList.Add(Mon);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdRecallMob');
  end;
end;

procedure TPlayObject.CmdReconnection(sCmd, sIPaddr, sPort: string);
//004CE380
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sIPaddr <> '') and (sIPaddr[1] = '?') then
    begin
      SysMsg('此命令用于改变客户端连接网关的IP及端口。',
        c_Blue, t_Hint);
      exit;
    end;

    if (sIPaddr = '') or (sPort = '') then
    begin
      SysMsg('命令格式: @' + sCmd + ' IP地址 端口', c_Red, t_Hint);
      exit;
    end;
    if (sIPaddr <> '') and (sPort <> '') then
    begin
      SendMsg(Self, RM_RECONNECTION, 0, 0, 0, 0, sIPaddr + '/' + sPort);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReconnection');
  end;
end;

procedure TPlayObject.CmdRefineWeapon(Cmd: pTGameCmd; nDC, nMC, nSC, nHit:
  Integer); //004CD1C4
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (nDC + nMC + nSC) > 10 then
      exit;
    if m_UseItems[U_WEAPON].wIndex <= 0 then
      exit;
    m_UseItems[U_WEAPON].btValue[0] := nDC;
    m_UseItems[U_WEAPON].btValue[1] := nMC;
    m_UseItems[U_WEAPON].btValue[2] := nSC;
    m_UseItems[U_WEAPON].btValue[5] := nHit;
    SendUpdateItem(@m_UseItems[U_WEAPON]);
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    MainOutMessage('[武器调整]' + m_sCharName + ' DC:' + IntToStr(nDC) +
      ' MC' + IntToStr(nMC) + ' SC' + IntToStr(nSC) + ' HIT:' + IntToStr(nHit));
  except
    MainOutMessage('[Exception] TPlayObject.CmdRefineWeapon');
  end;
end;

procedure TPlayObject.CmdReGotoHuman(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandReGotoHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    SpaceMove(PlayObject.m_PEnvir.sMapName, PlayObject.m_nCurrX,
      PlayObject.m_nCurrY, 0);

  except
    MainOutMessage('[Exception] TPlayObject.CmdReGotoHuman');
  end;
end;

procedure TPlayObject.CmdReloadAbuse(sCmd: string; nPerMission: Integer;
  sParam1: string);
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadAbuse');
  end;
end;

procedure TPlayObject.CmdReLoadAdmin(sCmd: string);
begin
  try
    if (m_btPermission < 6) then
      exit;
    FrmDB.LoadAdminList();
    UserEngine.SendServerGroupMsg(213, nServerIndex, '');
    SysMsg('管理员列表重新加载成功...', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdReLoadAdmin');
  end;
end;

procedure TPlayObject.CmdReloadGuild(sCmd: string; nPerMission: Integer;
  sParam1: string);
var
  Guild: TGuild;
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sParam1 = '') or ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd,
        g_sGameCommandReloadGuildHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    if nServerIndex <> 0 then
    begin
      SysMsg(g_sGameCommandReloadGuildOnMasterserver, c_Red, t_Hint);
      exit;
    end;

    Guild := g_GuildManager.FindGuild(sParam1);
    if Guild = nil then
    begin
      SysMsg(format(g_sGameCommandReloadGuildNotFoundGuildMsg, [sParam1]),
        c_Red, t_Hint);
      exit;
    end;
    Guild.LoadGuild();
    SysMsg(format(g_sGameCommandReloadGuildSuccessMsg, [sParam1]), c_Red,
      t_Hint);
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex, sParam1);
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadGuild');
  end;
end;

procedure TPlayObject.CmdReloadGuildAll; //004CE530
begin
  try
    if (m_btPermission < 6) then
      exit;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadGuildAll');
  end;
end;

procedure TPlayObject.CmdReloadLineNotice(sCmd: string;
  nPerMission: Integer; sParam1: string);
begin
  try
    if (m_btPermission < nPermission) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    if LoadLineNotice(g_Config.sNoticeDir + 'LineNotice.txt') then
    begin
      SysMsg(g_sGameCommandReloadLineNoticeSuccessMsg, c_Green, t_Hint);
    end
    else
    begin
      SysMsg(g_sGameCommandReloadLineNoticeFailMsg, c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadLineNotice');
  end;
end;

procedure TPlayObject.CmdReloadManage(Cmd: pTGameCmd; sParam: string);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam <> '') and (sParam[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    if sParam = '' then
    begin
      if g_ManageNPC <> nil then
      begin
        g_ManageNPC.ClearScript();
        g_ManageNPC.LoadNPCScript();
        SysMsg('重新加载登录脚本完成...', c_Green, t_Hint);
      end
      else
      begin
        SysMsg('重新加载登录脚本失败...', c_Green, t_Hint);
      end;
    end
    else
    begin
      if g_FunctionNPC <> nil then
      begin
        g_FunctionNPC.ClearScript();
        g_FunctionNPC.LoadNPCScript();
        //g_FunctionNPC.LoadNPCData;
        SysMsg('重新加载功能脚本完成...', c_Green, t_Hint);
      end
      else
      begin
        SysMsg('重新加载功能脚本失败...', c_Green, t_Hint);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadManage');
  end;
end;

procedure TPlayObject.CmdReloadRobot;
begin
  try
    RobotManage.ReLoadRobot();
    SysMsg('重新加载机器人配置完成...', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadRobot');
  end;
end;

procedure TPlayObject.CmdReloadRobotManage;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if g_RobotNPC <> nil then
    begin
      g_RobotNPC.ClearScript();
      g_RobotNPC.LoadNPCScript();
      SysMsg('重新加载机器人专用脚本完成...', c_Green, t_Hint);
    end
    else
    begin
      SysMsg('重新加载机器人专用脚本失败...', c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadRobotManage');
  end;
end;

procedure TPlayObject.CmdReloadMonItems; //
var
  I: Integer;
  Monster: pTMonInfo;
begin
  try
    if (m_btPermission < 6) then
      exit;
    try
      for I := 0 to UserEngine.MonsterList.Count - 1 do
      begin
        Monster := UserEngine.MonsterList.Items[I];
        FrmDB.LoadMonitems(Monster.sName, Monster.ItemList);
      end;
      SysMsg('怪物爆物品列表重加载完成...', c_Green, t_Hint);
    except
      SysMsg('怪物爆物品列表重加载失败！！！', c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadMonItems');
  end;
end;

procedure TPlayObject.CmdReloadNpc(sParam: string); //004CFFF8
var
  I: Integer;
  TmpList: TList;
  Merchant: TMerchant;
  Npc: TNormNpc;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if CompareText('all', sParam) = 0 then
    begin
      FrmDB.ReLoadMerchants();
      UserEngine.ReloadMerchantList();
      SysMsg('交易NPC重新加载完成！！！', c_Red, t_Hint);
      UserEngine.ReloadNpcList();
      SysMsg('管理NPC重新加载完成！！！', c_Red, t_Hint);
      exit;
    end; //004D0136
    TmpList := TList.Create;
    if UserEngine.GetMerchantList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0
      then
    begin
      for I := 0 to TmpList.Count - 1 do
      begin
        Merchant := TMerchant(TmpList.Items[i]);
        Merchant.ClearScript;
        Merchant.LoadNPCScript;
        //Merchant.LoadNPCData;   //Jason 0716
        SysMsg(Merchant.m_sCharName + '重新加载成功...', c_Green, t_Hint);
      end; // for
    end
    else
    begin
      SysMsg('附近未发现任何交易NPC！！！', c_Red, t_Hint);
    end;
    TmpList.Clear;
    if UserEngine.GetNpcList(m_PEnvir, m_nCurrX, m_nCurrY, 9, TmpList) > 0 then
    begin
      for I := 0 to TmpList.Count - 1 do
      begin
        Npc := TNormNpc(TmpList.Items[i]);
        Npc.ClearScript;
        Npc.LoadNPCScript;
        SysMsg(Npc.m_sCharName + '重新加载成功...', c_Green, t_Hint);
      end; // for
    end
    else
    begin
      SysMsg('附近未发现任何管理NPC！！！', c_Red, t_Hint);
    end;
    TmpList.Free;
  except
    MainOutMessage('[Exception] TPlayObject.CmdReloadNpc');
  end;
end;

procedure TPlayObject.CmdSearchHuman(sCmd, sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if m_boProbeNecklace or (m_btPermission >= 6) then
    begin
      if (sHumanName = '') then
      begin
        SysMsg('命令格式: @' + sCmd + ' 人物名称', c_Red, t_Hint);
        exit;
      end;
      if ((GetTickCount - m_dwProbeTick) > 10000) or (m_btPermission >= 3) then
      begin
        m_dwProbeTick := GetTickCount();
        PlayObject := UserEngine.GeTPlayObject(sHumanName);
        if PlayObject <> nil then
        begin
          SysMsg(sHumanName + ' 现在位于 ' + PlayObject.m_PEnvir.sMapDesc +
            ' ' + IntToStr(PlayObject.m_nCurrX) + ':' +
            IntToStr(PlayObject.m_nCurrY), c_Blue, t_Hint);
        end
        else
        begin
          SysMsg(sHumanName +
            ' 现在不在线，或位于其它服务器上！！！', c_Red,
            t_Hint);
        end;
      end
      else
      begin
        SysMsg(IntToStr((GetTickCount - m_dwProbeTick) div 1000 - 10) +
          ' 秒之后才可以再使用此功能！！！', c_Red, t_Hint);
      end;
    end
    else
    begin
      SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdSearchHuman');
  end;
end;

procedure TPlayObject.CmdShowSbkGold(Cmd: pTGameCmd; sCastleName, sCtr, sGold:
  string);
var
  I: Integer;
  Ctr: Char;
  nGold: Integer;
  Castle: TUserCastle;
  List: TStringList;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sCastleName <> '') and (sCastleName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
      exit;
    end;
    if sCastleName = '' then
    begin
      List := TStringList.Create;
      g_CastleManager.GetCastleGoldInfo(List);
      for I := 0 to List.Count - 1 do
      begin
        SysMsg(List.Strings[I], c_Green, t_Hint);
      end;
      List.Free;
      exit;
    end;
    Castle := g_CastleManager.Find(sCastleName);
    if Castle = nil then
    begin
      SysMsg(format(g_sGameCommandSbkGoldCastleNotFoundMsg, [sCastleName]),
        c_Red, t_Hint);
      exit;
    end;

    Ctr := sCtr[1];
    nGold := Str_ToInt(sGold, -1);
    if not (Ctr in ['=', '-', '+']) or (nGold < 0) or (nGold > 100000000) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandSbkGoldHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    case Ctr of
      '=': Castle.m_nTotalGold := nGold;
      '-': Dec(Castle.m_nTotalGold);
      '+': Inc(Castle.m_nTotalGold, nGold);
    end;
    if Castle.m_nTotalGold < 0 then
      Castle.m_nTotalGold := 0;

  except
    MainOutMessage('[Exception] TPlayObject.CmdShowSbkGold');
  end;
end;

procedure TPlayObject.CmdShowUseItemInfo(Cmd: pTGameCmd;
  sHumanName: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandShowUseItemInfoHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    for I := Low(PlayObject.m_UseItems) to High(PlayObject.m_UseItems) do
    begin
      UserItem := @PlayObject.m_UseItems[I];
      if UserItem.wIndex = 0 then
        Continue;
      SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]',
        [GetUseItemName(I),
        UserEngine.GetStdItemName(UserItem.wIndex),
          UserItem.wIndex,
          UserItem.MakeIndex,
          UserItem.Dura,
          UserItem.DuraMax]),
          c_Blue, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShowUseItemInfo');
  end;
end;

procedure TPlayObject.CmdBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    nBind := -1;
    nItem := GetUseItemIdx(sItem);
    if CompareText(sType, '帐号') = 0 then
      nBind := 0;
    if CompareText(sType, '人物') = 0 then
      nBind := 1;
    if CompareText(sType, 'IP') = 0 then
      nBind := 2;

    if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '')
      and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    UserItem := @PlayObject.m_UseItems[nItem];
    if UserItem.wIndex = 0 then
    begin
      SysMsg(format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]),
        c_Red, t_Hint);
      exit;
    end;
    nItemIdx := UserItem.wIndex;
    nMakeIdex := UserItem.MakeIndex;
    case nBind of //
      0:
        begin
          sBindName := PlayObject.m_sUserID;
          g_ItemBindAccount.Lock;
          try
            for I := 0 to g_ItemBindAccount.Count - 1 do
            begin
              ItemBind := g_ItemBindAccount.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
                nMakeIdex) then
              begin
                SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,
                  [sHumanName, sItem]), c_Red, t_Hint);
                exit;
              end;
            end;
            New(ItemBind);
            ItemBind.nItemIdx := nItemIdx;
            ItemBind.nMakeIdex := nMakeIdex;
            ItemBind.sBindName := sBindName;
            g_ItemBindAccount.Insert(0, ItemBind);
          finally
            g_ItemBindAccount.UnLock;
          end;
          SaveItemBindAccount();
          SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              UserItem.wIndex,
              UserItem.MakeIndex,
              UserItem.Dura,
              UserItem.DuraMax,
              sBindName]),
              c_Blue, t_Hint);
          PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              sType,
              sBindName
              ]), c_Blue, t_Hint);
        end;
      1:
        begin
          sBindName := PlayObject.m_sCharName;
          g_ItemBindCharName.Lock;
          try
            for I := 0 to g_ItemBindCharName.Count - 1 do
            begin
              ItemBind := g_ItemBindCharName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
                nMakeIdex) then
              begin
                SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,
                  [sHumanName, sItem]), c_Red, t_Hint);
                exit;
              end;
            end;
            New(ItemBind);
            ItemBind.nItemIdx := nItemIdx;
            ItemBind.nMakeIdex := nMakeIdex;
            ItemBind.sBindName := sBindName;
            g_ItemBindCharName.Insert(0, ItemBind);
          finally
            g_ItemBindCharName.UnLock;
          end;
          SaveItemBindCharName();
          SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              UserItem.wIndex,
              UserItem.MakeIndex,
              UserItem.Dura,
              UserItem.DuraMax,
              sBindName]),
              c_Blue, t_Hint);
          PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              sType,
              sBindName
              ]), c_Blue, t_Hint);
        end;
      2:
        begin
          sBindName := PlayObject.m_sIPaddr;
          g_ItemBindIPaddr.Lock;
          try
            for I := 0 to g_ItemBindIPaddr.Count - 1 do
            begin
              ItemBind := g_ItemBindIPaddr.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
                nMakeIdex) then
              begin
                SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,
                  [sHumanName, sItem]), c_Red, t_Hint);
                exit;
              end;
            end;
            New(ItemBind);
            ItemBind.nItemIdx := nItemIdx;
            ItemBind.nMakeIdex := nMakeIdex;
            ItemBind.sBindName := sBindName;
            g_ItemBindIPaddr.Insert(0, ItemBind);
          finally
            g_ItemBindIPaddr.UnLock;
          end;
          SaveItemBindIPaddr();
          SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              UserItem.wIndex,
              UserItem.MakeIndex,
              UserItem.Dura,
              UserItem.DuraMax,
              sBindName]),
              c_Blue, t_Hint);
          PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              sType,
              sBindName
              ]), c_Blue, t_Hint);
        end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdBindUseItem');
  end;
end;

procedure TPlayObject.CmdUnBindUseItem(Cmd: pTGameCmd; sHumanName, sItem,
  sType: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  UserItem: pTUserItem;
  nItem, nBind: Integer;
  ItemBind: pTItemBind;
  nItemIdx, nMakeIdex: Integer;
  sBindName: string;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    nBind := -1;
    nItem := GetUseItemIdx(sItem);
    if CompareText(sType, '帐号') = 0 then
      nBind := 0;
    if CompareText(sType, '人物') = 0 then
      nBind := 1;
    if CompareText(sType, 'IP') = 0 then
      nBind := 2;

    if (nItem < 0) or (nBind < 0) or (sHumanName = '') or ((sHumanName <> '')
      and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandBindUseItemHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject = nil then
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
      exit;
    end;
    UserItem := @PlayObject.m_UseItems[nItem];
    if UserItem.wIndex = 0 then
    begin
      SysMsg(format(g_sGameCommandBindUseItemNoItemMsg, [sHumanName, sItem]),
        c_Red, t_Hint);
      exit;
    end;
    nItemIdx := UserItem.wIndex;
    nMakeIdex := UserItem.MakeIndex;
    case nBind of //
      0:
        begin
          sBindName := PlayObject.m_sUserID;
          g_ItemBindAccount.Lock;
          try
            for I := 0 to g_ItemBindAccount.Count - 1 do
            begin
              ItemBind := g_ItemBindAccount.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
                nMakeIdex) then
              begin
                SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,
                  [sHumanName, sItem]), c_Red, t_Hint);
                exit;
              end;
            end;
            New(ItemBind);
            ItemBind.nItemIdx := nItemIdx;
            ItemBind.nMakeIdex := nMakeIdex;
            ItemBind.sBindName := sBindName;
            g_ItemBindAccount.Insert(0, ItemBind);
          finally
            g_ItemBindAccount.UnLock;
          end;
          SaveItemBindAccount();
          SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              UserItem.wIndex,
              UserItem.MakeIndex,
              UserItem.Dura,
              UserItem.DuraMax,
              sBindName]),
              c_Blue, t_Hint);
          PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              sType,
              sBindName
              ]), c_Blue, t_Hint);
        end;
      1:
        begin
          sBindName := PlayObject.m_sCharName;
          g_ItemBindCharName.Lock;
          try
            for I := 0 to g_ItemBindCharName.Count - 1 do
            begin
              ItemBind := g_ItemBindCharName.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
                nMakeIdex) then
              begin
                SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,
                  [sHumanName, sItem]), c_Red, t_Hint);
                exit;
              end;
            end;
            New(ItemBind);
            ItemBind.nItemIdx := nItemIdx;
            ItemBind.nMakeIdex := nMakeIdex;
            ItemBind.sBindName := sBindName;
            g_ItemBindCharName.Insert(0, ItemBind);
          finally
            g_ItemBindCharName.UnLock;
          end;
          SaveItemBindCharName();
          SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              UserItem.wIndex,
              UserItem.MakeIndex,
              UserItem.Dura,
              UserItem.DuraMax,
              sBindName]),
              c_Blue, t_Hint);
          PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              sType,
              sBindName
              ]), c_Blue, t_Hint);
        end;
      2:
        begin
          sBindName := PlayObject.m_sIPaddr;
          g_ItemBindIPaddr.Lock;
          try
            for I := 0 to g_ItemBindIPaddr.Count - 1 do
            begin
              ItemBind := g_ItemBindIPaddr.Items[I];
              if (ItemBind.nItemIdx = nItemIdx) and (ItemBind.nMakeIdex =
                nMakeIdex) then
              begin
                SysMsg(format(g_sGameCommandBindUseItemAlreadBindMsg,
                  [sHumanName, sItem]), c_Red, t_Hint);
                exit;
              end;
            end;
            New(ItemBind);
            ItemBind.nItemIdx := nItemIdx;
            ItemBind.nMakeIdex := nMakeIdex;
            ItemBind.sBindName := sBindName;
            g_ItemBindIPaddr.Insert(0, ItemBind);
          finally
            g_ItemBindIPaddr.UnLock;
          end;
          SaveItemBindIPaddr();
          SysMsg(format('%s[%s]IDX[%d]系列号[%d]持久[%d-%d]，绑定到%s成功。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              UserItem.wIndex,
              UserItem.MakeIndex,
              UserItem.Dura,
              UserItem.DuraMax,
              sBindName]),
              c_Blue, t_Hint);
          PlayObject.SysMsg(format('你的%s[%s]已经绑定到%s[%s]上了。',
            [GetUseItemName(nItem),
            UserEngine.GetStdItemName(UserItem.wIndex),
              sType,
              sBindName
              ]), c_Blue, t_Hint);
        end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdUnBindUseItem');
  end;
end;

procedure TPlayObject.CmdShutup(Cmd: pTGameCmd; sHumanName, sTime: string);
var
  dwTime: LongWord;
  nIndex: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sTime = '') or (sHumanName = '') or ((sHumanName <> '') and
      (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandShutupHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    dwTime := Str_ToInt(sTime, 5);
    g_DenySayMsgList.Lock;
    try
      nIndex := g_DenySayMsgList.GetIndex(sHumanName);
      if nIndex >= 0 then
      begin
        g_DenySayMsgList.Objects[nIndex] := TObject(GetTickCount + dwTime * 60 *
          1000);
      end
      else
      begin
        g_DenySayMsgList.AddRecord(sHumanName, GetTickCount + dwTime * 60 *
          1000);
      end;
    finally
      g_DenySayMsgList.UnLock;
    end;
    SysMsg(format(g_sGameCommandShutupHumanMsg, [sHumanName, dwTime]), c_Red,
      t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdShutup');
  end;
end;

procedure TPlayObject.CmdShutupList(Cmd: pTGameCmd; sParam1: string);
var
  I: Integer;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if ((sParam1 <> '') and (sParam1[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd, '']), c_Red, t_Hint);
      exit;
    end;

    if (m_btPermission < 6) then
      exit;
    g_DenySayMsgList.Lock;
    try
      if g_DenySayMsgList.Count <= 0 then
      begin
        SysMsg(g_sGameCommandShutupListIsNullMsg, c_Green, t_Hint);
        exit;
      end;
      for I := 0 to g_DenySayMsgList.Count - 1 do
      begin
        SysMsg(g_DenySayMsgList.Strings[I] + ' ' +
          IntToStr((LongWord(g_DenySayMsgList.Objects[I]) - GetTickCount) div
          60000), c_Green, t_Hint);
      end;
    finally
      g_DenySayMsgList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShutupList');
  end;
end;

procedure TPlayObject.CmdShutupRelease(Cmd: pTGameCmd; sHumanName: string;
  boAll: Boolean);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandShutupReleaseHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    g_DenySayMsgList.Lock;
    try
      I := g_DenySayMsgList.GetIndex(sHumanName);
      if I >= 0 then
      begin
        g_DenySayMsgList.Delete(I);
        PlayObject := UserEngine.GeTPlayObject(sHumanName);
        if PlayObject <> nil then
        begin
          PlayObject.SysMsg(g_sGameCommandShutupReleaseCanSendMsg, c_Red,
            t_Hint);
        end;
        if boAll then
        begin
          UserEngine.SendServerGroupMsg(SS_210, nServerIndex, sHumanName);
        end;
        SysMsg(format(g_sGameCommandShutupReleaseHumanCanSendMsg, [sHumanName]),
          c_Green, t_Hint);
      end;
    finally
      g_DenySayMsgList.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdShutupRelease');
  end;
end;

procedure TPlayObject.CmdSmakeItem(Cmd: pTGameCmd; nWhere, nValueType, nValue:
  Integer);
var
  sShowMsg: string;
  StdItem: TItem;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;

    if (nWhere in [0..MAXUSEITEMS]) and (nValueType in [0..15]) and (nValue in
      [0..255]) then
    begin
      if m_UseItems[nWhere].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[nWhere].wIndex);
        if StdItem = nil then
          exit;

        if nValueType > 13 then
        begin
          nValue := _MIN(65, nValue);
          if nValueType = 14 then
            m_UseItems[nWhere].Dura := nValue * 1000;
          if nValueType = 15 then
            m_UseItems[nWhere].DuraMax := nValue * 1000;
        end
        else
        begin
          m_UseItems[nWhere].btValue[nValueType] := nValue;
        end;
        RecalcAbilitys();
        SendUpdateItem(@m_UseItems[nWhere]);
        sShowMsg := IntToStr(m_UseItems[nWhere].wIndex) + '-' +
          IntToStr(m_UseItems[nWhere].MakeIndex) + ' ' +
          IntToStr(m_UseItems[nWhere].Dura) + '/' +
          IntToStr(m_UseItems[nWhere].DuraMax) + ' ' +
          IntToStr(m_UseItems[nWhere].btValue[0]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[1]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[2]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[3]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[4]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[5]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[6]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[7]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[8]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[9]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[10]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[11]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[12]) + '/' +
          IntToStr(m_UseItems[nWhere].btValue[13]);
        SysMsg(sShowMsg, c_Blue, t_Hint);
        if g_Config.boShowMakeItemMsg then
          MainOutMessage('[物品调整] ' + m_sCharName + '(' + StdItem.Name +
            ' -> ' + sShowMsg + ')');
      end
      else
      begin
        SysMsg(g_sGamecommandSuperMakeHelpMsg, c_Red, t_Hint);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdSmakeItem');
  end;
end;

procedure TPlayObject.CmdSpirtStart(sCmd, sParam1: string);
var
  nTime: Integer;
  dwTime: LongWord;
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sParam1 <> '') and (sParam1[1] = '?') then
    begin
      SysMsg('此命令用于开始祈祷生效宝宝叛变。', c_Red, t_Hint);
      exit;
    end;
    nTime := Str_ToInt(sParam1, -1);
    if nTime > 0 then
    begin
      dwTime := LongWord(nTime) * 1000;
    end
    else
    begin
      dwTime := g_Config.dwSpiritMutinyTime;
    end;

    g_dwSpiritMutinyTick := GetTickCount + dwTime;
    SysMsg('祈祷叛变已开始。持续时长 ' + IntToStr(dwTime div 1000) +
      ' 秒。', c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdSpirtStart');
  end;
end;

procedure TPlayObject.CmdSpirtStop(sCmd, sParam1: string);
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (sParam1 <> '') and (sParam1[1] = '?') then
    begin
      SysMsg('此命令用于停止祈祷生效导致宝宝叛变。', c_Red,
        t_Hint);
      exit;
    end;
    g_dwSpiritMutinyTick := 0;
    SysMsg('祈祷叛变已停止。', c_Green, t_Hint);

  except
    MainOutMessage('[Exception] TPlayObject.CmdSpirtStop');
  end;
end;

procedure TPlayObject.CmdStartQuest(Cmd: pTGameCmd; sQuestName: string);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sQuestName = '') then
    begin
      SysMsg('命令格式: @' + Cmd.sCmd + ' 问答名称', c_Red, t_Hint);
      exit;
    end;
    UserEngine.SendQuestMsg(sQuestName);
  except
    MainOutMessage('[Exception] TPlayObject.CmdStartQuest');
  end;
end;

procedure TPlayObject.CmdSuperTing(Cmd: pTGameCmd; sHumanName, sRange: string);
var
  I: Integer;
  PlayObject: TPlayObject;
  MoveHuman: TPlayObject;
  nRange: Integer;
  HumanList: TList;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sRange = '') or (sHumanName = '') or ((sHumanName <> '') and
      (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandSuperTingHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    nRange := _MAX(10, Str_ToInt(sRange, 2));
    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      HumanList := TList.Create;
      UserEngine.GetMapRageHuman(PlayObject.m_PEnvir, PlayObject.m_nCurrX,
        PlayObject.m_nCurrY, nRange, HumanList);
      for I := 0 to HumanList.Count - 1 do
      begin
        MoveHuman := TPlayObject(HumanList.Items[I]);
        if MoveHuman <> Self then
          MoveHuman.MapRandomMove(MoveHuman.m_sHomeMap, 0);
      end;
      HumanList.Free;
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdSuperTing');
  end;
end;

procedure TPlayObject.CmdTakeOffHorse(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('下马命令，在骑马状态输入此命令下马。', c_Red,
        t_Hint);
      SysMsg(format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
      exit;
    end;
    if not m_boOnHorse then
      exit;

    m_boOnHorse := False;
    FeatureChanged();
  except
    MainOutMessage('[Exception] TPlayObject.CmdTakeOffHorse');
  end;
end;

procedure TPlayObject.CmdTakeOnHorse(sCmd, sParam: string);
begin
  try
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg('上马命令，在戴好马牌后输入此命令就可以骑上马。', c_Red, t_Hint);
      SysMsg(format('命令格式: @%s', [sCmd]), c_Red, t_Hint);
      exit;
    end;
    if m_boShop then
    begin
      SysMsg('请先取消摆摊状态。', c_Red, t_Hint);
      exit;
    end;
    if m_boOnHorse then
      exit;

    if (m_btHorseType = 0) then
    begin
      SysMsg('骑马必须先戴上马牌！！！', c_Red, t_Hint);
      exit;
    end;
    m_boOnHorse := True;
    FeatureChanged();
  except
    MainOutMessage('[Exception] TPlayObject.CmdTakeOnHorse');
  end;
end;

procedure TPlayObject.CmdTestFire(sCmd: string; nRange, nType, nTime, nPoint:
  Integer);
var
  nX, nY: Integer;
  FireBurnEvent: TFireBurnEvent;
  nMinX, nMaxX, nMinY, nMaxY: Integer;
begin
  try
    nMinX := m_nCurrX - nRange;
    nMaxX := m_nCurrX + nRange;
    nMinY := m_nCurrY - nRange;
    nMaxY := m_nCurrY + nRange;
    for nX := nMinX to nMaxX do
    begin
      for nY := nMinY to nMaxY do
      begin
        if ((nX < nMaxX) and (nY = nMinY)) or
          ((nY < nMaxY) and (nX = nMinX)) or
          (nX = nMaxX) or (nY = nMaxY) then
        begin
          FireBurnEvent := TFireBurnEvent.Create(Self, nX, nY, nType, nTime *
            1000, nPoint);
          g_EventManager.AddEvent(FireBurnEvent);
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdTestFire');
  end;
end;

procedure TPlayObject.CmdTestGetBagItems(Cmd: pTGameCmd; sParam: string);
var
  btDc, btSc, btMc, btDura: Byte;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sParam <> '') and (sParam[1] = '?') then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandTestGetBagItemsHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    btDc := 0;
    btSc := 0;
    btMc := 0;
    btDura := 0;
    //GetBagUseItems(btDc,btSc,btMc,btDura);
    SysMsg(format('DC:%d SC:%d MC:%d DURA:%d', [btDc, btSc, btMc, btDura]),
      c_Blue, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdTestGetBagItems');
  end;
end;

procedure TPlayObject.CmdTestSpeedMode(Cmd: pTGameCmd);
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    m_boTestSpeedMode := not m_boTestSpeedMode;
    if m_boTestSpeedMode then
    begin
      SysMsg('开启速度测试模式', c_Red, t_Hint);
    end
    else
    begin
      SysMsg('关闭速度测试模式', c_Red, t_Hint);
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CmdTestSpeedMode');
  end;
end;

procedure TPlayObject.CmdTestStatus(sCmd: string; nType, nTime: Integer);
begin
  try
    if (m_btPermission < 6) then
      exit;
    if (not (nType in [Low(TStatusTime)..High(TStatusTime)])) or (nTime < 0)
      then
    begin
      SysMsg('命令格式: @' + sCmd + ' 类型(0..11) 时长', c_Red, t_Hint);
      exit;
    end;
    m_wStatusTimeArr[nType] := nTime * 1000;
    m_dwStatusArrTick[nType] := GetTickCount();
    m_nCharStatus := GetCharStatus();
    StatusChanged();
    SysMsg(format('状态编号:%d 时间长度: %d 秒', [nType, nTime]),
      c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.CmdTestStatus');
  end;
end;

procedure TPlayObject.CmdTing(Cmd: pTGameCmd; sHumanName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sHumanName = '') or ((sHumanName <> '') and (sHumanName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandTingHelpMsg]), c_Red, t_Hint);
      exit;
    end;

    PlayObject := UserEngine.GeTPlayObject(sHumanName);
    if PlayObject <> nil then
    begin
      PlayObject.MapRandomMove(m_sHomeMap, 0);
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumanName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdTing');
  end;
end;

procedure TPlayObject.CmdTraining(sSkillName: string; nLevel: Integer);
//004CC414
begin
  try
    if (m_btPermission < 6) then
      exit;
  except
    MainOutMessage('[Exception] TPlayObject.CmdTraining');
  end;
end;

procedure TPlayObject.CmdUserMoveXY(sCMD, sX, sY: string);
var
  //  Envir:TEnvirnoment;
  nX, nY: Integer;
begin
  try
    if m_boTeleport then
    begin
      nX := Str_ToInt(sX, -1);
      nY := Str_ToInt(sY, -1);
      {
      if (nX < 0) or (nY < 0) then begin
        SysMsg('命令格式: @' + sCMD + ' 座标X 座标Y',c_Red,t_Hint);
        exit;
      end;
      }
      if not m_PEnvir.Flag.boNOPOSITIONMOVE then
      begin
        if m_PEnvir.CanWalkOfItem(nX, nY, g_Config.boUserMoveCanDupObj,
          g_Config.boUserMoveCanOnItem) then
        begin
          if (GetTickCount - m_dwTeleportTick) > LongWord(g_Config.dwUserMoveTime
            * 1000) {10000} then
          begin
            m_dwTeleportTick := GetTickCount();
            SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
            //BaseObjectMove('',sX,sY);
            SpaceMove(m_sMapName, nX, nY, 0);
            if m_boTeleport2 then
            begin
              if m_UseItems[U_BUJUK].Dura > 100 then
              begin
                Dec(m_UseItems[U_BUJUK].Dura, 100);
                SendMsg(Self, RM_DURACHANGE, U_BUJUK, m_UseItems[U_BUJUK].Dura,
                  m_UseItems[U_BUJUK].DuraMax, 0, '');
              end
              else
              begin
                m_UseItems[U_BUJUK].Dura := 0;
                SendDelItems(@m_UseItems[U_BUJUK]); //符毒用完消失
                m_UseItems[U_BUJUK].wIndex := 0;
              end;
            end;
          end
          else
          begin
            SysMsg(IntToStr(LongWord(g_Config.dwUserMoveTime) - (GetTickCount -
              LongWord(m_dwTeleportTick)) div 1000) +
              '秒之后才可以再使用此功能！！！', c_Red, t_Hint);
          end;
        end
        else
        begin
          SysMsg(format(g_sGameCommandPositionMoveCanotMoveToMap, [m_sMapName,
            sX, sY]), c_Green, t_Hint);
        end;
      end
      else
      begin
        SysMsg('此地图禁止使用此命令！！！', c_Red, t_Hint);
      end;
    end
    else
    begin
      SysMsg('您现在还无法使用此功能！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdUserMoveXY');
  end;
end;

procedure TPlayObject.CmdViewDiary(sCMD: string; nFlag: Integer); //004D1B70
begin
  try

  except
    MainOutMessage('[Exception] TPlayObject.CmdViewDiary');
  end;
end;

procedure TPlayObject.CmdViewWhisper(Cmd: pTGameCmd; sCharName, sParam2:
  string);
var
  PlayObject: TPlayObject;
begin
  try
    if (m_btPermission < Cmd.nPermissionMin) then
    begin
      SysMsg(g_sGameCommandPermissionTooLow, c_Red, t_Hint);
      exit;
    end;
    if (sCharName = '') or ((sCharName <> '') and (sCharName[1] = '?')) then
    begin
      SysMsg(format(g_sGameCommandParamUnKnow, [Cmd.sCmd,
        g_sGameCommandViewWhisperHelpMsg]), c_Red, t_Hint);
      exit;
    end;
    PlayObject := UserEngine.GeTPlayObject(sCharName);
    if PlayObject <> nil then
    begin
      if PlayObject.m_GetWhisperHuman = Self then
      begin
        PlayObject.m_GetWhisperHuman := nil;
        SysMsg(format(g_sGameCommandViewWhisperMsg1, [sCharName]), c_Green,
          t_Hint);
      end
      else
      begin
        PlayObject.m_GetWhisperHuman := Self;
        SysMsg(format(g_sGameCommandViewWhisperMsg2, [sCharName]), c_Green,
          t_Hint);
      end;
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sCharName]), c_Red,
        t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CmdViewWhisper');
  end;
end;

constructor TPlayObject.Create; //004C9860
var
  I: Integer;
begin
  try
    inherited;
    m_sDieMap := '';
    m_btRaceServer := RC_PLAYOBJECT;
    m_dwThinkTick := GetTickCount;
    m_boEmergencyClose := False;
    m_boSwitchData := False;
    m_boReconnection := False;
    m_boKickFlag := False;
    m_boSoftClose := False;
    m_boReadyRun := False;
    bo698 := False;
    n69C := 0;
    m_HeroMinHPTail:=0;
    m_nGloryPoint := 0;
    m_dwSaveRcdTick := GetTickCount();
    m_dwSortViewTime := GetTickCount();
    m_RandomNo := 0;
    m_boWantRefMsg := True;
    m_boRcdSaved := False;
    m_boDieInFight3Zone := False;
    m_Script := nil;
    m_MeteorRainTime := GetTickCount;
    m_boTimeRecall := False;
    m_sMoveMap := '';
    m_nMoveX := 0;
    m_nMoveY := 0;
    m_dwRunTick := GetTickCount();
    m_nRunTime := 250;
    m_dwSearchTime := 1000;
    m_dwSearchTick := GetTickCount();
    m_nViewRange := 12;
    m_boNewHuman := False;
    m_boLoginNoticeOK := False;
    bo6AB := False;
    m_boExpire := False;
    m_boSendNotice := False;
    m_dwCheckDupObjTick := GetTickCount();
    dwTick578 := GetTickCount();
    //dwTick57C          := GetTickCount();
    m_boInSafeArea := False;
    n5F8 := 0;
    n5FC := 0;
    m_dwMagicAttackTick := GetTickCount();
    m_dwMagicAttackInterval := 0;
    m_dwAttackTick := GetTickCount();
    m_dwMoveTick := GetTickCount();
    m_dwTurnTick := GetTickCount();
    m_dwActionTick := GetTickCount();
    m_dwAttackCount := 0;
    m_dwAttackCountA := 0;
    m_dwMagicAttackCount := 0;
    m_dwMoveCount := 0;
    m_dwMoveCountA := 0;
    m_nOverSpeedCount := 0;
    // TList55C                := TList.Create;
    m_sOldSayMsg := '';
    m_dwSayMsgTick := GetTickCount();
    m_boDisableSayMsg := False;
    m_dwDisableSayMsgTick := GetTickCount();
    m_dLogonTime := Now();
    m_dwLogonTick := GetTickCount();
    n584 := 0;
    n588 := 0;
    m_boSwitchData := False;
    m_boSwitchDataSended := False;
    m_nWriteChgDataErrCount := 0;
    m_dwShowLineNoticeTick := GetTickCount();
    m_nShowLineNoticeIdx := 0;
    m_dwShowLineNoticeTick2 := GetTickCount();
    m_nShowLineNoticeIdx2 := 0;
    m_dwSendWhisperTime := GetTickCount;
    m_nSendWhisperIdx := 0;
    m_nSoftVersionDateEx := 0;
    m_CanJmpScriptLableList := TStringList.Create;
    m_nKillMonExpMultiple := 1;
    m_nKillMonExpRate := 100;
    m_nSuitMonExpRate := 10;
    m_dwRateTick := GetTickCount();
    m_nPowerRate := 100;
    m_nKillMonCount := 0;

    m_DealGoldBase := nil;

    m_boNpcOffLine := False;
    m_boAutoOffLine := False;
    m_boSafeOffLine := False;
    m_dwSafeOffLine := 0;
    m_nOffLineAddExp := 0;
    m_boOffLineLogin := False;

    m_boSetStoragePwd := False;
    m_boReConfigPwd := False;
    m_boCheckOldPwd := False;
    m_boUnLockPwd := False;
    m_boUnLockStoragePwd := False;
    m_boPasswordLocked := False; //锁仓库
    m_btPwdFailCount := 0;
    m_sTempPwd := '';
    m_sStoragePwd := '';
    ;
    m_boFilterSendMsg := False;

    m_boCanDeal := True;
    m_boCanDrop := True;
    m_boCanGetBackItem := True;
    m_boCanWalk := True;
    m_boCanRun := True;
    m_boCanHit := True;
    m_boCanSpell := True;
    m_boCanUseItem := True;
    m_nMemberType := 0;
    m_nMemberLevel := 0;

    m_nGameGold := 0;
    m_boDecGameGold := False;
    m_nDecGameGold := 1;
    m_dwDecGameGoldTick := GetTickCount();
    m_dwDecGameGoldTime := 60 * 1000;

    m_boIncGameGold := False;
    m_nIncGameGold := 1;
    m_dwIncGameGoldTick := GetTickCount();
    m_dwIncGameGoldTime := 60 * 1000;

    m_nGamePoint := 0;
    m_dwIncGamePointTick := GetTickCount();

    m_nPayMentPoint := 0;

    //FillChar(m_ShopSend,SizeOf(m_ShopSend),False);  //商铺
    for I := Low(m_ShopSend) to High(m_ShopSend) do
      m_ShopSend[I] := False;

    FillChar(m_SuitIdx, SizeOf(m_SuitIdx), 0);

    FillChar(m_OpenAd, SizeOf(m_OpenAd), 0);

    m_ShopTickTime := GetTickCount;
    m_nGameDiamond := 0;
    m_nGameGird := 0;
    nTwinHitSkillTick := GetTickCount;
    nTwinHitSkillCount := 0;
    m_dwHeroAllExp := 0;
    m_boHeroFourMagic := False;
    m_boCheckOk := False;
    m_boAutoCheck := False;
    m_nChickNpc := 0;
    m_nChangeMap := 0;
    m_nChangeMap2 := 0;
    m_nAttact := 0;

    FillChar(OpenBoxItem, SizeOf(OpenBoxItem), #0);
    FillChar(OpenBoxGetItem, SizeOf(TClientItem), #0);
    FillChar(OpenBoxsSet, SizeOf(TBoxsSet), #0);
    m_boOpenBox := False;

    m_sOffLineFunc := '';

    m_OnTimerList := TList.Create;
    New(m_DelayNpc);
    m_DelayNpc.bLock := False;
    m_DelayNpc.NormNpc := nil;
    m_DelayNpc.sLable := '';
    m_DelayNpc.nDelayTime := 0;

    m_DearHuman := nil;
    m_MasterHuman := nil;
    m_MasterList := TList.Create;
    m_boSendMsgFlag := False;
    m_boChangeItemNameFlag := False;

    m_boCanMasterRecall := False;
    m_boCanDearRecall := False;
    m_dwDearRecallTick := GetTickCount();
    m_dwMasterRecallTick := GetTickCount();
    m_btReColorIdx := 0;
    m_GetWhisperHuman := nil;
    m_boOnHorse := False;
    m_wContribution := 0;
    m_sRankLevelName := g_sRankLevelName;
    m_boFixedHideMode := True;
    m_nStep := 0;
    FillChar(m_nMval, SizeOf(m_nMval), 0);
    FillChar(m_DyValEx, SizeOf(m_DyValEx), 0);
    for I := Low(m_StrVal) to High(m_StrVal) do
      m_StrVal[I] := '';
    for I := Low(m_ServerStrVal) to High(m_ServerStrVal) do
      m_ServerStrVal[I] := '';
    for I := Low(m_ServerIntVal) to High(m_ServerIntVal) do
      m_ServerIntVal[I] := 0;
    //m_nClientFlagMode         := -1;
    m_dwAutoGetExpTick := GetTickCount;
    m_nAutoGetExpPoint := 0;
    m_AutoGetExpEnvir := nil;
    m_dwHitIntervalTime := g_Config.dwHitIntervalTime; //攻击间隔
    m_dwMagicHitIntervalTime := g_Config.dwMagicHitIntervalTime; //魔法间隔
    m_dwRunIntervalTime := g_Config.dwRunIntervalTime; //走路间隔
    m_dwWalkIntervalTime := g_Config.dwWalkIntervalTime; //走路间隔
    m_dwTurnIntervalTime := g_Config.dwTurnIntervalTime; //换方向间隔
    m_dwActionIntervalTime := g_Config.dwActionIntervalTime; //组合操作间隔
    m_dwRunLongHitIntervalTime := g_Config.dwRunLongHitIntervalTime;
    //组合操作间隔
    m_dwRunHitIntervalTime := g_Config.dwRunHitIntervalTime; //组合操作间隔
    m_dwWalkHitIntervalTime := g_Config.dwWalkHitIntervalTime;
    //组合操作间隔
    m_dwRunMagicIntervalTime := g_Config.dwRunMagicIntervalTime;
    //跑位魔法间隔
    m_DynamicVarList := TList.Create;
    //m_SessInfo                := nil;
    m_boTestSpeedMode := False;
    m_boLockLogon := True;
    m_boLockLogoned := False;

    m_Challenge:=nil;//挑战的玩家
    pChallengeItem:=nil;//挑战物品
    m_boChallengeing:=False;//是否打开了挑战窗口正在抵押物品
    m_bochallengeOK:=False;//是否按了抵押品确定
    m_dwChallengeTime:=0;//开始挑战时间
    m_boKILLBYHUM:=False;//玩家是被怪物杀死还是人物
   try
      if assigned(m_HookCreate) then  m_HookCreate(Self);
    except
      MainOutMessage('[Exception] TPlayObject.Create->HookApi');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.Create');
  end;
end;

procedure TPlayObject.ShopCancel();
begin
  try
    if m_boShop then
    begin
      GetBackShopItems;
      SendRefMsg(RM_ISSHOP, 0, 0, 0, 0, '');
      SendChangeShop(self, False);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ShopCancel');
  end;
end;

procedure TPlayObject.DealCancel; //004DD394
begin
  try
    if not m_boDealing then
      exit;
    m_boDealing := False;
    SendDefMessage(SM_DEALCANCEL, 0, 0, 0, 0, '');
    if (m_DealCreat <> nil) and (m_DealCreat.m_btRaceServer = RC_PLAYOBJECT)  then
    begin
      TPlayObject(m_DealCreat).DealCancel;
    end;
    m_DealCreat := nil;
    GetBackDealItems();

    SysMsg(g_sDealActionCancelMsg {'交易取消'}, c_Green, t_Hint);
    m_DealLastTick := GetTickCount();
  except
    MainOutMessage('[Exception] TPlayObject.DealCancel');
  end;
end;

procedure TPlayObject.DealCancelA;
begin
  try
    m_Abil.HP := m_WAbil.HP;
    if not m_boHero then //非英雄发送数据
      DealCancel();
  except
    MainOutMessage('[Exception] TPlayObject.DealCancelA');
  end;
end;

function TPlayObject.DecGold(nGold: Integer): Boolean; //004BF6A8
begin
  try
    Result := False;
    if m_nGold >= nGold then
    begin
      Dec(m_nGold, nGold);
      Result := True;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.DecGold');
  end;
end;

destructor TPlayObject.Destroy; //004C9B54
var
  I: Integer;
begin
  try
    try
      if Assigned(m_HookDestroy) then
        m_HookDestroy(Self);
    except
      MainOutMessage('[Exception] TPlayObject.Destroy->HookApi');
    end;
    m_MasterList.Free;

    for I := 0 to m_DynamicVarList.Count - 1 do
    begin
      Dispose(pTDynamicVar(m_DynamicVarList.Items[I]));
    end;
    m_DynamicVarList.Free;
    m_CanJmpScriptLableList.Free;
    for I := 0 to m_OnTimerList.Count - 1 do
    begin
      Dispose(pTOnTimer(m_OnTimerList.Items[I]));
    end;
    m_OnTimerList.Free;
    if m_DelayNpc <> nil then
      Dispose(m_DelayNpc);
    inherited;
  except
    MainOutMessage('[Exception] TPlayObject.Destroy');
  end;
end;

procedure TPlayObject.Disappear; //004CA89C
var
  m_DefMsg: TDefaultMessage;
begin
  try
    if m_boReadyRun then
      DisappearA;
    if m_boHero then
    begin
      m_HeroHuman.m_HeroCallTime := GetTickCount;
      m_DefMsg := MakeDefaultMsg(SM_918, 0, 0, 0, 0);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, '');
      SendRefMsg(RM_CLOSEHEROHALO, Integer(Self), m_nCurrX, m_nCurrY,
        m_btDirection, '');
      TPlayObject(m_HeroHuman).SysMsg(sHeroClose, c_Green, t_Hint);
      m_HeroHuman.m_Hero := nil;
    end
    else
    begin
      if m_boTransparent and m_boHideMode then
        m_wStatusTimeArr[STATE_TRANSPARENT {0x70}] := 0; //004CA8F7

      if m_GroupOwner <> nil then
      begin
        m_GroupOwner.DelMember(Self);
      end;
      if m_MyGuild <> nil then
      begin
        TGuild(m_MyGuild).DelHumanObj(Self);
      end;
      LogonTimcCost();
    end;
    inherited;
  except
    MainOutMessage('[Exception] TPlayObject.Disappear');
  end;
end;
{$REGION '没用的'}
{procedure TPlayObject.DropUseItems(BaseObject: TBaseObject);
var
  I: Integer;
  nRate:Integer;
  StdItem:TItem;
  DelList:TStringList;
ResourceString
  sExceptionMsg = '[Exception] TPlayObject::DropUseItems';
begin
Try
  DelList:=nil;
  try
    if m_boAngryRing or m_boNoDropUseItem then exit;
    for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      StdItem:=UserEngine.GetStdItem(m_UseItems[I].wIndex);
      if StdItem <> nil then begin
        if StdItem.Reserved and 8 <> 0 then begin
          if DelList = nil then DelList:=TStringList.Create;
          DelList.AddObject('',TObject(m_UseItems[I].MakeIndex));
          //004BB885
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('16' +  #9 +
                     m_sMapName + #9 +
                     IntToStr(m_nCurrX) + #9 +
                     IntToStr(m_nCurrY) + #9 +
                     m_sCharName + #9 +
                     //UserEngine.GetStdItemName(m_UseItems[I].wIndex) + #9 +
                     StdItem.Name + #9 +
                     IntToStr(m_UseItems[I].MakeIndex) + #9 +
                     BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                     '0');
          m_UseItems[I].wIndex:=0;
        end;
      end;
    end;

    if PKLevel > 2 then nRate:=g_Config.nDieRedDropUseItemRate
    else nRate:=g_Config.nDieDropUseItemRate{30}

   { for I := Low(THumanUseItems) to High(THumanUseItems) do begin
      if Random(nRate) <> 0 then Continue;
      if InDisableTakeOffList(m_UseItems[I].wIndex) then Continue;    //检查是否在禁止取下列表,如果在列表中则不掉此物品
      if CheckItemState(@m_UseItems[I],ITEMSTATE_SCATTER,False) then Continue; //检查是否禁止爆出
      if DropItemDown(@m_UseItems[I],2,True,BaseObject,Self) then begin
          StdItem:=UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if StdItem <> nil then begin
            if StdItem.Reserved and 10 = 0 then begin
              if m_btRaceServer = RC_PLAYOBJECT then begin
                if DelList = nil then DelList:=TStringList.Create;
                DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex),TObject(m_UseItems[I].MakeIndex));
              end;
              m_UseItems[I].wIndex:=0;
            end;
          end;
      end;
    end;
    if DelList <> nil then
      SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DelList),0,0,'');
  except
    MainOutMessage(sExceptionMsg);
  end;
Except
  MainOutMessage('[Exception] TPlayObject.DropUseItems');
End;
end;    }
{$ENDREGION}
procedure TPlayObject.GainExp(dwExp: LongWord); //004BE600
var
  i, n, sumlv: integer;
  PlayObject: TPlayObject;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::GainExp';
const
  bonus: array[0..GROUPMAX] of Real = (1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8,
    1.9, 2, 2.1, 2.2);
begin
  try
    try
      if m_GroupOwner <> nil then
      begin
        sumlv := 0;
        n := 0;
        for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
        begin
          PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
          if not PlayObject.m_boDeath and ((m_PEnvir = PlayObject.m_PEnvir) or
            g_Config.boGroupSameMap) and ((abs(m_nCurrX - PlayObject.m_nCurrX)
            <=
            12) or g_Config.boGroupSameScreen) and ((abs(m_nCurrX -
            PlayObject.m_nCurrX) <= 12) or g_Config.boGroupSameScreen) then
          begin
            sumlv := sumlv + PlayObject.m_Abil.Level;
            Inc(n);
          end;
        end;
        if (sumlv > 0) and (n > 1) then
        begin
          if n in [0..GROUPMAX] then
            dwExp := Round(dwExp * bonus[n]);
          for i := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
          begin
            PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
            if not PlayObject.m_boDeath and ((m_PEnvir = PlayObject.m_PEnvir) or
              g_Config.boGroupSameMap) and ((abs(m_nCurrX - PlayObject.m_nCurrX)
              <= 12) or g_Config.boGroupSameScreen) and ((abs(m_nCurrX -
              PlayObject.m_nCurrX) <= 12) or g_Config.boGroupSameScreen) then
            begin
              {if g_Config.boHighLevelGroupFixExp then begin  //Jason 高低等级组队经验不变
                PlayObject.WinExp (dwExp);
              end else begin}
              //Jason 高低等级组队经验不变 g_Config.boHighLevelKillMonFixExp
              if g_Config.boHighLevelGroupFixExp then
              begin //02/08 增加，在高等级经验不变时，把组队的经验平均分配
                PlayObject.WinExp(Round(dwExp / n));
              end
              else
              begin
                PlayObject.WinExp(Round(dwExp / sumlv *
                  PlayObject.m_Abil.Level));
              end;
              //end;
            end;
          end;
        end
        else
          WinExp(dwExp);
      end
      else
        WinExp(dwExp);
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GainExp');
  end;
end;

procedure TPlayObject.GameTimeChanged;
begin
  try
    if m_btBright <> g_nGameTime then
    begin
      m_btBright := g_nGameTime;
      SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GameTimeChanged');
  end;
end;

procedure TPlayObject.GetBackShopItems();
var
  I: Integer;
  UserShopItem: pTUserShopItem;
begin
  try
    if m_ShopItemList.Count > 0 then
    begin
      for I := 0 to m_ShopItemList.Count - 1 do
      begin
        UserShopItem := m_ShopItemList.Items[i];
        //m_ItemList.Add(UserShopItem.Item);
        Dispose(UserShopItem);
      end;
    end;
    m_ShopItemList.Clear;
    m_boShop := False;
    m_sShopMsg := '';
  except
    MainOutMessage('[Exception] TPlayObject.GetBackShopItems');
  end;
end;

procedure TPlayObject.GetBackDealItems; //004DD270
var
  I: Integer;
begin
  try
    if m_DealItemList.Count > 0 then
    begin
      for I := 0 to m_DealItemList.Count - 1 do
      begin
        m_ItemList.Add(m_DealItemList.Items[i]);
      end;
    end;
    m_DealItemList.Clear;
    Inc(m_nGold, m_nDealGolds);
    m_nDealGolds := 0;
    m_boDealOK := False;
  except
    MainOutMessage('[Exception] TPlayObject.GetBackDealItems');
  end;
end;

{$REGION '没用的'}
{procedure TPlayObject.GetBagUseItems(var btDc, btSc, btMc, btDura: Byte);
  var
    I,II: Integer;
    DuraList:TList;
    UserItem:pTUserItem;
    StdItem:TItem;
    StdItem80:TStdItem;
    DelItemList:TStringList;
    nDc,nSc,nMc,nDcMin,nDcMax,nScMin,nScMax,nMcMin,nMcMax,nDura,nItemCount:Integer;
  begin
Try
    nDcMin:=0;
    nDcMax:=0;
    nScMin:=0;
    nScMax:=0;
    nMcMin:=0;
    nMcMax:=0;
    nDura:=0;
    nItemCount:=0;
    DelItemList:=nil;
    DuraList:=TList.Create;
    for I := m_ItemList.Count - 1 downto 0 do begin
      UserItem:=m_ItemList.Items[I];
      if UserEngine.GetStdItemName(UserItem.wIndex) = g_Config.sBlackStone then begin
        DuraList.Add(Pointer(ROUND(UserItem.Dura / 1.0e3)));
        if DelItemList = nil then DelItemList:=TStringList.Create;
        DelItemList.AddObject(g_Config.sBlackStone,TObject(UserItem.MakeIndex));
        DisPose(UserItem);
        m_ItemList.Delete(I);
      end else begin
        if IsAccessory2(UserItem.wIndex) then begin
          StdItem:=UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then begin
            StdItem.GetStandardItem(StdItem80);
            StdItem.GetItemAddValue(UserItem,StdItem80);
            nDc:=0;
            nSc:=0;
            nMc:=0;
            if StdItem.ItemType = ITEM_ACCESSORY then begin
              case StdItem80.StdMode of
                19,20,21: begin //004A0421
                  nDc:=HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                  nSc:=HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                  nMc:=HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
                end;
                22,23: begin //004A046E
                  nDc:=HiWord(StdItem80.DC) + LoWord(StdItem80.DC);
                  nSc:=HiWord(StdItem80.SC) + LoWord(StdItem80.SC);
                  nMc:=HiWord(StdItem80.MC) + LoWord(StdItem80.MC);
                end;
                24,26: begin
                  nDc:=HiWord(StdItem80.DC) + LoWord(StdItem80.DC) + 1;
                  nSc:=HiWord(StdItem80.SC) + LoWord(StdItem80.SC) + 1;
                  nMc:=HiWord(StdItem80.MC) + LoWord(StdItem80.MC) + 1;
                end;
              end;
            end;
            if nDcMin < nDc then begin
              nDcMax:=nDcMin;
              nDcMin:=nDc;
            end else begin
              if nDcMax < nDc then nDcMax:=nDc;
            end;
            if nScMin < nSc then begin
              nScMax:=nScMin;
              nScMin:=nSc;
            end else begin
              if nScMax < nSc then nScMax:=nSc;
            end;
            if nMcMin < nMc then begin
              nMcMax:=nMcMin;
              nMcMin:=nMc;
            end else begin
              if nMcMax < nMc then nMcMax:=nMc;
            end;
            if DelItemList = nil then DelItemList:=TStringList.Create;
            DelItemList.AddObject(StdItem.Name,TObject(UserItem.MakeIndex));
            //004A06DB
            if StdItem.NeedIdentify = 1 then
            AddGameDataLog('26' +  #9 +
                           m_sMapName + #9 +
                           IntToStr(m_nCurrX) + #9 +
                           IntToStr(m_nCurrY) + #9 +
                           m_sCharName + #9 +
                           //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                           StdItem.Name + #9 +
                           IntToStr(UserItem.MakeIndex) + #9 +
                           '1' + #9 +
                           '0');
            DisPose(UserItem);
            m_ItemList.Delete(I);
          end;
        end;
      end;
    end;    // for
    for I := 0 to DuraList.Count - 1 do begin
      for II := DuraList.Count -1 downto i + 1 do begin
        if Integer(DuraList.Items[II]) > Integer(DuraList.Items[II- 1]) then
          DuraList.Exchange(II,II-1);
      end;    // for
    end;    // for
    for I := 0 to DuraList.Count - 1 do begin
      nDura:=nDura + Integer(DuraList.Items[I]);
      Inc(nItemCount);
      if nItemCount >= 5 then break;
    end;
    btDura:=ROUND(_MIN(5,nItemCount) + _MIN(5,nItemCount) * ((nDura /nItemCount) / 5.0));
    btDc:=nDcMin div 5 + nDcMax div 3;
    btSc:=nScMin div 5 + nScMax div 3;
    btMc:=nMcMin div 5 + nMcMax div 3;
    if DelItemList <> nil then
      SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DelItemList),0,0,'');

    if DuraList <> nil then DuraList.Free;
Except
  MainOutMessage('[Exception] TPlayObject.GetBagUseItems');
End;
end;  }
{$ENDREGION}
function TPlayObject.GeTBaseObjectInfo: string;
begin
  try
    Result := m_sCharName +
      ' 标识:' + IntToHex(Integer(Self), 2) +
      ' 权限等级: ' + IntToStr(m_btPermission) +
      ' 管理模式: ' + BoolToStr(m_boAdminMode) +
      ' 隐身模式: ' + BoolToStr(m_boObMode) +
      ' 无敌模式: ' + BoolToStr(m_boSuperMan) +
      ' 地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ')' +
      ' 座标:' + IntToStr(m_nCurrX) + ':' + IntToStr(m_nCurrY) +
      ' 等级:' + IntToStr(m_Abil.Level) +
      ' 转生等级:' + IntToStr(m_btReLevel) +
      ' 经验值:' + IntToStr(m_Abil.Exp) +
      ' 生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) +
      ' 魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) +
      ' 攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' +
      IntToStr(HiWord(m_WAbil.DC)) +
      ' 魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' +
      IntToStr(HiWord(m_WAbil.MC)) +
      ' 道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' +
      IntToStr(HiWord(m_WAbil.SC)) +
      ' 防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' +
      IntToStr(HiWord(m_WAbil.AC)) +
      ' 魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' +
      IntToStr(HiWord(m_WAbil.MAC)) +
      ' 准确:' + IntToStr(m_btHitPoint) +
      ' 敏捷:' + IntToStr(m_btSpeedPoint) +
      ' 速度:' + IntToStr(m_nHitSpeed) +
      ' 仓库密码:' + m_sStoragePwd +
      ' 登录IP:' + m_sIPaddr + '(' + m_sIPLocal {GetIPLocal(m_sIPaddr)} + ')'
    +
      ' 登录帐号:' + m_sUserID +
      ' 登录时间:' + DateTimeToStr(m_dLogonTime) +
      ' 在线时长(分钟):' + IntToStr((GetTickCount - m_dwLogonTick) div
      60000) +
      ' 登录模式:' + IntToStr(m_nPayMent) +
      ' ' + g_Config.sGameGoldName + ':' + IntToStr(m_nGameGold) +
      ' ' + g_Config.sGamePointName + ':' + IntToStr(m_nGamePoint) +
      ' ' + g_Config.sPayMentPointName + ':' + IntToStr(m_nPayMentPoint) +
      ' 会员类型:' + IntToStr(m_nMemberType) +
      ' 会员等级:' + IntToStr(m_nMemberLevel) +
      ' 经验倍数:' + CurrToStr(m_nKillMonExpRate / 100) +
      ' 攻击倍数:' + CurrToStr(m_nPowerRate / 100) +
      ' 声望值:' + IntToStr(m_btCreditPoint);
  except
    MainOutMessage('[Exception] TPlayObject.GeTBaseObjectInfo');
  end;
end;

function TPlayObject.GetDigUpMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_BUTCH) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetDigUpMsgCount:');
  end;
end;

procedure TBaseObject.UseLamp; //004C759C
var
  nOldDura: Integer;
  nDura: Integer;
  PlayObject: TPlayObject;
  Stditem: TItem;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::UseLamp';
begin
  try
    try
      if m_UseItems[U_RIGHTHAND].wIndex > 0 then
      begin
        Stditem := UserEngine.GetStdItem(m_UseItems[U_RIGHTHAND].wIndex);
        if (Stditem = nil) or (Stditem.Source <> 0) then
          exit;

        nOldDura := ROUND(m_UseItems[U_RIGHTHAND].Dura / 1000);
        if g_Config.boDecLampDura then
        begin
          nDura := m_UseItems[U_RIGHTHAND].Dura - 1;
        end
        else
        begin
          nDura := m_UseItems[U_RIGHTHAND].Dura;
        end;
        if nDura <= 0 then
        begin
          m_UseItems[U_RIGHTHAND].Dura := 0;
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            PlayObject := TPlayObject(Self);
            PlayObject.SendDelItems(@m_UseItems[U_RIGHTHAND]);
          end;
          m_UseItems[U_RIGHTHAND].wIndex := 0;
          m_nLight := 0;
          SendRefMsg(RM_CHANGELIGHT, 0, 0, 0, 0, '');
          SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0,
            0,
            '');
          RecalcAbilitys();
          //        FeatureChanged(); 01/21 取消 蜡烛是本人才可以看到的，不需要发送广播信息
        end
        else
          m_UseItems[U_RIGHTHAND].Dura := nDura;
        if nOldDura <> ROUND(nDura / 1000) then
        begin
          SendMsg(Self, RM_LAMPCHANGEDURA, 0, m_UseItems[U_RIGHTHAND].Dura, 0,
            0,
            '');
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.UseLamp');
  end;
end;

//004C368C

function TBaseObject.GetPoseCreate: TBaseObject;
var
  nX, nY: Integer;
begin
  try
    Result := nil;
    if GetFrontPosition(nX, nY) then
    begin
      Result := m_PEnvir.GetMovingObject(nX, nY, True);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetPoseCreate:');
  end;
end;

procedure TPlayObject.SendDelShopItem(UserItem: pTUserItem);
begin
  try
    SendDefMessage(SM_DELSHOPITEM, UserItem.MakeIndex, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.SendDelShopItem');
  end;
end;

procedure TPlayObject.ClientBuySelfShopItem(BaseObject: TBaseObject; nX, nY:
  Integer; sMsg: string);
var
  boBuy: Boolean;
  nItemIdx: Integer;
  nCode, I, II: Integer;
  UserShopItem: pTUserShopItem;
  StdItem: TItem;
  UserItem: pTUserItem;
  PlayObject: TPlayObject;

  function CheckGold(nCount: Integer; boGameGold: Boolean): Boolean;
  begin
    Result := False;
    if boGameGold then
    begin
      if (m_nGameGold >= nCount) and ((PlayObject.m_nGameGold + nCount) <
        High(m_nGameGold)) then
      begin
        Result := True;
      end;
    end
    else
    begin
      if (m_nGold >= nCount) and ((PlayObject.m_nGold + nCount) <
        g_Config.nHumanMaxGold) then
      begin
        Result := True;
      end;
    end;
  end;

  procedure AddGold(nCount: Integer; boGameGold: Boolean);
  begin
    if boGameGold then
    begin
      Inc(PlayObject.m_nGameGold, nCount);
      Dec(m_nGameGold, nCount);
    end
    else
    begin
      Inc(PlayObject.m_nGold, nCount);
      Dec(m_nGold, nCount);
    end;
    GoldChanged;
    PlayObject.GoldChanged;
  end;
begin
  try
    try
      boBuy := False;
      nCode := -1;
      nItemIdx := Str_ToInt(sMsg, -1);
      if CretInNearXY(BaseObject, nX, nY) and (BaseObject.m_btRaceServer =
        RC_PLAYOBJECT) and (not BaseObject.m_boHero) then
      begin
        PlayObject := TPlayObject(BaseObject);
        nCode := 0;
        if (PlayObject.m_boShop) and (nItemIdx > 0) then
        begin
          nCode := 1; //购买的物品不存在
          for I := 0 to PlayObject.m_ShopItemList.Count - 1 do
          begin
            UserShopItem := PlayObject.m_ShopItemList.Items[I];
            if UserShopItem.Item = nItemIdx then
            begin
              for ii := 0 to PlayObject.m_ItemList.Count - 1 do
              begin
                UserItem := PlayObject.m_ItemList.Items[II];
                if UserItem.MakeIndex = nItemIdx then
                begin
                  if (GetItemState(UserItem, ITEMSTATE_DROP) <> 0) then
                    break;
                  if (GetItemState(UserItem, ITEMSTATE_DEAL) <> 0) then
                    break;
                  if (GetItemState(UserItem, ITEMSTATE_SELL) <> 0) then
                    break;
                  if (GetItemState(UserItem, ITEMSTATE_SCATTER) <> 0) then
                    break;
                  StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                  if StdItem <> nil then
                  begin
                    if StdItem.nRule[RULE_PLAYSELL] then
                      break; //禁止摆摊物品
                    nCode := 2; //钱不够，或卖东西的钱太多
                    if CheckGold(UserShopItem.nPic, UserShopItem.boCls) then
                    begin
                      nCode := 3; //背包物品已满
                      if AddItemToBag(UserItem) then
                      begin
                        boBuy := True;
                        AddGold(UserShopItem.nPic, UserShopItem.boCls);
                        PlayObject.SendDelShopItem(UserItem);
                        if StdItem.NeedIdentify = 1 then
                          AddGameDataLog(IntToStr(LOG_SELFSHOPITEM) + #9 +
                            m_sCharName + #9 +
                            IntToStr(m_nCurrX) + #9 +
                            IntToStr(m_nCurrY) + #9 +
                            PlayObject.m_sCharName + #9 +
                            StdItem.Name + #9 +
                            IntToStr(nItemIdx) + #9 +
                            IntToStr(UserShopItem.nPic) + '-' +
                            BoolToStr(UserShopItem.boCls) + #9 +
                            '0');
                        Dispose(UserShopItem);
                        PlayObject.m_ShopItemList.Delete(I);
                        PlayObject.m_ItemList.Delete(II);
                      end;
                    end;
                  end;
                  break;
                end;
              end;
              break;
            end;
          end;
        end;
      end;
      if boBuy then
        SendDefMessage(SM_PLAYSHOP_OK, 0, 0, 0, 0, '')
      else
        SendDefMessage(SM_PLAYSHOP_FALL, nCode, 0, 0, 0, '');
    except
      MainOutMessage('[Exception] TPlayObject.ClientBuySelfShopItem');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientBuySelfShopItem');
  end;
end;

procedure TPlayObject.ClientGetShopList();
var
  OShopItem: TOShopItem;
  ShopItem: TShopItem;
  UserShopItem: pTUserShopItem;
  UserItem: pTUserItem;
  sSendMsg: string;
  Item: TItem;
  I: integer;
begin
  try
    sSendMsg := '';
    for I := 0 to m_ShopItemList.Count - 1 do
    begin
      UserShopItem := m_ShopItemList.Items[I];
      UserItem := GetBagItemsEx(UserShopItem.Item);
      if UserItem = nil then
        Continue;
      //if UserItem.btValue[15]<>0 then Continue; //已绑定过的物品不允许出售
      if (GetItemState(UserItem, ITEMSTATE_DROP) <> 0) then
        Continue;
      if (GetItemState(UserItem, ITEMSTATE_DEAL) <> 0) then
        Continue;
      if (GetItemState(UserItem, ITEMSTATE_SELL) <> 0) then
        Continue;
      if (GetItemState(UserItem, ITEMSTATE_SCATTER) <> 0) then
        Continue;
      Item := UserEngine.GetStdItem(UserItem.wIndex);
      FillChar(OShopItem, SizeOf(TOShopItem), #0);
      FillChar(ShopItem, SizeOf(TShopItem), #0);
      if Item <> nil then
      begin
        if Item.nRule[RULE_PLAYSELL] then
          Continue; //禁止摆摊物品
        if m_dwClientTickEx > 20080108 then
        begin
          Item.GetStandardItem(ShopItem.Item.S);
          Item.GetItemAddValue(UserItem, ShopItem.Item.S);
          ShopItem.Item.Desc := Item.sDesc;
          ShopItem.Item.Shine := 0;
          ShopItem.Item.S.Name := GetItemName(UserItem);
          ShopItem.Item.Dura := UserItem.Dura;
          ShopItem.Item.DuraMax := UserItem.DuraMax;
          ShopItem.Item.MakeIndex := UserItem.MakeIndex;
          ShopItem.nPic := UserShopItem.nPic;
          ShopItem.boCls := UserShopItem.boCls;
          GetMapItemInfo(UserItem, ShopItem.Item.S);
          sSendMsg := sSendMsg + EncodeBuffer(@ShopItem, SizeOf(TShopItem)) +
            '/';
        end
        else
        begin
          Item.GetStandardItem(OShopItem.Item.S);
          Item.GetItemAddValue(UserItem, OShopItem.Item.S);
          OShopItem.Item.S.Name := GetItemName(UserItem);
          OShopItem.Item.Dura := UserItem.Dura;
          OShopItem.Item.DuraMax := UserItem.DuraMax;
          OShopItem.Item.MakeIndex := UserItem.MakeIndex;
          OShopItem.nPic := UserShopItem.nPic;
          OShopItem.boCls := UserShopItem.boCls;
          GetMapItemInfo(UserItem, OShopItem.Item.S);
          sSendMsg := sSendMsg + EncodeBuffer(@OShopItem, SizeOf(TOShopItem)) +
            '/';
        end;
      end;
    end;
    SendDefMessage(SM_SELLSHOPTITLE, 0, 0, 0, 0, m_sShopMsg);
    m_DefMsg := MakeDefaultMsg(SM_SELLSHOPLIST, Integer(Self), 0, 0, 0);
    SendSocket(@m_DefMsg, sSendMsg);
  except
    MainOutMessage('[Exception] TPlayObject.ClientGetShopList');
  end;
end;

procedure TPlayObject.ClientClickPlay(BaseObject: TBaseObject; nX, nY: Integer);
var
  OShopItem: TOShopItem;
  ShopItem: TShopItem;
  UserShopItem: pTUserShopItem;
  UserItem: pTUserItem;
  sSendMsg: string;
  Item: TItem;
  I: integer;
  PlayObject: TPlayObject;
begin
  try
    try
      if not CretInNearXY(BaseObject, nX, nY) then
        exit;
      if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) or (BaseObject.m_boHero)
        then
        exit;
      PlayObject := TPlayObject(BaseObject);
      if PlayObject.m_boShop then
      begin
        sSendMsg := '';
        for I := 0 to PlayObject.m_ShopItemList.Count - 1 do
        begin
          UserShopItem := PlayObject.m_ShopItemList.Items[I];
          UserItem := PlayObject.GetBagItemsEx(UserShopItem.Item);
          if UserItem = nil then
            Continue;
          //if UserItem.btValue[15]<>0 then Continue; //已绑定过的物品不允许出售
          if (GetItemState(UserItem, ITEMSTATE_DROP) <> 0) then
            Continue;
          if (GetItemState(UserItem, ITEMSTATE_DEAL) <> 0) then
            Continue;
          if (GetItemState(UserItem, ITEMSTATE_SELL) <> 0) then
            Continue;
          if (GetItemState(UserItem, ITEMSTATE_SCATTER) <> 0) then
            Continue;
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          FillChar(OShopItem, SizeOf(TOShopItem), #0);
          FillChar(ShopItem, SizeOf(TShopItem), #0);
          if Item <> nil then
          begin
            if Item.nRule[RULE_PLAYSELL] then
              Continue; //禁止摆摊物品
            if m_dwClientTickEx > 20080108 then
            begin
              Item.GetStandardItem(ShopItem.Item.S);
              Item.GetItemAddValue(UserItem, ShopItem.Item.S);
              ShopItem.Item.S.Name := GetItemName(UserItem);
              ShopItem.Item.Dura := UserItem.Dura;
              ShopItem.Item.DuraMax := UserItem.DuraMax;
              ShopItem.Item.MakeIndex := UserItem.MakeIndex;
              ShopItem.nPic := UserShopItem.nPic;
              ShopItem.boCls := UserShopItem.boCls;
              GetMapItemInfo(UserItem, ShopItem.Item.S);
              sSendMsg := sSendMsg + EncodeBuffer(@ShopItem, SizeOf(TShopItem))
                +
                '/';
            end
            else
            begin
              Item.GetStandardItem(OShopItem.Item.S);
              Item.GetItemAddValue(UserItem, OShopItem.Item.S);
              OShopItem.Item.S.Name := GetItemName(UserItem);
              OShopItem.Item.Dura := UserItem.Dura;
              OShopItem.Item.DuraMax := UserItem.DuraMax;
              OShopItem.Item.MakeIndex := UserItem.MakeIndex;
              OShopItem.nPic := UserShopItem.nPic;
              OShopItem.boCls := UserShopItem.boCls;
              GetMapItemInfo(UserItem, OShopItem.Item.S);
              sSendMsg := sSendMsg + EncodeBuffer(@OShopItem, SizeOf(TOShopItem))
                + '/';
            end;
          end;
        end;
        m_DefMsg := MakeDefaultMsg(SM_PLAYSHOPLIST, Integer(PlayObject), 0, 0,
          0);
        SendSocket(@m_DefMsg, sSendMsg);
      end;
    except
      MainOutMessage('[Exception] TPlayObject.ClientClickPlay');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientClickPlay');
  end;
end;

//刷新包裹
procedure TPlayObject.ClientQueryBagItems; //004D0EDC
var
  i: Integer;
  sSendMsg: string;
  UserItem: pTUserItem;
begin
  try
    try
      if Assigned(m_HookClientQueryBagItems) then
        m_HookClientQueryBagItems(Self);
    except
      MainOutMessage('[Exception] TPlayObject.ClientQueryBagItems->HookApi');
    end;
    sSendMsg := '';
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      sSendMsg := sSendMsg + MakeClientItem(UserItem) + '/';
    end;
    if m_boHero then
    begin
      m_DefMsg := MakeDefaultMsg(SM_902, Integer(Self), 0, 0, GetHeroBagCount);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, sSendMsg);
    end
    else if sSendMsg <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_BAGITEMS, Integer(Self), 0, 0,
        m_ItemList.Count);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientQueryBagItems');
  end;
end;

procedure TPlayObject.ClientQueryUserSet(ProcessMsg: pTProcessMessage);
//var
//  sPassword:String;
begin
  try
    {sPassword:=GetMD5Text(ProcessMsg.sMsg);
    if sPassword <> DeCodeString('NbA_VsaSTRucMbAjUl') then begin
      MainOutMessage('Fail');
      exit;
    end;
    m_nClientFlagMode:=ProcessMsg.wParam;
    MainOutMessage(format('OK:%d',[m_nClientFlagMode])); }
    //'JackyWangFang'
    //'8988e0804091579a2fd8a0db75e9c17a';
    //'NbA_VsaSTRucMbAjUl'
  except
    MainOutMessage('[Exception] TPlayObject.ClientQueryUserSet');
  end;
end;

procedure TPlayObject.ClientQueryUserState(PlayObject: TBaseObject; nX, nY:
  Integer); //004DE654
var
  I: Integer;
  UserState: TUserStateInfo;
  OUserState: TOUserStateInfo;
  OUserState2: TOUserStateInfo2;
  Item: TItem;
  StdItem: TStdItem;
  ClientItem: TClientItem;
  OClientItem: TOClientItem;
  OClientItem2: TOClientItem2;
  UserItem: pTUserItem;
  sShowName,ShHeroShowName:string;
begin
  try
    try
      if Assigned(m_HookClientQueryUserState) then
        m_HookClientQueryUserState(Self, PlayObject, nX, nY);
    except
      MainOutMessage('[Exception] TPlayObject.ClientQueryUserState->HookApi');
    end;
    if not CretInNearXY(PlayObject, nX, nY) then
      exit;
      sShowName:=PlayObject.m_sCharName;
      ShHeroShowName:=PlayObject.m_HeroName;
      if PlayObject.m_UseItems[U_STRAW].wIndex > 0 then
      begin
        if (PlayObject.m_boHero and g_Config.boHeroShowMystery) or
          ((not PlayObject.m_boHero) and g_Config.boPlayShowMystery) then
        begin
          sShowName:= '神秘人';
          ShHeroShowName:='神秘人';
        end;
      end;
    if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
    begin
      FillChar(OUserState, SizeOf(TOUserStateInfo), #0);
      OUserState.Feature := PlayObject.GetFeature(Self);
      if PlayObject.m_btRaceServer = RC_PLAYOBJECT then
        OUserState.UserName := sShowName//PlayObject.m_sCharName
      else
        OUserState.UserName := FilterShowName(PlayObject.m_sCharName);
      OUserState.NameColor := GetCharColor(PlayObject);
      if PlayObject.m_boHero then
      begin
        OUserState.GuildName :=ShHeroShowName;//PlayObject.m_HeroName;
        OUserState.GuildRankName := g_Config.sHeroNameSuffix;
      end
      else
      begin
        if PlayObject.m_MyGuild <> nil then
        begin
          OUserState.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
        end;
        OUserState.GuildRankName := PlayObject.m_sGuildRankName;
      end;

      for I := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        UserItem := @PlayObject.m_UseItems[i];
        if UserItem.wIndex > 0 then
        begin
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          if Item = nil then
            Continue;
          Item.GetStandardItem(StdItem);
          Item.GetItemAddValue(UserItem, StdItem);
          StdItem.Name := GetItemName(UserItem);
          CopyStdItemToOStdItem(@StdItem, @OClientItem.S);

          OClientItem.MakeIndex := UserItem.MakeIndex;
          OClientItem.Dura := UserItem.Dura;
          OClientItem.DuraMax := UserItem.DuraMax;
          OUserState.UseItems[I] := OClientItem;
        end;
      end;
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@OUserState, SizeOf(TOUserStateInfo)));
    end
    else if m_dwClientTickEx > 20080108 then
    begin
      FillChar(UserState, SizeOf(TUserStateInfo), #0);
      UserState.Feature := PlayObject.GetFeature(Self);
      if PlayObject.m_btRaceServer = RC_PLAYOBJECT then
        UserState.UserName :=sShowName// PlayObject.m_sCharName
      else
        UserState.UserName := FilterShowName(PlayObject.m_sCharName);
      UserState.NameColor := GetCharColor(PlayObject);
      if PlayObject.m_boHero then
      begin
        UserState.GuildName :=ShHeroShowName;//PlayObject.m_HeroName;
        UserState.GuildRankName := g_Config.sHeroNameSuffix;
      end
      else
      begin
        if PlayObject.m_MyGuild <> nil then
        begin
          UserState.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
        end;
        UserState.GuildRankName := PlayObject.m_sGuildRankName;
      end;

      for I := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        UserItem := @PlayObject.m_UseItems[i];
        if UserItem.wIndex > 0 then
        begin
          Item := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
          if Item = nil then
            Continue;
          Item.GetStandardItem(ClientItem.S);
          Item.GetItemAddValue(UserItem, ClientItem.S);
          ClientItem.S.Name := GetItemName(UserItem);
          ClientItem.Desc := Item.sDesc;
          ClientItem.Shine := GetItemState(UserItem, ITEMSTATE_SHINE);
          ClientItem.MakeIndex := UserItem.MakeIndex;
          ClientItem.Dura := UserItem.Dura;
          ClientItem.DuraMax := UserItem.DuraMax;
          UserState.UseItems[I] := ClientItem;
        end;
      end;
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@UserState, SizeOf(TUserStateInfo)));
    end
    else
    begin
      FillChar(OUserState2, SizeOf(TOUserStateInfo2), #0);
      OUserState2.Feature := PlayObject.GetFeature(Self);
      if PlayObject.m_btRaceServer = RC_PLAYOBJECT then
        OUserState2.UserName := sShowName//PlayObject.m_sCharName
      else
        OUserState2.UserName := FilterShowName(PlayObject.m_sCharName);
      OUserState2.NameColor := GetCharColor(PlayObject);
      if PlayObject.m_boHero then
      begin
        OUserState2.GuildName := ShHeroShowName;//PlayObject.m_HeroName;
        OUserState2.GuildRankName := g_Config.sHeroNameSuffix;
      end
      else
      begin
        if PlayObject.m_MyGuild <> nil then
        begin
          OUserState2.GuildName := TGuild(PlayObject.m_MyGuild).sGuildName;
        end;
        OUserState2.GuildRankName := PlayObject.m_sGuildRankName;
      end;

      for I := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        UserItem := @PlayObject.m_UseItems[i];
        if UserItem.wIndex > 0 then
        begin
          Item := UserEngine.GetStdItem(PlayObject.m_UseItems[i].wIndex);
          if Item = nil then
            Continue;
          Item.GetStandardItem(OClientItem2.S);
          Item.GetItemAddValue(UserItem, OClientItem2.S);
          OClientItem2.S.Name := GetItemName(UserItem);
          OClientItem2.MakeIndex := UserItem.MakeIndex;
          OClientItem2.Dura := UserItem.Dura;
          OClientItem2.DuraMax := UserItem.DuraMax;
          OUserState2.UseItems[I] := OClientItem2;
        end;
      end;
      m_DefMsg := MakeDefaultMsg(SM_SENDUSERSTATE, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, EncodeBuffer(@OUserState2,
        SizeOf(TOUserStateInfo2)));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientQueryUserState');
  end;
end;

procedure TPlayObject.ClientMerchantDlgSelect(nParam1: Integer; sMsg: string);
//004DBAA4
var
  Npc: TNormNpc;
begin
  try

    Npc := UserEngine.FindMerchant(TObject(nParam1));
    if Npc = nil then
      Npc := UserEngine.FindNPC(TObject(nParam1));
    if Npc = nil then
      exit;
    if m_boGhost then
      exit;
    if ((Npc.m_PEnvir = m_PEnvir) and
      (abs(Npc.m_nCurrX - m_nCurrX) < 15) and
      (abs(Npc.m_nCurrY - m_nCurrY) < 15)) or (Npc.m_boIsHide) then
      Npc.UserSelect(Self, Trim(sMsg));

  except
    MainOutMessage('[Exception] TPlayObject.ClientMerchantDlgSelect');
  end;
end;

procedure TPlayObject.ClientMerchantQuerySellPrice(nParam1, nMakeIndex: Integer;
  sMsg: string); //004DBB7C
var
  I: Integer;
  UserItem: pTUserItem;
  UserItem18: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  try
    UserItem18 := nil;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = nMakeIndex then
      begin
        //取自定义物品名称
        sUserItemName := GetItemName(UserItem);

        if CompareText(sUserItemName, sMsg) = 0 then
        begin
          UserItem18 := UserItem;
          break;
        end;
      end;
    end; // for
    if UserItem18 = nil then
      exit;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if Merchant = nil then
      exit;
    if ((Merchant.m_PEnvir = m_PEnvir) and
      (Merchant.m_boSell) and
      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
      Merchant.ClientQuerySellPrice(Self, UserItem18);

  except
    MainOutMessage('[Exception] TPlayObject.ClientMerchantQuerySellPrice');
  end;
end;

procedure TPlayObject.ClientUserSellItem(nParam1, nMakeIndex: Integer; sMsg:
  string); //004DBE1C
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  Item: TItem;
begin
  try
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nMakeIndex) then
      begin
        if CheckItemState(UserItem, ITEMSTATE_SELL, True) then
        begin
          SendMsg(Self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
          exit;
        end;
        Item := UserEngine.GetStdItem(UserItem.wIndex);
        if (Item <> nil) and (Item.nRule[RULE_SELL]) then
        begin
          SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
            '此物品禁止出售！！');
          SendMsg(Self, RM_USERSELLITEM_FAIL, 0, 0, 0, 0, '');
          exit;
        end;
        //取自定义物品名称
        sUserItemName := GetItemName(UserItem);

        if CompareText(sUserItemName, sMsg) = 0 then
        begin
          Merchant := UserEngine.FindMerchant(TObject(nParam1));
          if (Merchant <> nil) and
            (Merchant.m_boSell) and
            ((Merchant.m_PEnvir = m_PEnvir) and
            (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
            (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
          begin
            if Merchant.ClientSellItem(Self, UserItem) then
            begin
              if UserItem.btValue[13] = 1 then
              begin
                ItemUnit.DelCustomItemName(UserItem.MakeIndex, UserItem.wIndex);
                UserItem.btValue[13] := 0;
              end;
              //Dispose(UserItem); //物品加到NPC物品列表中了  Jason
              m_ItemList.Delete(I);
              WeightChanged();
            end;
          end;
          break;
        end;
      end;
    end; // for
  except
    MainOutMessage('[Exception] TPlayObject.ClientUserSellItem');
  end;
end;

procedure TPlayObject.ClientUserBuyItem(nIdent, nParam1, nInt, nZz: Integer;
  sMsg: string); //004DCA10
var
  Merchant: TMerchant;
begin
  try
    try
      if m_boDealing then
        exit;
      Merchant := UserEngine.FindMerchant(TObject(nParam1));
      if (Merchant = nil) or
        (not Merchant.m_bobuy) or
        (Merchant.m_PEnvir <> m_PEnvir) or
        (abs(Merchant.m_nCurrX - m_nCurrX) > 15) or
        (abs(Merchant.m_nCurrY - m_nCurrY) > 15) then
        exit;

      if nIdent = CM_USERBUYITEM then
      begin
        Merchant.ClientBuyItem(Self, sMsg, nInt);
      end;
      if nIdent = CM_USERGETDETAILITEM then
      begin
        Merchant.ClientGetDetailGoodsList(Self, sMsg, nZz);
      end;
    except
      on e: Exception do
      begin
        MainOutMessage('TUserHumah.ClientUserBuyItem wIdent = ' +
          IntToStr(nIdent));
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientUserBuyItem');
  end;
end;

function TPlayObject.ClientDropGold(nGold: Integer): Boolean; //004C5BB0
begin
  try
    Result := False;
    if g_Config.boInSafeDisableDrop and InSafeZone then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sCanotDropInSafeZoneMsg);
      exit;
    end;

    if g_Config.boControlDropItem and (nGold < g_Config.nCanDropGold) then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sCanotDropGoldMsg);
      exit;
    end;

    if not m_boCanDrop or m_PEnvir.Flag.boNOTHROWITEM then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sCanotDropItemMsg);
      exit;
    end;
    if nGold >= m_nGold then
      exit;
    Dec(m_nGold, nGold);
    if not DropGoldDown(nGold, False, nil, Self) then
      Inc(m_nGold, nGold);
    GoldChanged();
    Result := True;
  except
    MainOutMessage('[Exception] TPlayObject.ClientDropGold');
  end;
end;

function TPlayObject.ClientDropItem(sItemName: string; //004C5A2C
  nItemIdx: Integer): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
  StdItem: TItem;
  sUserItemName: string;
begin
  try
    Result := False;
    try
      if Assigned(m_CheckClientDropItem) then
        if not m_CheckClientDropItem(Self, PChar(sItemName)) then
          exit;
    except
      MainOutMessage('[Exception] TPlayObject.ClientDropItem->HookApi');
    end;
    if g_Config.boJsCheckFail then
    begin
      if m_nStep = 8 then
        Inc(m_nStep)
      else
        m_nStep := 0;
    end;
    if g_Config.boInSafeDisableDrop and InSafeZone then
    begin
      if (m_HeroHuman <> nil) and (m_boHero) then
        m_HeroHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sCanotDropInSafeZoneMsg)
      else
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sCanotDropInSafeZoneMsg);
      exit;
    end;

    if not m_boCanDrop or m_PEnvir.Flag.boNOTHROWITEM then
    begin
      if (m_HeroHuman <> nil) and (m_boHero) then
        m_HeroHuman.SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sCanotDropItemMsg)
      else
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sCanotDropItemMsg);
      exit;
    end;

    if Pos(' ', sItemName) > 0 then
    begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    if (GetTickCount - m_DealLastTick) > 3000 then
    begin
      for I := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList.Items[i];
        if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
        begin
          if CheckItemState(UserItem, ITEMSTATE_DROP, True) then
            exit;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem = nil then
            Continue;
          if StdItem.nRule[RULE_DROPDOWN] then
          begin
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
              '此物品禁止扔掉！！');
            break;
          end;
          //取自定义物品名称
          sUserItemName := GetItemName(UserItem);
          ;

          if CompareText(sUserItemName, sItemName) = 0 then
          begin
            if g_Config.boControlDropItem and (StdItem.Price <
              LongWord(g_Config.nCanDropPrice)) then
            begin
              Dispose(UserItem);
              m_ItemList.Delete(i);
              Result := True;
              //m_ServerStrVal[2]:=StdItem.Name;
              //NpcGotoLable(g_FunctionNPC,'@DropItem',False);
              break;
            end;
            if DropItemDown(UserItem, 1, False, nil, Self, False) then
            begin
              Dispose(UserItem);
              m_ItemList.Delete(i);
              Result := True;
              if StdItem.nRule[RULE_MAKE] then
              begin
                m_ServerStrVal[2] := StdItem.Name;
                NpcGotoLable(g_FunctionNPC, '@DropItem', False);
              end;
              MapEventCheck(OS_DROPITEM, StdItem.Name); //地图事件触发
              break;
            end;
          end; //004C5B53
        end;
      end;
      if Result then
        WeightChanged();
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientDropItem');
  end;
end;

procedure TPlayObject.GoldChange(sChrName: string; nGold: Integer); //004CD844
var
  s10, s14: string;
begin
  try
    if nGold > 0 then
    begin
      s10 := '14';
      s14 := '增加';
    end
    else
    begin
      s10 := '13';
      s14 := '减少';
    end;
    SysMsg(sChrName + ' 的金币 ' + IntToStr(nGold) + ' 金币' + s14,
      c_Green, t_Hint);
    //004CD97C
    if g_boGameLogGold then
      AddGameDataLog(s10 + #9 +
        m_sMapName + #9 +
        IntToStr(m_nCurrX) + #9 +
        IntToStr(m_nCurrY) + #9 +
        m_sCharName + #9 +
        sSTRING_GOLDNAME + #9 +
        IntToStr(nGold) + #9 +
        '1' + #9 +
        sChrName);
  except
    MainOutMessage('[Exception] TPlayObject.GoldChange');
  end;
end;

//004D6758

//004C9C08

procedure TPlayObject.ClearStatusTime;
begin
  try
    FillChar(m_wStatusTimeArr, SizeOf(TStatusTime), #0);
  except
    MainOutMessage('[Exception] TPlayObject.ClearStatusTime');
  end;
end;

procedure TPlayObject.SendMapDescription;
var
  nMUSICID: Integer;
begin
  try
    nMUSICID := -1;
    //if m_PEnvir.Flag.boMUSIC then nMUSICID:=m_PEnvir.Flag.nMUSICID;

    SendDefMessage(SM_MAPDESCRIPTION, nMUSICID, 0, 0, 0, m_PEnvir.sMapDesc);
    if m_PEnvir.Flag.sMusic <> '' then
      SendDefMessage(SM_MUSIC, 0, 0, 0, 0, m_PEnvir.Flag.sMusic);
  except
    MainOutMessage('[Exception] TPlayObject.SendMapDescription');
  end;
end;

procedure TPlayObject.SendNotice; //004DA490
var
  LoadList: TStringList;
  i: integer;
  sNoticeMsg: string;
begin
  try
    LoadList := TStringList.Create;
    NoticeManager.GetNoticeMsg('Notice', LoadList);
    sNoticeMsg := '';
    for I := 0 to LoadList.Count - 1 do
    begin
      sNoticeMsg := sNoticeMsg + LoadList.Strings[i] + #$20#$1B;
    end;
    LoadList.Free;
    //{$IF SOFTNEWVER = VERBLUEYUE}
      //SendDefMessage(SM_SENDNOTICE,1,0,0,0,sNoticeMsg);
    //{$ELSE}
    SendDefMessage(SM_SENDNOTICE, g_Config.nDemoVerIdx, g_Config.nDemoVerIdx,
      g_Config.nDemoVerIdx, g_Config.nDemoVerIdx, sNoticeMsg);
    //{$IFEND}

      //SendDefMessage(SM_SENDNOTICE,2000,0,0,0,sNoticeMsg);
  except
    MainOutMessage('[Exception] TPlayObject.SendNotice');
  end;
end;

//英雄人物首次登录处理
procedure TPlayObject.HeroLogon();
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::HeroLogon';
  sDelItems = '删除复制品 [%s]%d %s';
var
  I: Integer;
  II: Integer;
  UserItem: PTUserItem;
  UserItem1: PTUserItem;
  StdItem: TItem;
  s14: string;
  sItem: string;
  //  sIPaddr    :String;
  n1C, n20, n24: Integer;
  p28: Pointer;
  boDel: Boolean;
begin
  try
    try
      if g_Config.boTestServer then
      begin
        if m_Abil.Level < g_Config.nTestHeroLevel then
          m_Abil.Level := g_Config.nTestHeroLevel;
        if m_nGold < g_Config.nTestGold then
          m_nGold := g_Config.nTestGold;
      end; //004C9C99
      if g_Config.boTestServer or (g_Config.boServiceMode) then
        m_nPayMent := 3;
      m_dwMapMoveTick := GetTickCount();
      m_dLogonTime := Now();
      m_dwLogonTick := GetTickCount();
      m_boFixedHideMode := False;
      Initialize;
      if m_boAddtoMapSuccess then
      begin
        p28 := nil;
        if m_PEnvir.Header.wWidth < 50 then
          n20 := 2
        else
          n20 := 3;
        if (m_PEnvir.Header.wHeight < 250) then
        begin
          if (m_PEnvir.Header.wHeight < 30) then
            n24 := 2
          else
            n24 := 20;
        end
        else
          n24 := 50;

        n1C := 0;
        while (True) do
        begin
          if not m_PEnvir.CanWalk(m_nCurrX, m_nCurrY, False) then
          begin
            if (m_PEnvir.Header.wWidth - n24 - 1) > m_nCurrX then
            begin
              Inc(m_nCurrX, n20);
            end
            else
            begin //004ADD9D
              m_nCurrX := Random(m_PEnvir.Header.wWidth div 2) + n24;
              if m_PEnvir.Header.wHeight - n24 - 1 > m_nCurrY then
              begin
                Inc(m_nCurrY, n20);
              end
              else
              begin //004ADDBE
                m_nCurrY := Random(m_PEnvir.Header.wHeight div 2) + n24;
              end;
            end;
          end
          else
          begin //004ADDC0
            p28 := m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
            break;
          end;
          Inc(n1C);
          if n1C >= 31 then
            break;
        end;

        if p28 = nil then
        begin
          //      m_PEnvir.DelObjectCount2(Self);
          m_HeroHuman.SysMsg('召唤失败，请找一处空白地点再进行召唤!!', c_Blue, t_Hint);
          MakeGhost;
          Exit;
        end;
      end;
      m_HeroHuman.SendRefMsg(RM_HEROLOGINHALO, 0, m_nCurrX, m_nCurrY,
        m_btDirection, '');
      //新人物给出物品
      if m_boNewHuman then
      begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sCandle, UserItem) then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sBasicDrug, UserItem) then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword, UserItem)
          then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);

        New(UserItem);
        if m_btGender = gMan then
          sItem := g_Config.sClothsMan
        else
          sItem := g_Config.sClothsWoman;

        if UserEngine.CopyToUserItemFromName(sItem, UserItem) then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);
      end; //004C9F44

      //检查背包中的物品是否合法

      for I := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[I];
        if UserEngine.GetStdItemName(UserItem.wIndex) = '' then
        begin
          Dispose(UserItem);
          m_ItemList.Delete(I);
        end;
      end;
      //004C9FB8

      //004C9FBD
      //检查人物身上的物品是否符合使用规则
      if g_Config.boCheckUserItemPlace then
      begin
        for I := Low(THumanUseItems) to High(THumanUseItems) do
        begin
          if m_UseItems[I].wIndex > 0 then
          begin
            StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
            if StdItem <> nil then
            begin
              if not CheckUserItems(I, StdItem) then
              begin
                New(UserItem);
                UserItem^ := m_UseItems[I];
                if not AddItemToBag(UserItem) then
                begin
                  m_ItemList.Insert(0, UserItem);
                end;
                m_UseItems[I].wIndex := 0;
              end;
            end
            else
              m_UseItems[I].wIndex := 0;
          end;
        end; //004CA06D
      end;

      //检查背包中是否有复制品
      //Jason 071122重新修正检查复制品
      while True do
      begin
        boDel := False;
        for I := m_ItemList.Count - 1 downto 0 do
        begin
          boDel := False;
          UserItem := m_ItemList.Items[I];
          s14 := UserEngine.GetStdItemName(UserItem.wIndex);
          for ii := I - 1 downto 0 do
          begin
            UserItem1 := m_ItemList.Items[ii];
            if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
              (UserItem.MakeIndex = UserItem1.MakeIndex) then
            begin
              MainOutMessage(Format(sDelItems, [s14, UserItem1.MakeIndex,
                m_sCharName]));
              Dispose(UserItem1); //Jason 0714
              m_ItemList.Delete(ii);
              boDel := True;
            end;
          end;
          if boDel then
            break;
        end;
        if not boDel then
          break;
      end;

      if m_nGloryPoint > 10000 then
        m_nGloryPoint := 10000;

      { for I := m_ItemList.Count - 1 downto 0 do begin
         UserItem:=m_ItemList.Items[I];
         s14:=UserEngine.GetStdItemName(UserItem.wIndex);
         for ii:=I -1 downto 0 do begin
           UserItem1:=m_ItemList.Items[ii];
           if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
              (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
             MainOutMessage(Format(sDelItems,[s14,UserItem1.MakeIndex,m_sCharName]));
             Dispose(UserItem1);    //Jason 0714
             m_ItemList.Delete(ii);
             break;
           end;
         end;
       end; }
      if (m_nGloryPoint >= g_Config.nHeroFourMagic) then
        m_boHeroFourMagic := True;
      m_nCharStatus := GetCharStatus();
      m_Abil.MaxExp := GetLevelExp(m_Abil.Level);

       //酒馆数据设置
     if m_Winerec.WineValue<g_Config.nMaxAlcoholValue then
         m_Winerec.WineValue:=g_Config.nMaxAlcoholValue;//酒量上限初始值
     if m_WineRec.Alcoho>m_WineRec.WineValue then
        m_WineRec.Alcoho:=m_WineRec.WineValue;//饮酒量大于酒量的等于酒量值

    // if m_MedicineRec.MedicineLevel<=0 then
    //     m_MedicineRec.MedicineLevel:=1; //药力等级初始值

      m_MedicineRec.MaxMedicineValue:=GetMedicineLevelExp(m_MedicineRec.MedicineLevel);//药力值升级值
      m_SKILL84Rec.MaxSKILL84Exp:=Getskill84LevelExp(m_SKILL84Rec.SKILL84Level);//酒气护身升级经验
      if (m_WineRec.Alcoho>0) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)>=g_Config.nRUNKValue) then
       begin
         m_RUNKarray[0]:=1;
         m_RUNKarray[1]:=1;
         m_boRUNK:=True; //达到醉酒标准
       end;
    // if  m_WineRec.Alcoho>0 then
      GetSkill83LevelAbil();//重新计算先天元力等级
      RecalcHeroBagCount();
      RecalcLevelAbilitys();
      RecalcAbilitys();
      RefNameColor();
      SendMsg(Self, RM_HEROLOGIN, 0, 0, 0, 0, '');
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');

      SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
      SendMsg(Self, RM_MedicineValue, 0,0, 0,0,'');
      SendMsg(Self, RM_SKILL83Value, 0,0, 0,0,'');      
     if m_MagicSkill84<>nil then //酒气护体
        SendMsg(Self, RM_SKILL84Exp, 0,0, 0,0,'');
      SendMsg(Self, RM_bLiquorProgress, 0,0, 0,0,'');

      SendMsg(Self, RM_HEROLOGINEX, 0, 0, 0, 0, '');
      SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
      //m_dwAttackTick := GetTickCount() + 5000;
      //m_dwMoveTick   := GetTickCount() + 5000;
      //m_wStatusTimeArr[POISON_STONE]:=3;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg);
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroLogon');
  end;
end;

procedure TPlayObject.UserOffLineLogon();
var
  I: integer;
begin
  try
    //MainOutMessage(Self.m_sCharName) ;
    m_boReconnection := False;
    m_VisibleHumanList.Clear;
    for I := Low(m_ShopSend) to High(m_ShopSend) do
      m_ShopSend[I] := False;
    for I := 0 to m_VisibleItems.Count - 1 do
    begin
      Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
    end;
    m_VisibleItems.Clear;
    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
    end;
    m_VisibleActors.Clear;
    m_VisibleEvents.Clear; //01/21 移动时清除列表
    SendMsg(Self, RM_LOGON, 0, 0, 0, 0, '');
    if not bo6AB then
    begin
      if (m_dwClientTickEx < LongWord(g_Config.nSoftVersionDate)) and
        g_Config.boCanJSClientLogon then
      begin
        SysMsg(sClientSoftVersionError, c_Red, t_Hint);
        SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
        SysMsg(sForceDisConnect, c_Red, t_Hint);
        m_boEmergencyClose := True;
        exit;
      end
      else if (m_dwClientTickEx = 0) and g_Config.boOldClientShowHiLevel2 then
      begin
        SysMsg(sClientSoftVersionTooOld, c_Blue, t_Hint);
        SysMsg(sDownLoadAndUseNewClient, c_Red, t_Hint);
        if (not g_Config.boCanOldClientLogon) then
        begin
          SysMsg(sClientSoftVersionError, c_Red, t_Hint);
          SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          exit;
        end;
      end;

      //攻击模式
      if m_dwClientTickEx > 20070801 then
      begin
        case m_btAttatckMode of
          HAM_ALL: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[全体攻击模式]'); //[攻击模式: 全体攻击]
          HAM_PEACE: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[和平攻击模式]'); //[攻击模式: 和平攻击]
          HAM_DEAR: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[夫妻攻击模式]'); //[攻击模式: 夫妻攻击]
          HAM_MASTER: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[师徒攻击模式]'); //[攻击模式: 师徒攻击]
          HAM_GROUP: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[编组攻击模式]'); //[攻击模式: 编组攻击]
          HAM_GUILD: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[行会攻击模式]'); //[攻击模式: 行会攻击]
          HAM_PKATTACK: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
              '[红名攻击模式]'); //[攻击模式: 红名攻击]
        end;
      end
      else
      begin
        case m_btAttatckMode of
          HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint);
          //[攻击模式: 全体攻击]
          HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint);
          //[攻击模式: 和平攻击]
          HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint);
          //[攻击模式: 夫妻攻击]
          HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint);
          //[攻击模式: 师徒攻击]
          HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint);
          //[攻击模式: 编组攻击]
          HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint);
          //[攻击模式: 行会攻击]
          HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint);
          //[攻击模式: 红名攻击]
        end;
      end;
      SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint);
      //使用组合快捷键 CTRL-H 更改攻击...
      if g_Config.boTestServer then
        SysMsg(sStartNoticeMsg, c_Green, t_Hint);
      //欢迎进入本服务器进行游戏...
      if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then
      begin
        if m_btPermission < 2 then
        begin
          SysMsg(sOnlineUserFull, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
        end;
      end;

      //004CA344

    end; //if not bo6AB
    m_dwSafeOffLine := 0; //清除挂机时间
    m_nOffLineAddExp := 0;
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
    SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
    //  FeatureChanged(); //增加，广播人物骑马信息
    m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
    if m_MyGuild <> nil then
    begin
      m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
      for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do
      begin
        SysMsg(TGuild(m_MyGuild).GuildWarList.Strings[i] +
          ' 正与你们行会发生战争.', c_Green, t_Hint);
      end;
    end;
    RefShowName();
    if (m_nPayMent = 1) then
    begin
      if not bo6AB then
        SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
      //    m_nGoldMax:=100000;
      m_nGoldMax := g_Config.nHumanTryModeMaxGold;
      if m_Abil.Level > g_Config.nTryModeLevel then
      begin
        SysMsg('测试状态可以使用到第 ' +
          IntToStr(g_Config.nTryModeLevel) + ' 级。', c_Red, t_Hint);
        SysMsg('链接中断，请到以下地址获得收费相关信息。(http://www.51m2.com)', c_Red, t_Hint);
        m_boEmergencyClose := True;
      end;
    end; //004CA4FA
    if (m_nPayMent = 3) and not bo6AB then
      SysMsg(g_sNowIsFreePlayMode {'当前服务器运行于测试模式.'},
        c_Green, t_Hint);

    if g_Config.boVentureServer then
      SysMsg('欢迎进行冒险服务器.', c_Green, t_Hint);
    if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting) then
    begin
      m_boUseThrusting := True;
      SendSocket(nil, '+LNG');
    end;
    NpcGotoLable(g_ManageNPC, '@Resume', False);
    {if g_ManageNPC <> nil then begin
      g_ManageNPC.GotoLable(Self,'@Resume',False);    //登陆执行@Login项
    end;}

    m_boFixedHideMode := False; //01/21 增加
    // PlayObject.Create 过程里被置为True，在执行完登录脚本后再置False
//m_boFilterSendMsg:=GetDisableSendMsgList(m_sCharName);

    if m_Hero <> nil then
    begin
      m_Hero.SendDelayMsg(m_Hero, RM_HEROLOGIN, 0, 0, 0, 0, '', 3000);
      m_Hero.SendDelayMsg(m_Hero, RM_ABILITY, 0, 0, 0, 0, '', 3000);
      m_Hero.SendDelayMsg(m_Hero, RM_SUBABILITY, 0, 0, 0, 0, '', 3000);
      m_Hero.SendDelayMsg(m_Hero, RM_HEROLOGINEX, 0, 0, 0, 0, '', 3000);
      m_Hero.SendDelayMsg(m_Hero, RM_SENDMYMAGIC, 0, 0, 0, 0, '', 3000);
    end;
    if m_boShop then
      SendMsg(Self, RM_SELFSHOPLIST, 0, 0, 0, 0, '');
    (*{$IF IFOPENAD = OPENAD}
      if m_dwClientTickEx > 20070801 then begin
        SendDefMessage(SM_SELFONE,0,0,0,0,'私服，美女，电影，想看吗？ 来 92sf.com(就要舒服)');
        SendDefMessage(SM_SELFTWO,0,0,0,0,'http://www.js991.com');
        SendDefMessage(SM_SELFWEB,0,0,0,0,'最新私服大全|http://www.js991.com');
        SendDefMessage(SM_SELFTOP,0,MakeWord(252,0),0,0,'找私服，请到Http://www.92sf.com，有你想要的！');
      end;
    {$IFEND}  *)

  except
    MainOutMessage('[Exception] TPlayObject.UserOffLineLogon');
  end;
end;

//游戏人物首次登录处理
procedure TPlayObject.UserLogon; //004C9C24
var
  I: Integer;
  II: Integer;
  UserItem: PTUserItem;
  UserItem1: PTUserItem;
  StdItem: TItem;
  s14: string;
  sItem: string;
  sIPaddr: string;
  boDel: Boolean;
  Envir: TEnvirnoment;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::UserLogon';
  sCheckIPaddrFail = 'GM IP validation failed...';
  sDelItems = '删除复制品 [%s]%d %s';
begin
  try
    sIPaddr := '127.0.0.1';
    try
      try
        if Assigned(m_HookUserLogin1) then
          m_HookUserLogin1(Self);
      except
        MainOutMessage('[Exception] TPlayObject.UserLogon->HookApi 1');
      end;
      if g_Config.boTestServer then
      begin
        if m_Abil.Level < g_Config.nTestLevel then
          m_Abil.Level := g_Config.nTestLevel;
        if m_nGold < g_Config.nTestGold then
          m_nGold := g_Config.nTestGold;
      end; //004C9C99
      if g_Config.boTestServer or (g_Config.boServiceMode) then
        m_nPayMent := 3;
      m_dwMapMoveTick := GetTickCount();
      m_dLogonTime := Now();
      m_dwLogonTick := GetTickCount();
      m_dwSafeOffLine := 0; //清除挂机时间
      m_nOffLineAddExp := 0;
      Initialize(); //004C9CE8
      try
        if Assigned(m_HookUserLogin2) then
          m_HookUserLogin2(Self);
      except
        MainOutMessage('[Exception] TPlayObject.UserLogon->HookApi 2');
      end;
      SendMsg(Self, RM_LOGON, 0, 0, 0, 0, '');
      if m_Abil.Level <= 7 then
      begin
        if GetRangeHumanCount >= 80 then
        begin
          MapRandomMove(m_PEnvir.sMapName, 0);
        end;
      end; //004C9D32

      if m_boDieInFight3Zone then
      begin
        MapRandomMove(m_PEnvir.sMapName, 0);
      end;

      Envir := g_MapManager.FindMap(m_sDieMap);
      if Envir <> nil then
      if Envir.Flag.boFIGHT4 then //在挑战地图死亡的
      begin
       m_WAbil.HP:=m_WAbil.MaxHP;
       m_WAbil.MP:=m_WAbil.MaxMP
      end;

      //取得用户权限
      if UserEngine.GetHumPermission(m_sCharName, sIPaddr, m_btPermission) then
      begin
{$IF GMCHECKIP = CHECKGMIP}
        if not CompareIPaddr(m_sIPaddr, sIPaddr) then
        begin
          SysMsg(sCheckIPaddrFail, c_Red, t_Hint);
          m_boEmergencyClose := True;
        end;
{$IFEND}
      end;

      GetHomePoint();

      for i := 0 to m_MagicList.Count - 1 do
      begin
        sub_4C713C(pTUserMagic(m_MagicList.Items[i]));
      end;

      //如果为新人，给出新人物品
      if m_boNewHuman then
      begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sCandle, UserItem) then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sBasicDrug, UserItem) then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sWoodenSword, UserItem)
          then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);

        New(UserItem);
        if m_btGender = gMan then
          sItem := g_Config.sClothsMan
        else
          sItem := g_Config.sClothsWoman;

        if UserEngine.CopyToUserItemFromName(sItem, UserItem) then
        begin
          m_ItemList.Add(UserItem);
        end
        else
          Dispose(UserItem);

      end; //004C9F44

      //检查背包中的物品是否合法

      for I := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[I];
        if UserEngine.GetStdItemName(UserItem.wIndex) = '' then
        begin
          Dispose(UserItem);
          m_ItemList.Delete(I);
        end;
      end;
      //004C9FB8

      //004C9FBD
      //检查人物身上的物品是否符合使用规则
      if g_Config.boCheckUserItemPlace then
      begin
        for I := Low(THumanUseItems) to High(THumanUseItems) do
        begin
          if m_UseItems[I].wIndex > 0 then
          begin
            StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
            if StdItem <> nil then
            begin
              if not CheckUserItems(I, StdItem) then
              begin
                New(UserItem);
                UserItem^ := m_UseItems[I];
                if not AddItemToBag(UserItem) then
                begin
                  m_ItemList.Insert(0, UserItem);
                end;
                m_UseItems[I].wIndex := 0;
              end;
            end
            else
              m_UseItems[I].wIndex := 0;
          end;
        end; //004CA06D
      end;

      //检查背包中是否有复制品
      //Jason 071122重新修正检查复制品
      while True do
      begin
        boDel := False;
        for I := m_ItemList.Count - 1 downto 0 do
        begin
          boDel := False;
          UserItem := m_ItemList.Items[I];
          s14 := UserEngine.GetStdItemName(UserItem.wIndex);
          for ii := I - 1 downto 0 do
          begin
            UserItem1 := m_ItemList.Items[ii];
            if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
              (UserItem.MakeIndex = UserItem1.MakeIndex) then
            begin
              MainOutMessage(Format(sDelItems, [s14, UserItem1.MakeIndex,
                m_sCharName]));
              Dispose(UserItem1); //Jason 0714
              m_ItemList.Delete(ii);
              boDel := True;
            end;
          end;
          if boDel then
            break;
        end;
        if not boDel then
          break;
      end;

      //检查背包中是否有复制品
      {for I := m_ItemList.Count - 1 downto 0 do begin
        UserItem:=m_ItemList.Items[I];
        s14:=UserEngine.GetStdItemName(UserItem.wIndex);
        for ii:=I -1 downto 0 do begin
          UserItem1:=m_ItemList.Items[ii];
          if (UserEngine.GetStdItemName(UserItem1.wIndex) = s14) and
             (UserItem.MakeIndex = UserItem1.MakeIndex) then begin
            MainOutMessage(Format(sDelItems,[s14,UserItem1.MakeIndex,m_sCharName]));
            Dispose(UserItem1);    //Jason 0714
            m_ItemList.Delete(ii);
            break;
          end;
        end;
      end;  }

 //酒馆数据设置
     if m_Winerec.WineValue<g_Config.nMaxAlcoholValue then
         m_Winerec.WineValue:=g_Config.nMaxAlcoholValue;//酒量上限初始值
     if m_WineRec.Alcoho>m_WineRec.WineValue then
        m_WineRec.Alcoho:=m_WineRec.WineValue;//饮酒量大于酒量的等于酒量值

    // if m_MedicineRec.MedicineLevel<=0 then
    //     m_MedicineRec.MedicineLevel:=1; //药力等级初始值

      m_MedicineRec.MaxMedicineValue:=GetMedicineLevelExp(m_MedicineRec.MedicineLevel);//药力值升级值
      m_SKILL84Rec.MaxSKILL84Exp:=Getskill84LevelExp(m_SKILL84Rec.SKILL84Level);//酒气护身升级经验
      if (m_WineRec.Alcoho>0) and ((m_WineRec.Alcoho / m_WineRec.WineValue*100)>=g_Config.nRUNKValue) then
       begin
         m_RUNKarray[0]:=1;
         m_RUNKarray[1]:=1;
         m_boRUNK:=True; //达到醉酒标准
       end;

  //   if  m_WineRec.Alcoho>0 then
      GetSkill83LevelAbil();//重新计算先天元力等级
      
      //检测人物副加属性
      for i := Low(m_dwStatusArrTick) to High(m_dwStatusArrTick) do
      begin
        if m_wStatusTimeArr[i] > 0 then
          m_dwStatusArrTick[i] := GetTickCount();
      end;
      //004CA177
      m_nCharStatus := GetCharStatus();
      RecalcLevelAbilitys();
      RecalcAbilitys();
      m_Abil.MaxExp := GetLevelExp(m_Abil.Level);
      if btB22 = 0 then
      begin
        m_nPkPoint := 0;
        Inc(btB22);
      end;

      //检测人物金币是否大于指定数
      if (m_nGold > g_Config.nHumanMaxGold * 2) and (g_Config.nHumanMaxGold > 0)
        then
        m_nGold := g_Config.nHumanMaxGold * 2;

      //检测版本并发送信息
      if not bo6AB then
      begin
        if (m_dwClientTickEx < LongWord(g_Config.nSoftVersionDate)) and
          g_Config.boCanJSClientLogon then
        begin
          SysMsg(sClientSoftVersionError, c_Red, t_Hint);
          SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
          SysMsg(sForceDisConnect, c_Red, t_Hint);
          m_boEmergencyClose := True;
          exit;
        end
        else if (m_dwClientTickEx = 0) and g_Config.boOldClientShowHiLevel2 then
        begin
          SysMsg(sClientSoftVersionTooOld, c_Blue, t_Hint);
          SysMsg(sDownLoadAndUseNewClient, c_Red, t_Hint);
          if (not g_Config.boCanOldClientLogon) then
          begin
            SysMsg(sClientSoftVersionError, c_Red, t_Hint);
            SysMsg(sDownLoadNewClientSoft, c_Red, t_Hint);
            SysMsg(sForceDisConnect, c_Red, t_Hint);
            m_boEmergencyClose := True;
            exit;
          end;
        end;

        //攻击模式
        if m_dwClientTickEx > 20070801 then
        begin
          case m_btAttatckMode of
            HAM_ALL: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[全体攻击模式]'); //[攻击模式: 全体攻击]
            HAM_PEACE: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[和平攻击模式]'); //[攻击模式: 和平攻击]
            HAM_DEAR: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[夫妻攻击模式]'); //[攻击模式: 夫妻攻击]
            HAM_MASTER: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[师徒攻击模式]'); //[攻击模式: 师徒攻击]
            HAM_GROUP: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[编组攻击模式]'); //[攻击模式: 编组攻击]
            HAM_GUILD: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[行会攻击模式]'); //[攻击模式: 行会攻击]
            HAM_PKATTACK: SendDefMessage(SM_ATTACKMODE, 0, 0, 0, 0,
                '[红名攻击模式]'); //[攻击模式: 红名攻击]
          end;
        end
        else
        begin
          case m_btAttatckMode of
            HAM_ALL: SysMsg(sAttackModeOfAll, c_Green, t_Hint);
            //[攻击模式: 全体攻击]
            HAM_PEACE: SysMsg(sAttackModeOfPeaceful, c_Green, t_Hint);
            //[攻击模式: 和平攻击]
            HAM_DEAR: SysMsg(sAttackModeOfDear, c_Green, t_Hint);
            //[攻击模式: 夫妻攻击]
            HAM_MASTER: SysMsg(sAttackModeOfMaster, c_Green, t_Hint);
            //[攻击模式: 师徒攻击]
            HAM_GROUP: SysMsg(sAttackModeOfGroup, c_Green, t_Hint);
            //[攻击模式: 编组攻击]
            HAM_GUILD: SysMsg(sAttackModeOfGuild, c_Green, t_Hint);
            //[攻击模式: 行会攻击]
            HAM_PKATTACK: SysMsg(sAttackModeOfRedWhite, c_Green, t_Hint);
            //[攻击模式: 红名攻击]
          end;
        end;
        SysMsg(sStartChangeAttackModeHelp, c_Green, t_Hint);
        //使用组合快捷键 CTRL-H 更改攻击...
        if g_Config.boTestServer then
          SysMsg(sStartNoticeMsg, c_Green, t_Hint);
        //欢迎进入本服务器进行游戏...
        if UserEngine.PlayObjectCount > g_Config.nTestUserLimit then
        begin
          if m_btPermission < 2 then
          begin
            SysMsg(sOnlineUserFull, c_Red, t_Hint);
            SysMsg(sForceDisConnect, c_Red, t_Hint);
            m_boEmergencyClose := True;
          end;
        end;

        //004CA344

      end;
      m_btBright := g_nGameTime;
      m_Abil.MaxExp := GetLevelExp(m_Abil.Level);

      SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
      SendMsg(Self, RM_MedicineValue, 0,0, 0,0,'');
      SendMsg(Self, RM_SKILL83Value, 0,0, 0,0,'');
     if m_MagicSkill84<>nil then //酒气护体
        SendMsg(Self, RM_SKILL84Exp, 0,0, 0,0,'');
      SendMsg(Self, RM_bLiquorProgress, 0,0, 0,0,'');

      //jacky 2004/09/15 登录重新取得升级所需经验值

      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
      SendMsg(Self, RM_DAYCHANGING, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SENDUSEITEMS, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
      //  FeatureChanged(); //增加，广播人物骑马信息
      m_MyGuild := g_GuildManager.MemberOfGuild(m_sCharName);
      if m_MyGuild <> nil then
      begin
        m_sGuildRankName := TGuild(m_MyGuild).GetRankName(Self, m_nGuildRankNo);
        for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do
        begin
          SysMsg(TGuild(m_MyGuild).GuildWarList.Strings[i] +
            ' 正与你们行会发生战争.', c_Green, t_Hint);
        end;
      end;
      RefShowName();
      if (m_nPayMent = 1) then
      begin
        if not bo6AB then
          SysMsg(sYouNowIsTryPlayMode, c_Red, t_Hint);
        //    m_nGoldMax:=100000;
        m_nGoldMax := g_Config.nHumanTryModeMaxGold;
        if m_Abil.Level > g_Config.nTryModeLevel then
        begin
          SysMsg('测试状态可以使用到第 ' +
            IntToStr(g_Config.nTryModeLevel) + ' 级。', c_Red, t_Hint);
          SysMsg('链接中断，请到以下地址获得收费相关信息。(http://www.51m2.com)', c_Red, t_Hint);
          m_boEmergencyClose := True;
        end;
      end; //004CA4FA
      if (m_nPayMent = 3) and not bo6AB then
        SysMsg(g_sNowIsFreePlayMode {'当前服务器运行于测试模式.'},
          c_Green, t_Hint);

      if g_Config.boVentureServer then
        SysMsg('欢迎进行冒险服务器.', c_Green, t_Hint);
      if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting) then
      begin
        m_boUseThrusting := True;
        SendSocket(nil, '+LNG');
      end;
      if m_PEnvir.Flag.boNORECONNECT then
        MapRandomMove(m_PEnvir.Flag.sNoReconnectMap, 0);

      if CheckDenyLogon() then
      begin
        m_boEmergencyClose := True;
        exit; //如果人物在禁止登录列表里则直接掉线而不执行下面内容
      end;

      try
        if Assigned(m_HookUserLogin3) then
          m_HookUserLogin3(Self);
      except
        MainOutMessage('[Exception] TPlayObject.UserLogon->HookApi 3');
      end;

      if m_dwKillMonExpRateTime > 0 then
        SysMsg(format(g_sChangeKillMonExpRateMsg, [m_nKillMonExpRate / 100,
          m_dwKillMonExpRateTime]), c_Green, t_Hint);

      try //取得在线最高等级、PK、攻击力、魔法、道术 的人物
        { if (g_HighLevelHuman = Self) and (m_boDeath or m_boGhost) then g_HighLevelHuman:=nil;
         if (g_HighPKPointHuman = Self) and (m_boDeath or m_boGhost) then g_HighPKPointHuman:=nil;
         if (g_HighDCHuman = Self) and (m_boDeath or m_boGhost) then g_HighDCHuman:=nil;
         if (g_HighMCHuman = Self) and (m_boDeath or m_boGhost) then g_HighMCHuman:=nil;
         if (g_HighSCHuman = Self) and (m_boDeath or m_boGhost) then g_HighSCHuman:=nil;
         if (g_HighOnlineHuman = Self) and (m_boDeath or m_boGhost) then g_HighOnlineHuman:=nil;  }

        if m_btPermission < 6 then
        begin
          //最高等级
          if (g_HighLevelHuman = nil) or
            (TPlayObject(g_HighLevelHuman).m_boGhost) then
          begin
            g_HighLevelHuman := Self;
          end
          else
          begin
            if m_Abil.Level > TPlayObject(g_HighLevelHuman).m_Abil.Level then
              g_HighLevelHuman := Self;
          end;

          //最高PK
          if (g_HighPKPointHuman = nil) or
            (TPlayObject(g_HighPKPointHuman).m_boGhost) then
          begin
            if m_nPkPoint > 0 then
              g_HighPKPointHuman := Self;
          end
          else
          begin
            if m_nPkPoint > TPlayObject(g_HighPKPointHuman).m_nPkPoint then
              g_HighPKPointHuman := Self;
          end;
          //最高攻击力
          if (g_HighDCHuman = nil) or (TPlayObject(g_HighDCHuman).m_boGhost)
            then
          begin
            g_HighDCHuman := Self;
          end
          else
          begin
            if HiWord(m_WAbil.DC) > HiWord(TPlayObject(g_HighDCHuman).m_WAbil.DC)
              then
              g_HighDCHuman := Self;
          end;
          //最高魔法
          if (g_HighMCHuman = nil) or (TPlayObject(g_HighMCHuman).m_boGhost)
            then
          begin
            g_HighMCHuman := Self;
          end
          else
          begin
            if HiWord(m_WAbil.MC) > HiWord(TPlayObject(g_HighMCHuman).m_WAbil.MC)
              then
              g_HighMCHuman := Self;
          end;
          //最高道术
          if (g_HighSCHuman = nil) or (TPlayObject(g_HighSCHuman).m_boGhost)
            then
          begin
            g_HighSCHuman := Self;
          end
          else
          begin
            if HiWord(m_WAbil.SC) > HiWord(TPlayObject(g_HighSCHuman).m_WAbil.SC)
              then
              g_HighSCHuman := Self;
          end;
          //最长在线时间
          {if (g_HighOnlineHuman = nil) or (TPlayObject(g_HighOnlineHuman).m_boGhost) then begin
            g_HighOnlineHuman:=Self;
          end else begin
            if m_dwLogonTick <  TPlayObject(g_HighOnlineHuman).m_dwLogonTick then
              g_HighOnlineHuman:=Self;
          end;}
        end;
      except
        on e: Exception do
        begin
          //MainOutMessage(sExceptionMsg3);
        end;
      end;
      NpcGotoLable(g_ManageNPC, '@Login', False);
      {if g_ManageNPC <> nil then begin
        g_ManageNPC.GotoLable(Self,'@Login',False);    //登陆执行@Login项
      end;}

      m_boFixedHideMode := False; //01/21 增加
      // PlayObject.Create 过程里被置为True，在执行完登录脚本后再置False

      if m_sDearName <> '' then
        CheckMarry();

      CheckMaster();

      m_boFilterSendMsg := GetDisableSendMsgList(m_sCharName);

      //密码保护系统
      if g_Config.boPasswordLockSystem then
      begin
        if m_boPasswordLocked then
        begin
          m_boCanGetBackItem := not g_Config.boLockGetBackItemAction;
        end;

        if g_Config.boLockHumanLogin and m_boLockLogon and m_boPasswordLocked
          then
        begin
          m_boCanDeal := not g_Config.boLockDealAction;
          m_boCanDrop := not g_Config.boLockDropAction;
          m_boCanUseItem := not g_Config.boLockUserItemAction;
          m_boCanWalk := not g_Config.boLockWalkAction;
          m_boCanRun := not g_Config.boLockRunAction;
          m_boCanHit := not g_Config.boLockHitAction;
          m_boCanSpell := not g_Config.boLockSpellAction;
          m_boCanSendMsg := not g_Config.boLockSendMsgAction;
          m_boObMode := g_Config.boLockInObModeAction;
          m_boAdminMode := g_Config.boLockInObModeAction;
{$IF VEROWNER = WL}
          SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' +
            g_GameCommand.LOCKLOGON.sCmd, c_Red, t_Hint);
          SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
            g_sActionIsLockedMsg + '\ \'
            + '密码命令: @' + g_GameCommand.PASSWORDLOCK.sCmd);
        end;
        if not m_boPasswordLocked then
        begin
          SysMsg(format(g_sPasswordNotSetMsg,
            [g_GameCommand.PASSWORDLOCK.sCmd]), c_Red, t_Hint);
        end;
        if not m_boLockLogon and m_boPasswordLocked then
        begin
          SysMsg(format(g_sNotPasswordProtectMode,
            [g_GameCommand.LOCKLOGON.sCmd]), c_Red, t_Hint);
        end;
{$ELSE}

        SysMsg(g_sActionIsLockedMsg + ' 开锁命令: @' +
          g_GameCommand.UNLOCK.sCmd, c_Red, t_Hint);
        SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
          g_sActionIsLockedMsg + '\ \'
          + '开锁命令: @' + g_GameCommand.UNLOCK.sCmd + '\'
          + '加锁命令: @' + g_GameCommand.LOCK.sCmd + '\'
          + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
          + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      end;

{$IFEND}

    end;

    {if g_nM2Crc <> nM2Crc then begin
      m_boEmergencyClose:=True;
    end;}

    {if UserEngine.PlayObjectCount > g_nMaxUserCount then begin
      if m_btPermission < 10 then begin
        SysMsg(sOnlineUserFull,c_Red,t_Hint);
        SysMsg(sForceDisConnect,c_Red,t_Hint);
        m_boEmergencyClose:=True;
      end;
    end;}
    //重置泡点方面计时
    m_dwIncGamePointTick := GetTickCount();
    m_dwIncGameGoldTick := GetTickCount();
    m_dwAutoGetExpTick := GetTickCount();
    if g_Config.boJsCheckFail then
      SysMsg(DecryStrHex('1FE5A4BDFEDF795775E997B92BC768AEAB02093DC9D7219A4E5A4B4F9EF17643159D6A86D715D5C6C0C9D5CBAB4708D7639AE55E7FF90CEA80B9FC9A6BBF1A36', sCHECK), c_Red, t_Hint);
    (*{$IF IFOPENAD = OPENAD}
      if m_dwClientTickEx > 20070801 then begin
        SendDefMessage(SM_SELFONE,0,0,0,0,'私服，美女，电影，想看吗？ 来 92sf.com(就要舒服)');
        SendDefMessage(SM_SELFTWO,0,0,0,0,'http://www.js991.com');
        SendDefMessage(SM_SELFWEB,0,0,0,0,'最新私服大全|http://www.js991.com');
        SendDefMessage(SM_SELFTOP,0,MakeWord(252,0),0,0,'找私服，请到Http://www.92sf.com，有你想要的！');
      end;
    {$IFEND}*)
    try
      if Assigned(m_HookUserLogin4) then
        m_HookUserLogin4(Self);
    except
      MainOutMessage('[Exception] TPlayObject.UserLogon->HookApi 4');
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);
    end;
  end;
  //ReadAllBook();
  except
  MainOutMessage('[Exception] TPlayObject.UserLogon');
end;
end;

procedure TPlayObject.SendWhisperMsg(PlayObject: TPlayObject);
var
  sMsg: string;
begin
  try
    if (PlayObject = Self) then
      exit;
    if g_SayMsgList.Count <= 0 then
      exit;
    if (PlayObject.m_btPermission >= 9) or (m_btPermission >= 9) then
      exit;
    if Random(5) > 0 then
      exit;
    if (GetTickCount - PlayObject.m_dwSendWhisperTime) <
      g_Config.dwSendWhisperTime then
      exit;
    PlayObject.m_dwSendWhisperTime := GetTickCount;
    Inc(PlayObject.m_nSendWhisperIdx);
    if g_SayMsgList.Count <= PlayObject.m_nSendWhisperIdx then
      PlayObject.m_nSendWhisperIdx := 0;

    sMsg := g_ManageNPC.GetLineVariableText(PlayObject,
      g_SayMsgList.Strings[PlayObject.m_nSendWhisperIdx]);

    case Random(2) of
      0:
        begin
          Whisper(PlayObject.m_sCharName, sMsg);
        end;
      1:
        begin
          SendRefMsg(RM_HEAR, 1, g_Config.btHearMsgFColor,
            g_Config.btHearMsgBColor, 0, m_sCharName + ':' + sMsg);
        end;
    end;
    //if UserEngine.PlayObjectCount < g_Config.nSendWhisperPlayCount + Random(5) then exit;

   (*
     m_dwSendWhisperTime       :LongWord;
      m_nSendWhisperIdx         :Byte;
   if GetStartPoint(StartPoint) then begin
      if GetTickCount - StartPoint.dwWhisperTick < g_Config.dwSendWhisperTime{5 * 60 * 1000} then exit;
      StartPoint.dwWhisperTick:=GetTickCount();
    end else begin
      if GetTickCount - m_PEnvir.m_dwWhisperTick < g_Config.dwSendWhisperTime{5 * 60 * 1000} then exit;
      m_PEnvir.m_dwWhisperTick:=GetTickCount();
    end;

    if g_SayMsgList.Count <= 0 then exit;
    Inc(g_nSayMsgIdx);
    if g_SayMsgList.Count <= g_nSayMsgIdx then g_nSayMsgIdx:=0;
    sMsg:=g_SayMsgList.Strings[g_nSayMsgIdx];

    case Random(2) of
      0: begin
        Whisper(PlayObject.m_sCharName,sMsg);
      end;
      1: begin
        SendRefMsg(RM_HEAR,1,g_Config.btHearMsgFColor,g_Config.btHearMsgBColor,0, m_sCharName + ':' + sMsg);
      end;
    end;  *)
  except
    MainOutMessage('[Exception] TPlayObject.SendWhisperMsg');
  end;
end;

procedure TPlayObject.SendGoldInfo(boSendName: Boolean);
var
  sMsg: string;
begin
  try
    if (m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) then
    begin
    end
    else
    begin
      //0521夜猫增加
     //if boSendName then
      sMsg := g_Config.sGameGoldName + #13 + g_Config.sGamePointName;
      if m_dwClientTickEx > 20071228 then
        sMsg := sMsg + #13 + g_Config.sGAMEDIAMONDname + #13 +
          g_Config.sGAMEGIRDname;
      SendDefMessage(SM_GOLDNAME,
        m_nGameGold,
        LoWord(m_nGamePoint),
        HiWord(m_nGamePoint),
        m_nGloryPoint,
        sMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendGoldInfo');
  end;
end;

procedure TPlayObject.SendOpenItem();
var
  mt_DefMsg:TDefaultMessage;
begin
  try
      mt_DefMsg := MakeDefaultMsg(SM_OpenItemArray,
        Length(UserEngine.g_OpenItemArray)*Sizeof(TOpenItem),
        Length(UserEngine.g_OpenItemArray),
        0,
        0);
      SendSocket(@mt_DefMsg,EncodeBuffer(@UserEngine.g_OpenItemArray[0],Length(UserEngine.g_OpenItemArray)*Sizeof(TOpenItem)));
  except
    MainOutMessage('[Exception] TPlayObject.SendOpenItem');
  end;
end;

procedure TPlayObject.SendLogon; //004D677C
var
  MessageBodyWL: TMessageBodyWL;
  nRecog: Integer;
begin
  try
    m_DefMsg := MakeDefaultMsg(SM_LOGON, Integer(Self), m_nCurrX, m_nCurrY,
      MakeWord(m_btDirection, m_nLight));
    MessageBodyWL.lParam1 := GetFeatureToLong();
    MessageBodyWL.lParam2 := m_nCharStatus;
    if m_boAllowGroup then
      MessageBodyWL.lTag1 := MakeLong(MakeWord(1, 0), GetFeatureEx)
    else
      MessageBodyWL.lTag1 := 0;
    MessageBodyWL.lTag2 := g_Config.btClientWgInfo;
    SendSocket(@m_DefMsg, EncodeBuffer(@MessageBodyWL, SizeOf(TMessageBodyWL)));

    nRecog := GetFeatureToLong();
    SendDefMessage(SM_FEATURECHANGED,
      Integer(Self),
      LoWord(nRecog),
      HiWord(nRecog),
      GetFeatureEx,
      '');
  except
    MainOutMessage('[Exception] TPlayObject.SendLogon');
  end;
end;

//发送经验显示模式消息
procedure TPlayObject.SendExpShowConfig();
begin
  try
    SendDefMessage(SM_ExpShowConfig,
      Integer(g_Config.boClientExpShowConfig),
      Word(g_Config.boBagShowItemDec),
      0,
      0,
      '');
  except
    MainOutMessage('[Exception] TPlayObject.SendExpShowConfig');
  end;
end;

procedure TPlayObject.SendServerConfig;
{var
  nRecog,nParam:Integer;
  nRunHuman,nRunMon,nRunNpc,nWarRunAll:Integer;
  ClientConf:TClientConf;
  sMsg:String; }
var
  sMsg: string;
  Old: Boolean;
begin
  try
    if m_dwClientTickEx < 20070915 then
      exit;
    g_Config.WgInfo.boRunHum := False;
    g_Config.WgInfo.boRunMon := False;
    g_Config.WgInfo.boRunNpc := False;
    //if g_Config.boDiableHumanRun or ((m_btPermission > 9) and g_Config.boGMRunAll) then begin
    g_Config.WgInfo.boRunHum := True;
    g_Config.WgInfo.boRunMon := True;
    g_Config.WgInfo.boRunNpc := True;
    g_Config.WgInfo.nFireHitSkillTime:=g_Config.nFireHitSkillTime;
    g_Config.WgInfo.nLongFireHitSkillTime:=g_Config.nLongFireHitSkillTime;
    g_Config.WgInfo.nHPUpUseTime:=g_Config.nHPUpUseTime;
    Old := g_Config.WgInfo.boForceNotViewFog;
    try
      if Old then
        g_Config.WgInfo.boForceNotViewFog := not m_PEnvir.Flag.boNight
      else
        g_Config.WgInfo.boForceNotViewFog := m_PEnvir.Flag.boNight;

      sMsg := EncodeBuffer(@g_Config.WgInfo, SizeOf(TClientWGInfo));
      m_DefMsg := MakeDefaultMsg(SM_SERVERCONFIG, 0,
        g_Config.nHeroEatingTime,
        g_Config.nAutoPuckUpItemTime,
        g_Config.nAspeederTime);
      SendSocket(@m_DefMsg, sMsg);
    finally
      g_Config.WgInfo.boForceNotViewFog := Old;
    end;

  except
    MainOutMessage('[Exception] TPlayObject.SendServerConfig');
  end;
end;

procedure TPlayObject.SendServerStatus;
begin
  try
    if m_btPermission < 10 then
      exit;
    SysMsg(IntToStr(CalcFileCRC(Application.ExeName)), c_Red, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.SendServerStatus');
  end;
end;
//检查角色的座标是否在指定误差范围以内
//TargeTBaseObject 为要检查的角色，nX,nY 为比较的座标
//检查角色是否在指定座标的1x1 范围以内，如果在则返回True 否则返回 False

function TPlayObject.CretInNearXY(TargeTBaseObject: TBaseObject; nX,
  nY: Integer): Boolean; //004C36CC
var
  I: Integer;
  nCX, nCY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  try
    Result := False;
    if m_PEnvir = nil then
    begin
      MainOutMessage('CretInNearXY nil PEnvir');
      exit;
    end;
    try
      for nCX := nX - 1 to nX + 1 do
      begin
        for nCY := nY - 1 to nY + 1 do
        begin
          if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) and
            (MapCellInfo.ObjList <> nil) then
          begin
            for I := 0 to MapCellInfo.ObjList.Count - 1 do
            begin
              OSObject := MapCellInfo.ObjList.Items[i];
              if OSObject.btType = OS_MOVINGOBJECT then
              begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if BaseObject <> nil then
                begin
                  if not BaseObject.m_boGhost and (BaseObject = TargeTBaseObject)
                    then
                  begin
                    Result := True;
                    exit;
                  end;
                end;
              end;
            end;
          end;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.CretInNearXY');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CretInNearXY');
  end;
end;

//004D112C

procedure TPlayObject.SendUseitems;
var
  i: Integer;
  sSendMsg: string;
begin
  try
    sSendMsg := '';
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if m_UseItems[i].wIndex > 0 then
      begin
        sSendMsg := sSendMsg + IntToStr(i) + '/' +
          MakeClientItem(@m_UseItems[i], True) + '/';
      end;
    end;
    if m_boHero then
    begin
      m_DefMsg := MakeDefaultMsg(SM_903, 0, 0, 0, 0);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, sSendMsg);
    end
    else if sSendMsg <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SENDUSEITEMS, 0, 0, 0, 0);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendUseitems');
  end;
end;

procedure TPlayObject.SendUseMagic; //004D1418
var
  I: Integer;
  sSendMsg: string;
  UserMagic: pTUserMagic;
  ClientMagic: TClientMagic;
begin
  try
    sSendMsg := '';

    m_HeroJointAttack := nil;
    //if m_boHero then
    for I := Low(m_HeroMagic) to High(m_HeroMagic) do
      //置英雄所学技能为假
      m_HeroMagic[I] := nil;

    for I := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[I];
      //if m_boHero then begin
      if UserMagic.wMagIdx < high(m_HeroMagic) then
        m_HeroMagic[UserMagic.wMagIdx] := UserMagic;
      if UserMagic.wMagIdx in [60..65] then
        m_HeroJointAttack := UserMagic;
      //end;

      ClientMagic.Key := Chr(UserMagic.btKey);
      ClientMagic.Level := UserMagic.btLevel;
      ClientMagic.CurTrain := UserMagic.nTranPoint;
      ClientMagic.Def := UserMagic.MagicInfo^;
      sSendMsg := sSendMsg + EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)) +
        '/';
    end;
    if m_boHero then
    begin
      if sSendMsg <> '' then
      begin
        m_DefMsg := MakeDefaultMsg(SM_904, 0, 0, 0, m_MagicList.Count);
        TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, sSendMsg);
      end;
    end
    else if sSendMsg <> '' then
    begin
      m_DefMsg := MakeDefaultMsg(SM_SENDMYMAGIC, 1, 0, 0, m_MagicList.Count);
      SendSocket(@m_DefMsg, sSendMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendUseMagic');
  end;
end;

function TPlayObject.ClientChangeDir(wIdent: Word; nX, nY, nDir: Integer; var
  dwDelayTime: LongWord): Boolean; //4CAEB8
var
  dwCheckTime: LongWord;
begin
  try
    Result := False;
    if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) then
      exit; //防麻
    if not CheckActionStatus(wIdent, dwDelayTime) then
    begin
      m_boFilterAction := False;
      exit;
    end;
    m_boFilterAction := True;
    dwCheckTime := GetTickCount - m_dwTurnTick;
    if dwCheckTime < g_Config.dwTurnIntervalTime then
    begin
      dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
      {
      if dwCheckTime <= g_Config.dwTurnIntervalTime div 2 then begin
        SysMsg('ClientChangeDir ' + IntToStr(dwCheckTime);
        m_boEmergencyClose:=True;
        Result:=True;
      end;
      }
      exit;
    end;

    if (nX = m_nCurrX) and (nY = m_nCurrY) then
    begin
      m_btDirection := nDir;
      if Walk(RM_TURN) then
      begin
        m_dwTurnTick := GetTickCount();
        Result := True;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientChangeDir');
  end;
end;

function TPlayObject.ClientSitDownHit(nX, nY, nDir: Integer; var dwDelayTime:
  LongWord): Boolean; //004CC248
var
  dwCheckTime: LongWord;
begin
  try
    //SetProcessName('TPlayObject.ClientSitDownHit');
    Result := False;
    if m_boDeath or (m_wStatusTimeArr[POISON_STONE {5}] {0x6A} <> 0) then
      exit; //防麻

    dwCheckTime := GetTickCount - m_dwTurnTick;

    if dwCheckTime < g_Config.dwTurnIntervalTime then
    begin
      dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
      exit;
    end;
    m_dwTurnTick := GetTickCount;
    SendRefMsg(RM_POWERHIT, 0, 0, 0, 0, '');
    Result := True;
  except
    MainOutMessage('[Exception] TPlayObject.ClientSitDownHit');
  end;
end;

procedure TPlayObject.ClientOpenDoor(nX, nY: Integer); //004DABD4
var
  Door: pTDoorInfo;
  Castle: TUserCastle;
begin
  try
    Door := m_PEnvir.GetDoor(nX, nY);
    if Door = nil then
      exit;
    Castle := g_CastleManager.IsCastleEnvir(m_PEnvir);
    if (Castle = nil) or
      (Castle.m_DoorStatus <> Door.Status) or
      (m_btRaceServer <> RC_PLAYOBJECT) or
      Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then
    begin

      UserEngine.OpenDoor(m_PEnvir, nX, nY);
    end;
    {
    if (UserCastle.m_MapCastle <> m_PEnvir) or
       (UserCastle.m_DoorStatus <> Door.Status) or
       (m_btRaceServer <> RC_PLAYOBJECT) or
       UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then begin

      UserEngine.OpenDoor(m_PEnvir,nX,nY);
    end;
    }
  except
    MainOutMessage('[Exception] TPlayObject.ClientOpenDoor');
  end;
end;

procedure TPlayObject.ClientTakeOnItems(btWhere: Byte; nItemIdx: integer;
  sItemName: string); //004DAC70
var
  I, n14, n18: Integer;
  UserItem, TakeOffItem: pTUserItem;
  StdItem, StdItem20: TItem;
  StdItem58: TStdItem;
  sUserItemName: string;
label
  FailExit;
begin
  try
    StdItem := nil;
    UserItem := nil;
    n14 := -1;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);

        sUserItemName := GetItemName(UserItem);
        if StdItem <> nil then
        begin
          if CompareText(sUserItemName, sItemName) = 0 then
          begin
            n14 := i;
            break;
          end;
        end;
      end;
      UserItem := nil;
    end;
    n18 := 0;
    if (StdItem <> nil) and (UserItem <> nil) then
    begin
      if CheckUserItems(btWhere, StdItem) then
      begin
        StdItem.GetStandardItem(StdItem58);
        StdItem.GetItemAddValue(UserItem, StdItem58);
        StdItem58.Name := GetItemName(UserItem);

        if CheckTakeOnItems(btWhere, StdItem58) and CheckItemBindUse(UserItem)
          then
        begin
          TakeOffItem := nil;
          if btWhere in [0..MAXUSEITEMS] then
          begin
            if m_UseItems[btWhere].wIndex > 0 then
            begin
              StdItem20 := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
              if (StdItem20 <> nil) and
                (StdItem20.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then
              begin
                if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7]
                  <> 0) then
                begin
                  SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'},
                    c_Red, t_Hint);
                  n18 := -4;
                  goto FailExit;
                end;
              end;
              if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0)
                then
              begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'},
                  c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end; //004DAE78
              if (StdItem20.Reserved and 4) <> 0 then
              begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'},
                  c_Red, t_Hint);
                n18 := -4;
                goto FailExit;
              end;
              if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then
              begin
                SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'},
                  c_Red, t_Hint);
                goto FailExit;
              end;
              New(TakeOffItem);
              TakeOffItem^ := m_UseItems[btWhere];
            end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

            if (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) and
              //004DAEC7
            (UserItem.btValue[8] <> 0) then
              UserItem.btValue[8] := 0;

            m_UseItems[btWhere] := UserItem^;
            DelBagItem(n14);
            if TakeOffItem <> nil then
            begin
              AddItemToBag(TakeOffItem);
              SendAddItem(TakeOffItem);
            end;
            RecalcAbilitys();
            SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
            SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            if (btWhere = U_STRAW) or ((btWhere = U_HELMET) and (m_Helmet > 0))
              then
              RefShowName;
            if m_boHero then
              TPlayObject(m_HeroHuman).SendDefMessage(SM_907,
                UserItem.MakeIndex, 0, 0, 0, '')
            else
              SendDefMessage(SM_TAKEON_OK, GetFeatureToLong, GetFeatureEx, 0, 0,
                '');
            FeatureChanged();
            n18 := 1;
            NpcGotoLable(g_FunctionNPC, '@TakeOn' + IntToStr(btWhere), False);
            {if (g_FunctionNPC <> nil) and (not m_boHero) then
              g_FunctionNPC.GotoLable(Self,'@TakeOn' + IntToStr(btWhere),False);}
          end; { else begin
          if m_AddUseItems[btWhere].wIndex > 0 then begin
            StdItem20:=UserEngine.GetStdItem(m_AddUseItems[btWhere].wIndex);
            if (StdItem20 <> nil) and
               (StdItem20.StdMode in [15,19,20,21,22,23,24,26]) then begin
              if (not m_boUserUnLockDurg) and (m_AddUseItems[btWhere].btValue[7] <> 0)then begin
                SysMsg('无法取下物品！！！',c_Red,t_Hint);
                n18:=-4;
                goto FailExit;
              end;
            end;
            if not m_boUserUnLockDurg and ((StdItem20.Reserved and 2) <> 0)then begin
              SysMsg('无法取下物品！！！',c_Red,t_Hint);
              n18:=-4;
              goto FailExit;
            end; //004DAE78
            if (StdItem20.Reserved and 4) <> 0 then begin
              SysMsg('无法取下物品！！！',c_Red,t_Hint);
              n18:=-4;
              goto FailExit;
            end;
            New(TakeOffItem);
            TakeOffItem^:=m_AddUseItems[btWhere];
          end; //004DAEC7 if m_UseItems[btWhere].wIndex > 0 then begin

          if (StdItem.StdMode in [15,19,20,21,22,23,24,26]) and   //004DAEC7
             (UserItem.btValue[8] <> 0) then
            UserItem.btValue[8]:=0;

          m_AddUseItems[btWhere]:=UserItem^;
          if TakeOffItem <> nil then begin
            AddItemToBag(TakeOffItem);
            SendAddItem(TakeOffItem);
          end;
          RecalcAbilitys();
          SendMsg(Self,RM_ABILITY,0,0,0,0,'');
          SendMsg(Self,RM_SUBABILITY,0,0,0,0,'');
          SendDefMessage(SM_TAKEON_OK,GetFeatureToLong,0,0,0,'');
          FeatureChanged();
          n18:=1;
        end;
        }
        end
        else
          n18 := -1; //004DAFA0
      end
      else
        n18 := -1; //004DAFA9
    end; //004DAFB0
    FailExit:
    if n18 <= 0 then
      if m_boHero then
        TPlayObject(m_HeroHuman).SendDefMessage(SM_908, n18, 0, 0, 0, '')
      else
        SendDefMessage(SM_TAKEON_FAIL, n18, 0, 0, 0, '');

  except
    MainOutMessage('[Exception] TPlayObject.ClientTakeOnItems');
  end;
end;

procedure TPlayObject.ClientIncFireDrakeHeartDander(nItemIdx: integer);
var
  I, n14, n18: Integer;
  UserItem: pTUserItem;
  StdItem, StdItem20: TItem;
begin
  try
    StdItem := nil;
    UserItem := nil;
    n14 := -1;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
            n14 := i;
            break;
        end;
      end;
      UserItem := nil;
    end;
    n18 := 0;
    if (StdItem <> nil) and (UserItem <> nil) then
    begin
      if StdItem.StdMode=42 then
      begin
            if m_UseItems[U_BUJUK].wIndex > 0 then
            begin
              StdItem20 := UserEngine.GetStdItem(m_UseItems[U_BUJUK].wIndex);
              if StdItem20.StdMode=25 then
              begin
               Inc(m_UseItems[U_BUJUK].Dura,UserItem.Dura);
               m_ItemList.Delete(n14);
               if m_UseItems[U_BUJUK].Dura>m_UseItems[U_BUJUK].DuraMax then
                 m_UseItems[U_BUJUK].Dura:=m_UseItems[U_BUJUK].DuraMax;
                n18 := 1;
                SendMsg(Self, RM_DURACHANGE, U_BUJUK,m_UseItems[U_BUJUK].Dura, m_UseItems[U_BUJUK].DuraMax, 0,
                      '');
                if m_boHero then
                   TPlayObject(m_HeroHuman).SendDefMessage(SM_909,UserItem.MakeIndex, 0, 0, 0, '');
              end;
            end; //004DAEC7 if m_UseItems[U_BUJUK].wIndex > 0 then
      end else
      n18 := -1; //004DAFA0
    end else
      n18 := -1; //004DAFA9
    if n18 <= 0 then
      if m_boHero then
        TPlayObject(m_HeroHuman).SendDefMessage(SM_908, n18, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientIncFireDrakeHeartDander');
  end;

end;

//泉水叠加到泉水罐 或药品叠加
procedure TPlayObject.ClientItemFold(bHero:Byte;sMsg:String);
var
  I, n14,n18: Integer;
  UserItem,DesUserItem,UserTempItem: pTUserItem;
  StdItem, StdItem20: TItem;
  itemsindex:TItemsFoldRec;
begin
  try
    StdItem := nil;
    UserItem := nil;
    DesUserItem:=nil;
    UserTempItem:=nil;
    DecodeBuffer(sMsg,@itemsindex,SizeOf(TItemsFoldRec));
    n14 := -1;
  if bHero=1 then
  begin
    for I := 0 to  m_Hero.m_ItemList.Count - 1 do
    begin
      UserTempItem := m_Hero.m_ItemList.Items[i];
      if (UserTempItem <> nil) and (UserTempItem.MakeIndex = itemsindex.SourMakeIndex) then
      begin
        StdItem:= UserEngine.GetStdItem(UserTempItem.wIndex);
        if StdItem <> nil then
         begin
          n14 := i;
          UserItem:=UserTempItem;
         end;
      end;
      if (UserTempItem <> nil) and (UserTempItem.MakeIndex = itemsindex.DESMakeIndex) then
       begin
        StdItem20 := UserEngine.GetStdItem(UserTempItem.wIndex);
        if  StdItem20<>nil then
         begin
          DesUserItem:=UserTempItem;
         end;        end;
      if (StdItem <> nil) and (UserItem <> nil) and (StdItem20 <> nil) and (DesUserItem <> nil) then break;
      UserTempItem:= nil;
    end;
  end else
  begin
    for I := 0 to  m_ItemList.Count - 1 do
    begin
      UserTempItem := m_ItemList.Items[i];
      if (UserTempItem <> nil) and (UserTempItem.MakeIndex = itemsindex.SourMakeIndex) then
      begin
        StdItem:= UserEngine.GetStdItem(UserTempItem.wIndex);
        if StdItem <> nil then
         begin
           n14 := i;
           UserItem:=UserTempItem;
         end;
      end;
      if (UserTempItem <> nil) and (UserTempItem.MakeIndex = itemsindex.DESMakeIndex) then
       begin
        StdItem20 := UserEngine.GetStdItem(UserTempItem.wIndex);
        if  StdItem20<>nil then
         begin
          DesUserItem:=UserTempItem;
         end;
        end;
      if (StdItem <> nil) and (UserItem <> nil) and (StdItem20 <> nil) and (DesUserItem <> nil) then break;
      UserTempItem:= nil;
    end;
  end;
    n18 := 0;
    if (StdItem <> nil) and (UserItem <> nil) and (StdItem20 <> nil) and (DesUserItem <> nil) then
    begin
    if ((StdItem.StdMode=9) and (StdItem.Shape=1) and (StdItem20.StdMode=2) and (StdItem20.Reserved=56)) or
    ((StdItem.StdMode=0) and (StdItem20.StdMode=0) and (StdItem20.Name=StdItem.Name) and (StdItem.Reserved=1) and (StdItem20.Reserved=1)) then
      begin
        if StdItem.StdMode=0 then //药品叠加
        begin
          if bHero=1 then
            m_Hero.m_ItemList.Delete(n14)
          else
            m_ItemList.Delete(n14);
          Inc(DesUserItem.Dura,UserItem.Dura);
          n18 := 1;
        end else
        begin //泉水叠加到泉水罐
         if DesUserItem.Dura<DesUserItem.DuraMax then
          begin
          if bHero=1 then
            m_Hero.m_ItemList.Delete(n14)
          else
            m_ItemList.Delete(n14);
          Inc(DesUserItem.Dura,1000);
          if DesUserItem.Dura>DesUserItem.DuraMax then
            DesUserItem.Dura:=DesUserItem.DuraMax;
          n18 := 1;
          end else
            n18 := -1; //004DAFA0
        end;
        if n18=1 then
        begin
         if bHero=1 then
          TPlayObject(m_Hero).SendMsg(m_Hero, RM_BAG_DURACHANGE2, DesUserItem.wIndex,DesUserItem.MakeIndex, DesUserItem.Dura,
            DesUserItem.DuraMax,'')
         else
          SendMsg(Self, RM_BAG_DURACHANGE2, DesUserItem.wIndex,DesUserItem.MakeIndex, DesUserItem.Dura,
            DesUserItem.DuraMax,'');
          SendDefMessage(SM_909,UserItem.MakeIndex, 0, 0, 0, '');
        end;
      end else
      n18 := -1; //004DAFA0
    end else
      n18 := -1; //004DAFA9
    if n18 <= 0 then
      if bHero=1 then
        SendDefMessage(SM_908, n18, 0, 0, 0, '')
      else
        SendDefMessage(SM_TAKEON_FAIL,0, 0, 0, 0, '')
  except
    MainOutMessage('[Exception] TPlayObject.ClientItemFold');
  end;

end;

procedure TPlayObject.MasterItemToHeroBag(ItemId: Integer; Msg: string);
var
  UserItem: pTUserItem;
  I: Integer;
  boSend: Boolean;
  StdItem: TItem;
begin
  try
    boSend := True;
    if m_boGhost then
      exit;
    if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not m_Hero.m_boDeath)
      then
    begin
      if IsEnoughBag then
      begin
        for I := 0 to m_Hero.m_ItemList.Count - 1 do
        begin
          UserItem := m_Hero.m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = ItemId) then
          begin
            m_Hero.m_ItemList.Delete(I);
            m_ItemList.Add(UserItem);
            boSend := False;
            break;
          end;
        end;
      end;
    end;
    if boSend then
    begin
      SendDefMessage(SM_818, -3, 0, 0, 0, '')
    end
    else
    begin
      SendDefMessage(SM_819, 0, 0, 0, 0, '');
      WeightChanged;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.MasterItemToHeroBag');
  end;
end;

procedure TPlayObject.ClientGetHero(Hero: Integer);
begin
  if (m_HeroName <> '') or (m_Hero <> nil) then
  begin
    NpcGotoLable(g_FunctionNPC, '@GetHeroBak', False);
    exit;
  end;
  if Hero = 1 then
  begin
    if m_HeroName1 <> '' then
    begin
      m_HeroName := m_HeroName1;
      m_HeroName1 := '';
      m_HeroClass := False;
      NpcGotoLable(g_FunctionNPC, '@GetHeroOk', False);
      exit;
    end;
  end
  else
  begin
    if m_HeroName2 <> '' then
    begin
      m_HeroName := m_HeroName2;
      m_HeroName2 := '';
      m_HeroClass := True;
      NpcGotoLable(g_FunctionNPC, '@GetHeroOk', False);
      exit;
    end;
  end;
end;

procedure TPlayObject.ClientGetPlayDrink(Npc, Drink1: Integer; Msg: string);
var
  i, Drink2: integer;
  Drink1Item, Drink2Item, UserItem: pTUserItem;
  Npc2: TNormNpc;
begin
  Drink2 := StrToIntDef(Msg, 0);
  Drink1Item := nil;
  Drink2Item := nil;
  if Drink2 = 0 then
    exit;
  for i := 0 to m_ItemList.Count - 1 do
  begin
    UserItem := m_ItemList.Items[I];
    if UserItem.MakeIndex = Drink1 then
    begin
      Drink1Item := UserItem;
    end
    else if UserItem.MakeIndex = Drink2 then
    begin
      Drink2Item := UserItem;
    end;
  end;
  if (Drink1Item <> nil) and (Drink2Item <> nil) then
  begin
    Npc2 := UserEngine.FindMerchant(TObject(Npc));
    if Npc2 = nil then
      Npc2 := UserEngine.FindNPC(TObject(Npc));
    if Npc2 = nil then
      exit;
    if m_boGhost then
      exit;
    if ((Npc2.m_PEnvir = m_PEnvir) and
      (abs(Npc2.m_nCurrX - m_nCurrX) < 15) and
      (abs(Npc2.m_nCurrY - m_nCurrY) < 15)) or (Npc2.m_boIsHide) then
    begin
      //Npc.UserSelect(Self,Trim(sMsg));
      DelBagItemEx(Drink1Item.MakeIndex, 11);
      DelBagItemEx(Drink2Item.MakeIndex, 11);
      NpcGotoLable(Npc2, '~PlayDrink_Ok', False);
    end;
  end;
end;

procedure TPlayObject.HeroItemToMasterBag(ItemId: Integer; Msg: string);
var
  UserItem: pTUserItem;
  I: Integer;
  boSend: Boolean;
  StdItem: TItem;
begin
  try
    boSend := True;
    if m_boGhost then
      exit;
    if (m_Hero <> nil) and (not m_Hero.m_boGhost) and (not m_Hero.m_boDeath)
      then
    begin
      if TPlayObject(m_Hero).GetHeroBagCount > m_Hero.m_ItemList.Count then
      begin
        for I := 0 to m_ItemList.Count - 1 do
        begin
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = ItemId) then
          begin
           StdItem := UserEngine.GetStdItem(UserItem.wIndex);
           if StdItem<>nil then
             if not StdItem.nRule[RULE_HeroBag] then
             begin
              m_ItemList.Delete(I);
              m_Hero.m_ItemList.Add(UserItem);
              boSend := False;
              break;
             end else
             begin
               SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,'此物品禁止放到英雄包裹！！');
               break;
             end;
          end;
        end;
      end;
    end;
    if boSend then
    begin
      SendDefMessage(SM_818, -2, 0, 0, 0, '')
    end
    else
    begin
      SendDefMessage(SM_817, 0, 0, 0, 0, '');
      WeightChanged;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroItemToMasterBag');
  end;
end;

procedure TPlayObject.ClientTakeOffItems(btWhere: Byte; nItemIdx: integer;
  sItemName: string); //004DB01C
var
  n10: Integer;
  StdItem: TItem;
  UserItem: pTUserItem;
  sUserItemName: string;
label
  FailExit;
begin
  try
    n10 := 0;
    if not m_boDealing and (btWhere <= MAXUSEITEMS) then
    begin
      //if (btWhere=U_HELMET) and (m_UseItems[U_STRAW].wIndex>0) then btWhere:=U_STRAW;
      if m_UseItems[btWhere].wIndex > 0 then
      begin
        if m_UseItems[btWhere].MakeIndex = nItemIdx then
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[btWhere].wIndex);
          if (StdItem <> nil) and
            (StdItem.StdMode in [15, 19, 20, 21, 22, 23, 24, 26]) then
          begin
            if (not m_boUserUnLockDurg) and (m_UseItems[btWhere].btValue[7] <> 0)
              then
            begin
              SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red,
                t_Hint);
              n10 := -4;
              goto FailExit;
            end;
          end;
          if (StdItem <> nil) and (StdItem.nRule[RULE_TAKEOFF]) then
          begin
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
              '此物品禁止取下！！');
            goto FailExit;
          end;
          if not m_boUserUnLockDurg and ((StdItem.Reserved and 2) <> 0) then
          begin
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red,
              t_Hint);
            n10 := -4;
            goto FailExit;
          end;
          if (StdItem.Reserved and 4) <> 0 then
          begin
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red,
              t_Hint);
            n10 := -4;
            goto FailExit;
          end;
          if InDisableTakeOffList(m_UseItems[btWhere].wIndex) then
          begin
            SysMsg(g_sCanotTakeOffItem {'无法取下物品！！！'}, c_Red,
              t_Hint);
            goto FailExit;
          end;
          //取自定义物品名称
          sUserItemName := GetItemName(@m_UseItems[btWhere]);

          if CompareText(sUserItemName, sItemName) = 0 then
          begin
            New(UserItem);
            UserItem^ := m_UseItems[btWhere];
            if AddItemToBag(UserItem) then
            begin
              NpcGotoLable(g_FunctionNPC, '@TakeOff' + IntToStr(btWhere),
                False);
              {if (g_FunctionNPC <> nil) and (not m_boHero) then
                g_FunctionNPC.GotoLable(Self,'@TakeOff' + IntToStr(btWhere),False); }
              m_UseItems[btWhere].wIndex := 0;

              SendAddItem(UserItem);
              RecalcAbilitys();
              SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
              SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
              if (btWhere = U_STRAW) or (btWhere = U_HELMET) then
                RefShowName;
              if m_boHero then
                TPlayObject(m_HeroHuman).SendDefMessage(SM_909,
                  UserItem.MakeIndex, 0, 0, 0, '')
              else
                SendDefMessage(SM_TAKEOFF_OK, GetFeatureToLong, GetFeatureEx, 0,
                  0, '');
              FeatureChanged();
            end
            else
            begin
              Dispose(UserItem);
              n10 := -3;
            end;
          end;
        end; //004DB26F
      end
      else
        n10 := -2; //004DB25F

    end
    else
      n10 := -1; //004DB268

    FailExit: //004DB26F
    if n10 <= 0 then
      if m_boHero then
        TPlayObject(m_HeroHuman).SendDefMessage(SM_910, n10, 0, 0, 0, '')
      else
        SendDefMessage(SM_TAKEOFF_FAIL, n10, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientTakeOffItems');
  end;
end;

procedure TPlayObject.ClientUseItems(nItemIdx: Integer; sItemName: string);
//004DB3B0
  function GetUnbindItemName(nShape: Integer): string; //004E4214
  var
    I: Integer;
  begin
    Result := '';
    for I := 0 to g_UnbindList.Count - 1 do
    begin
      if Integer(g_UnbindList.Objects[I]) = nShape then
      begin
        Result := g_UnbindList.Strings[I];
        break;
      end;
    end;
  end;
  function GetUnBindItems(sItemName: string; nCount: Integer): Boolean;
    //004DB2DC
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := False;
    for I := 0 to nCount - 1 do
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        m_ItemList.Add(UserItem);
        if m_btRaceServer = RC_PLAYOBJECT then
          SendAddItem(UserItem);
        Result := True;
      end
      else
      begin
        Dispose(UserItem);
        break;
      end;
    end;
  end;
resourcestring
  sTest1 = '绑定成功\地图：%s\坐标：%d,%d';
var
  I,nTAlcoho: Integer;
  boEatOK: Boolean;
  UserItem: pTUserItem;
  StdItem: TItem;
  UserItem34: TUserItem;
  //  boDel      :Boolean;
  nCount: Integer;
  NewUserItem: TNewUserItem;
  str: string;
  boSendFall: Boolean;
  boDel,boRtemp,boNeedRecalc1: Boolean;
begin
  try
    boEatOK := False;
    boSendFall := True;
    StdItem := nil;
    if m_PEnvir.Flag.boMission then
    begin
      SysMsg('本地图不允许使用任何物品！！！', c_Red, t_System);
      SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
      exit;
    end;
    if m_boCanUseItem then
    begin
      if not m_boDeath then
      begin
        for I := m_ItemList.Count - 1 downto 0 do
        begin
          UserItem := m_ItemList.Items[I];
          if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
          begin
            UserItem34 := UserItem^;
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) and m_PEnvir.Flag.boNOTALLOWUSEITEMS then
            begin
              if m_PEnvir.CheckNotEatItems(StdItem.Name) then
              begin
                SysMsg(Format('本地图不允许使用物品[%s]！！！',
                  [StdItem.Name]), c_Red, t_System);
                StdItem := nil;
              end;
            end;
            if StdItem <> nil then
            begin
              m_ItemList.Delete(I);
              try
                case StdItem.StdMode of //
                  0:
                    begin
                      if (m_WAbil.HP > 0) then
                      begin
                      boEatOK := False;
                      boDel := True;
                      if UserItem.Dura>1 then
                       nCount:=1
                      else
                       nCount := UserItem.Dura;
                        if EatItems(StdItem,nCount) then
                        begin
                          if UserItem.Dura > nCount then
                          begin
                            Dec(UserItem.Dura, nCount);
                                SendMsg(Self, RM_BAG_DURACHANGE2, UserItem.wIndex,
                              UserItem.MakeIndex, UserItem.Dura,
                              UserItem.DuraMax,
                              '');
                              boDel := False;
                          end;
                        if boDel then  boEatOK := True;
                        end;
                      end;
                    end;
                  1, 2, 3:
                    begin //药
                      boDel := True;
                      nCount := UserItem.Dura;
                      if (StdItem.StdMode = 2) and (StdItem.Shape = 99) then
                      begin
                        Move(UserItem^, NewUserItem, Sizeof(TNewUserItem));
                        if NewUserItem.sMapName <> '' then
                        begin
                          SpaceMove(NewUserItem.sMapName, UserItem34.Dura,
                            UserItem34.DuraMax, 1);
                          //Dispose(UserItem);
                          //m_ItemList.Delete(I);
                          boEatOK := True;
                        end
                        else
                        begin
                          NewUserItem.Dura := m_nCurrX;
                          NewUserItem.DuraMax := m_nCurrY;
                          NewUserItem.sMapName := m_sMapName;
                          Move(NewUserItem, UserItem^, Sizeof(TUserItem));
                          {StdItem.GetStandardItem(ClientItem.S);
                          StdItem.GetItemAddValue(UserItem,ClientItem.S);
                          ClientItem.Dura:=UserItem.Dura;
                          ClientItem.DuraMax:=UserItem.DuraMax;
                          ClientItem.MakeIndex:=UserItem.MakeIndex;
                          GetMapItemInfo(UserItem,ClientItem.S);}
                          boSendFall := False;
                          SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');

                          m_DefMsg := MakeDefaultMsg(CM_UPDATEBAGITEM,
                            UserItem.MakeIndex, UserItem.Dura, UserItem.DuraMax,
                            0);
                          SendSocket(@m_DefMsg, MakeClientItem(UserItem)
                            {EncodeBuffer(@ClientItem,SizeOf(TClientItem))});

                          m_DefMsg := MakeDefaultMsg(SM_MENU_OK, 0, 0, 0, 0);
                          Str := Format(sTest1, [m_PEnvir.sMapDesc,
                            NewUserItem.Dura, NewUserItem.DuraMax]);
                          SendSocket(@m_DefMsg, EncodeString(Str));
                        end;
                      end
                      else if EatItems(StdItem, nCount) then
                      begin
                        if StdItem.StdMode = 2 then
                        begin
                          if (StdItem.Reserved=56) and (UserItem.Dura >= nCount) then //泉水罐
                             GetUnBindItems(GetUnbindItemName(StdItem.Shape), 1);
                          if UserItem.Dura >= nCount then
                          begin
                            Dec(UserItem.Dura, nCount);
                            SendMsg(Self, RM_BAG_DURACHANGE2, UserItem.wIndex,
                              UserItem.MakeIndex, UserItem.Dura,
                              UserItem.DuraMax,
                              '');
                             boDel := False;
                            //boEatOK:=True;
                          end;
                        end;
                        if boDel then
                        begin
                          //Dispose(UserItem);
                          //m_ItemList.Delete(I);
                          if (StdItem.StdMode = 2) and (StdItem.Reserved=56) then
                             boEatOK  := False
                           else
                             boEatOK := True;
                        end;
                      end;
                    end;
                  4:
                    begin //书
                      if ReadBook(StdItem) then
                      begin
                        //Dispose(UserItem);
                        //m_ItemList.Delete(I);
                        boEatOK := True;
                        if (m_MagicErgumSkill <> nil) and (not m_boUseThrusting)
                          then
                        begin
                          ThrustingOnOff(True);
                          SendSocket(nil, '+LNG');
                        end;
                        if (m_MagicBanwolSkill <> nil) and (not m_boUseHalfMoon)
                          then
                        begin
                          HalfMoonOnOff(True);
                          SendSocket(nil, '+WID');
                        end;
                        if (m_MagicRedBanwolSkill <> nil) and (not
                          m_boRedUseHalfMoon) then
                        begin
                          RedHalfMoonOnOff(True);
                          SendSocket(nil, '+WID');
                        end;
                      end;
                    end;
                  31:
                    begin //解包物品
                       if StdItem.AniCount in [0..3] then
                      begin
                        if (m_ItemList.Count + 6 {-1}) <= MAXBAGITEM then
                        begin
                          //Dispose(UserItem);
                          //m_ItemList.Delete(I);
                          GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                          boEatOK := True;
                        end;
                      end
                      else
                      begin
                        if UseStdmodeFunItem(StdItem) then
                        begin //使用物品脚本触发
                          //Dispose(UserItem);
                          //m_ItemList.Delete(I);
                          boEatOK := True;
                        end;
                      end;
                    end;
                60: //酒
                  begin
                    nTAlcoho:=0;
                    boEatOK:=False;
                    boRtemp:=False;
                    boNeedRecalc1:=False;
                    boDel := True;
                    nCount := 1000;
                    if StdItem.Reserved+UserItem.btValue[10]>0 then
                      nTAlcoho:=(g_Config.nMaxAlcoholValue*((StdItem.Reserved+UserItem.btValue[10]) div 2) div 100);
                    if  ((m_WineRec.Alcoho+nTAlcoho) / m_WineRec.WineValue*100)>=g_Config.nRUNKValue then
                   // begin
                     begin
                      SysMsg('你已经醉了,不能再喝酒!', c_Red, t_System);
                      m_RUNKarray[0]:=1;
                      m_RUNKarray[1]:=1;
                      boNeedRecalc1:=True;
                      m_boRUNK:=True;
                     end;
                    //  SendAddItem(UserItem,1);
                    //  boDel := False;
                    // Exit;
                   // end else }
                  //  begin
                      if m_WineRec.WineValue>StdItem.Need then
                      begin
                        if UserItem.Dura >= nCount then
                        begin
                          Dec(UserItem.Dura, nCount);
                          m_dtAlcohoTime:=Now;//饮普通酒时间
                          if m_WineRec.Alcoho+nTAlcoho>m_WineRec.WineValue then
                            m_WineRec.Alcoho:=m_WineRec.WineValue
                          else
                            Inc(m_WineRec.Alcoho,nTAlcoho);
                          GetSkill83LevelAbil();//重新计算先天元力等级
                          if StdItem.Source+UserItem.btValue[7]>=g_Config.nWinequality then //品质达到加附加属生的
                          begin
                           if Random(g_Config.nGettempAbilRate)=0 then //达到指定机率
                           begin
                            m_dwSpeedupAlcoholTick:=m_dwSpeedupAlcoholTick+g_Config.nSpeedupAlcoholTick;//酒量加速时间
                            boRtemp:=True;
                           end;
                          end;
                          if  StdItem.AniCount=2 then   //药酒
                          begin
                            m_dtMedicineAlcohoTime:=Now;//饮药酒时间
                           if StdItem.Source+UserItem.btValue[7]>=g_Config.nMakeMedicineWineMinQuality then //品质高于指定值
                           begin
                            case StdItem.Shape of
                            8:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[0]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[0]:=1;
                               m_MedicineAbilArrTimeOutTick[0]:=GetTickCount();
                            end;
                            9:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[1]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[1]:=1;
                               m_MedicineAbilArrTimeOutTick[1]:=GetTickCount();
                            end;
                            10:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[4]:=1+g_Config.nTempAbil//加上随机加属性
                               else                                         //敏捷
                                m_MedicineAbilTemp[4]:=1;
                               m_MedicineAbilArrTimeOutTick[4]:=GetTickCount();
                               boNeedRecalc1:=True;
                            end;
                            11:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[3]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[3]:=1;
                               m_MedicineAbilArrTimeOutTick[3]:=GetTickCount();
                            end;
                            12:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[2]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[2]:=1;
                               m_MedicineAbilArrTimeOutTick[2]:=GetTickCount();
                            end;
                            end;
                            Inc(m_MedicineRec.MedicineValue);//加药力值
                            if m_MedicineRec.MedicineValue>=m_MedicineRec.MaxMedicineValue then
                            begin
                             Inc(m_MedicineRec.MedicineLevel);
                             m_MedicineRec.MedicineValue:=m_MedicineRec.MedicineValue-m_MedicineRec.MaxMedicineValue;
                             m_MedicineRec.MaxMedicineValue:=GetMedicineLevelExp(m_MedicineRec.MedicineLevel);//药力值升级值
                            end;
                           End;
                          end;
                          RecalcAbilitys();
                          SendMsg(Self, RM_DRINK, 0, 0,0,0, '');
                          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                          if boNeedRecalc1 then //更新敏捷
                             SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                          SendMsg(Self, RM_BAG_DURACHANGE2, UserItem.wIndex,UserItem.MakeIndex, UserItem.Dura,UserItem.DuraMax,'');
                          SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
                          SendMsg(Self, RM_MedicineValue, 0,0, 0,0,'');
                          if  UserItem.Dura<>0 then  boDel := False;
                        end;
                      end else
                      begin
                         SysMsg('你的酒量不够,喝不了此酒!', c_Red, t_System);
                         SendAddItem(UserItem,1);
                         boDel := False;
                      end;
                  //  end;
                   if boDel then  boEatOK := True;
                end;
              end;
              finally
                if boEatOK  then
                  Dispose(UserItem)
                else
                  m_ItemList.Add(UserItem);
              end;
            end;
            break;
          end;
        end;
      end;
    end
    else
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sCanotUseItemMsg);
    end;
    if boEatOK then
    begin
      WeightChanged();
      SendDefMessage(SM_EAT_OK, 0, 0, 0, 0, '');
      //004DB73F
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('11' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(UserItem34.wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(UserItem34.MakeIndex) + #9 +
          '1' + #9 +
          '0');
    end
    else
    begin
      if boSendFall then
        SendDefMessage(SM_EAT_FAIL, 0, 0, 0, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientUseItems');
  end;
end;

procedure TPlayObject.HeroLockedObject(t_Type, nX, nY: Integer; BaseObject:
  TBaseObject);
resourcestring
  sException = '[Exception] TPlayObject.HeroLockedObject %d';
  sMsg = '[英雄 %s] 锁定目标(%s),座标(%d,%d)';
  sMsg2 = '开始守护(%d,%d)';
  sMsg3 = '停止守护';
  //var
  //  LockedBase:TBaseObject;
begin
  try
    try
      if not m_boGhost then
      begin
        if t_Type = 0 then
        begin
          if (BaseObject <> nil) and
            (not BaseObject.m_boGhost) and
            (not BaseObject.m_boDeath) and
            (BaseObject <> Self) and
            (BaseObject <> m_HeroHuman) and
            ((not InSafeZone) or (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) or
            (BaseObject.m_AllMaster = nil)) and
            ((BaseObject.m_btRaceServer >= RC_ANIMAL) or
            (BaseObject.m_btRaceServer = RC_PLAYOBJECT)) and
            (m_HeroHuman.IsProperTarget(BaseObject)) then
          begin
            if m_btAttatckMode <> 0 then
            begin
              m_HeroHuman.SysMsg('状态：攻击', c_Red, t_Hint);
              m_btAttatckMode := 0;
            end;
            m_HeroLocked := BaseObject;
            m_HeroboLocked := True;
            m_HeroHuman.SetTargetCreat(BaseObject);
            SetTargetCreat(BaseObject);
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
              m_HeroHuman.SysMsg(format(sMsg,
                [m_sCharName,
                BaseObject.m_sCharName,
                  BaseObject.m_nCurrX,
                  BaseObject.m_nCurrY]),
                  c_Blue,
                t_Hint)
            else
              m_HeroHuman.SysMsg(format(sMsg,
                [m_sCharName,
                FilterShowName(BaseObject.m_sCharName),
                  BaseObject.m_nCurrX,
                  BaseObject.m_nCurrY]),
                  c_Blue,
                t_Hint);
          end;
        end
        else if t_Type = 1 then
        begin
          if m_HeroProtect then
          begin
            m_HeroProtect := False;
            m_HeroProtectX := -1;
            m_HeroHuman.SysMsg(sMsg3,
              c_Red,
              t_Hint);
          end
          else
          begin
            if m_PEnvir.Flag.NOHEROPROTECT then
             begin
                SysMsg('本地图禁止英雄守护。', c_Green, t_Hint);
             end else
             begin
                m_HeroProtect := True;
                m_HeroProtectX := nX;
                m_HeroProtectY := nY;
                m_HeroHuman.SysMsg(format(sMsg2, [nX, nY]),
                  c_Red,
                  t_Hint);
             end;
          end;
        end;
      end;
    except
      MainOutMessage(format(sException, [t_Type]));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.HeroLockedObject');
  end;
end;

procedure TPlayObject.HeroEatItems(nItemIdx: Integer; sItemName: string);
  function GetUnbindItemName(nShape: Integer): string; //004E4214
  var
    I: Integer;
  begin
    Result := '';
    for I := 0 to g_UnbindList.Count - 1 do
    begin
      if Integer(g_UnbindList.Objects[I]) = nShape then
      begin
        Result := g_UnbindList.Strings[I];
        break;
      end;
    end;
  end;
  function GetUnBindItems(sItemName: string; nCount: Integer): Boolean;
    //004DB2DC
  var
    I: Integer;
    UserItem: pTUserItem;
  begin
    Result := False;
    for I := 0 to nCount - 1 do
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(sItemName, UserItem) then
      begin
        m_ItemList.Add(UserItem);
        if m_btRaceServer = RC_PLAYOBJECT then
          SendAddItem(UserItem);
        Result := True;
      end
      else
      begin
        Dispose(UserItem);
        break;
      end;
    end;
  end;
var
  I,nTAlcoho: Integer;
  boEatOK: Boolean;
  UserItem: pTUserItem;
  StdItem: TItem;
  UserItem34: TUserItem;
  nCount: Integer;
  boDel,boRtemp,boNeedRecalc1: Boolean;
begin
  try
    boEatOk := False;
    StdItem := nil;
    if (not m_boGhost) and m_boCanUseItem and (not m_boDeath) then
    begin
      for I := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[I];
        if (UserItem <> nil) and (UserItem.MakeIndex = nItemIdx) then
        begin
          UserItem34 := UserItem^;
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then
          begin
            m_ItemList.Delete(I);
            try
              case StdItem.StdMode of //
                0:
                  begin //药品
                    if (m_WAbil.HP > 0) then
                    begin
                      boEatOK := False;
                      boDel := True;
                      if UserItem.Dura>1 then
                       nCount:=1
                      else
                       nCount := UserItem.Dura;
                        if EatItems(StdItem,nCount) then
                        begin
                          if UserItem.Dura > nCount then
                          begin
                            Dec(UserItem.Dura, nCount);
                                SendMsg(Self, RM_BAG_DURACHANGE2, UserItem.wIndex,
                              UserItem.MakeIndex, UserItem.Dura,
                              UserItem.DuraMax,
                              '');
                              boDel := False;
                          end;
                        if boDel then  boEatOK := True;
                        end;
                      end;
                    end;
                2:
                  begin
                    if StdItem.Shape in [1, 9] then
                    begin
                      boDel := True;
                      nCount := UserItem.Dura;
                      if EatItems(StdItem, nCount) then
                      begin
                        if UserItem.Dura > nCount then
                        begin
                          Dec(UserItem.Dura, nCount);
                          SendMsg(Self, RM_BAG_DURACHANGE2, UserItem.wIndex,
                            UserItem.MakeIndex, UserItem.Dura, UserItem.DuraMax,
                            '');
                          boDel := False;
                        end;
                        if boDel then
                        begin
                          //Dispose(UserItem);
                          ///m_ItemList.Delete(I);
                          boEatOK := True;
                        end;
                      end;
                    end;
                  end;
                4:
                  begin //书
                    if ReadBook(StdItem) then
                    begin
                      //Dispose(UserItem);
                      //m_ItemList.Delete(I);
                      boEatOK := True;
                    end;
                  end;
                31:
                  begin //解包物品
                     if StdItem.AniCount in [0..3] then
                    begin
                      if (m_ItemList.Count + 6) <= GetHeroBagCount then
                      begin
                        //Dispose(UserItem);
                        //m_ItemList.Delete(I);
                        GetUnBindItems(GetUnbindItemName(StdItem.Shape), 6);
                        //解包数量
                        boEatOK := True;
                      end;
                    end;
                  end;
                60: //酒
                  begin
                    nTAlcoho:=0;
                    boEatOK:=False;
                    boRtemp:=False;
                    boNeedRecalc1:=False;
                    boDel := True;
                    nCount := 1000;
                    if StdItem.Reserved+UserItem.btValue[10]>0 then
                      nTAlcoho:=(g_Config.nMaxAlcoholValue*((StdItem.Reserved+UserItem.btValue[10]) div 2) div 100);
                    if  ((m_WineRec.Alcoho+nTAlcoho) / m_WineRec.WineValue*100)>=g_Config.nRUNKValue then
                  //  begin
                     begin
                      SysMsg('你已经醉了,不能再喝酒!', c_Red, t_System);
                      m_RUNKarray[0]:=1;
                      m_RUNKarray[1]:=1;
                      m_boRUNK:=True;
                     end;
                    //  SendAddItem(UserItem,1);
                   //   boDel := False;
                    // Exit;
                   // end else
                 //   begin
                      if m_WineRec.WineValue>StdItem.Need then
                      begin
                        if UserItem.Dura >= nCount then
                        begin
                          Dec(UserItem.Dura, nCount);
                          m_dtAlcohoTime:=Now;//饮普通酒时间
                          if m_WineRec.Alcoho+nTAlcoho>m_WineRec.WineValue then
                            m_WineRec.Alcoho:=m_WineRec.WineValue
                          else
                            Inc(m_WineRec.Alcoho,nTAlcoho);
                          GetSkill83LevelAbil();//重新计算先天元力等级
                          if StdItem.Source+UserItem.btValue[7]>=g_Config.nWinequality then //品质高于指定值
                          begin
                           if Random(g_Config.nGettempAbilRate)=0 then //达到指定机率
                           begin
                            m_dwSpeedupAlcoholTick:=m_dwSpeedupAlcoholTick+g_Config.nSpeedupAlcoholTick;//酒量加速时间
                            boRtemp:=True;
                           end;
                          end;
                          if  StdItem.AniCount=2 then   //药酒
                          begin
                            m_dtMedicineAlcohoTime:=Now;//饮药酒时间
                           if StdItem.Source+UserItem.btValue[7]>=g_Config.nMakeMedicineWineMinQuality then //品质高于指定值
                           begin
                            case StdItem.Shape of
                            8:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[0]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[0]:=1;
                               m_MedicineAbilArrTimeOutTick[0]:=GetTickCount();
                            end;
                            9:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[1]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[1]:=1;
                               m_MedicineAbilArrTimeOutTick[1]:=GetTickCount();
                            end;
                            10:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[4]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[4]:=1;
                               m_MedicineAbilArrTimeOutTick[4]:=GetTickCount();
                               boNeedRecalc1:=True;
                            end;
                            11:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[3]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[3]:=1;
                               m_MedicineAbilArrTimeOutTick[3]:=GetTickCount();
                            end;
                            12:
                            begin
                               if boRtemp then
                                 m_MedicineAbilTemp[2]:=1+g_Config.nTempAbil//加上随机加属性
                               else
                                m_MedicineAbilTemp[2]:=1;
                               m_MedicineAbilArrTimeOutTick[2]:=GetTickCount();
                            end;
                            end;
                            Inc(m_MedicineRec.MedicineValue);//加药力值
                            if m_MedicineRec.MedicineValue>=m_MedicineRec.MaxMedicineValue then
                            begin
                             Inc(m_MedicineRec.MedicineLevel);
                             m_MedicineRec.MedicineValue:=m_MedicineRec.MedicineValue-m_MedicineRec.MaxMedicineValue;
                             m_MedicineRec.MaxMedicineValue:=GetMedicineLevelExp(m_MedicineRec.MedicineLevel);//药力值升级值
                            end;
                           End;
                          end;
                          RecalcAbilitys();
                          SendMsg(Self, RM_DRINK, 0, 0,0,0, '');
                          SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
                          if boNeedRecalc1 then
                             SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
                          SendMsg(Self, RM_BAG_DURACHANGE2, UserItem.wIndex,UserItem.MakeIndex, UserItem.Dura,UserItem.DuraMax,'');
                          SendMsg(Self, RM_WineValue, 0,0, 0,0,'');
                          SendMsg(Self, RM_MedicineValue, 0,0, 0,0,'');
                          if  UserItem.Dura<>0 then  boDel := False;
                        end;
                      end else
                      begin
                         SysMsg('你的酒量不够不能喝酒!', c_Red, t_System);
                         SendAddItem(UserItem,1);
                         boDel := False;
                      end;
                  //  end;
                   if boDel then  boEatOK := True;
                end;
              end;
            finally
              if boEatOk then
                Dispose(UserItem)
              else
                m_ItemList.Add(UserItem);
            end;
          end;
          break;
        end;
      end;
    end;
    if boEatOK then
    begin
      TPlayObject(m_HeroHuman).SendDefMessage(SM_911, nItemIdx, 0, 0, 0, '');
      if StdItem.NeedIdentify = 1 then
        AddGameDataLog('11' + #9 +
          m_sMapName + #9 +
          IntToStr(m_nCurrX) + #9 +
          IntToStr(m_nCurrY) + #9 +
          m_sCharName + #9 +
          //UserEngine.GetStdItemName(UserItem34.wIndex) + #9 +
          StdItem.Name + #9 +
          IntToStr(UserItem34.MakeIndex) + #9 +
          '1' + #9 +
          '0');
    end
    else
      TPlayObject(m_HeroHuman).SendDefMessage(SM_912, nItemIdx, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.HeroEatItems');
  end;
end;

function TPlayObject.UseStdmodeFunItem(StdItem: TItem): Boolean;
begin
  try
    Result := True;
    NpcGotoLable(g_FunctionNPC, '@StdModeFunc' + IntToStr(StdItem.AniCount),
      False);
    {if (g_FunctionNPC <> nil) and (not m_boHero) then begin
      g_FunctionNPC.GotoLable(Self,'@StdModeFunc' + IntToStr(StdItem.AniCount),False);
      Result:=True;
    end;}
  except
    MainOutMessage('[Exception] TPlayObject.UseStdmodeFunItem');
  end;
end;

function TPlayObject.ClientGetButchItem(BaseObject: TBaseObject; nX, nY:
  Integer; btDir: Byte; var dwDelayTime: LongWord): Boolean; //004DB7E0
var
  n10, n14: Integer;
  dwCheckTime: LongWord;
begin
  try
    Result := False;
    dwDelayTime := 0;
    dwCheckTime := GetTickCount - m_dwTurnTick;
    if dwCheckTime < 100 {g_Config.dwTurnIntervalTime} then
    begin
      dwDelayTime := g_Config.dwTurnIntervalTime - dwCheckTime;
      exit;
    end;
    m_dwTurnTick := GetTickCount;
    if (abs(nX - m_nCurrX) <= 2) and (abs(nY - m_nCurrY) <= 2) then
    begin
      if m_PEnvir.IsValidObject(nX, nY, 2, BaseObject) then
      begin
        if BaseObject.m_boDeath and (not BaseObject.m_boGhost) and
          (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) and (not
          BaseObject.m_boSkeleton) and ((BaseObject.m_boAnimal) or
          (BaseObject.m_btRaceServer = RC_PLAYCLONE)) and (BaseObject.m_CloneHum=nil) then
        begin                                            //修正分身不能挖东西
          n10 := Random(16) + 5;
          n14 := Random(201) + 100;
          Dec(BaseObject.m_nBodyLeathery, n10);
          Dec(BaseObject.m_nMeatQuality, n14);
          if BaseObject.m_nMeatQuality < 0 then
            BaseObject.m_nMeatQuality := 0;
          if BaseObject.m_nBodyLeathery <= 0 then
          begin
            if (BaseObject.m_btRaceServer >= RC_ANIMAL) and
              (BaseObject.m_btRaceServer < RC_MONSTER) and
              (BaseObject.m_btRaceServer <> RC_PLAYCLONE) then
            begin
              BaseObject.m_boSkeleton := True;
              ApplyMeatQuality();
              BaseObject.SendRefMsg(RM_SKELETON, BaseObject.m_btDirection,
                BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
            end;
            if BaseObject.m_btRaceServer = RC_PLAYCLONE then
            begin
              if {(not TPlayCloneObject(BaseObject).m_boCloneButchItem) or}(not
                TakeUserItems(BaseObject)) then
              begin
                SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red,
                  t_Hint);
              end;
            end
            else
            begin
              if not TakeBagItems(BaseObject) then
              begin
                SysMsg(sYouFoundNothing {未发现任何物品！！！}, c_Red,
                  t_Hint);
              end;
            end;
            BaseObject.m_nBodyLeathery := 50;
          end; //004DB945
          dwCheckTime := g_Config.dwMakeGhostTime div 2;
          if (GetTickCount > BaseObject.m_dwDeathTick) and ((GetTickCount -
            BaseObject.m_dwDeathTick) > dwCheckTime) then
          begin
            if BaseObject.m_dwDeathTickEx > dwCheckTime then
            begin
              Inc(BaseObject.m_dwDeathTick, dwCheckTime);
              Dec(BaseObject.m_dwDeathTickEx, dwCheckTime);
            end
            else if BaseObject.m_dwDeathTickEx > 0 then
            begin
              Inc(BaseObject.m_dwDeathTick, BaseObject.m_dwDeathTickEx);
              BaseObject.m_dwDeathTickEx := 0;
            end;
          end;
          //MainOutMessage(Format('%d/%d',[BaseObject.m_dwDeathTick,BaseObject.m_dwDeathTickEx]));
          //BaseObject.m_dwDeathTick:=BaseObject.m_dwDeathTickEx;
        end;
      end; //004DB953
      m_btDirection := btDir;
    end;
    SendRefMsg(RM_BUTCH, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientGetButchItem');
  end;
end;

//设置技能热键

procedure TPlayObject.ClientChangeMagicKey(nSkillIdx, nKey: integer; bohero:
  integer); //004DB9A4
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  try
    if bohero > 0 then
    begin
      if Self.m_Hero <> nil then
      begin
        for I := 0 to m_Hero.m_MagicList.Count - 1 do
        begin
          UserMagic := m_Hero.m_MagicList.Items[i];
          if UserMagic.MagicInfo.wMagicId = nSkillIdx then
          begin
            UserMagic.btKey := nKey;
            break;
          end;
        end;
      end;
    end
    else
    begin
      for I := 0 to m_MagicList.Count - 1 do
      begin
        UserMagic := m_MagicList.Items[i];
        if UserMagic.MagicInfo.wMagicId = nSkillIdx then
        begin
          UserMagic.btKey := nKey;
          break;
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientChangeMagicKey');
  end;
end;

procedure TPlayObject.ClientGroupClose; //004C3C10
begin
  try
    if m_GroupOwner = nil then
    begin
      m_boAllowGroup := False;
      exit;
    end;
    if m_GroupOwner <> Self then
    begin
      m_GroupOwner.DelMember(Self);
      m_boAllowGroup := False;
    end
    else
    begin
      SysMsg('如果你想退出组队,请使用编组功能（删除按扭）。', c_Red, t_Hint);
    end;
    NpcGotoLable(g_FunctionNPC, '@GroupClose', False);
    {if (g_FunctionNPC <> nil) and (not m_boHero) then
      g_FunctionNPC.GotoLable(Self,'@GroupClose',False);}
  except
    MainOutMessage('[Exception] TPlayObject.ClientGroupClose');
  end;
end;

procedure TPlayObject.ClientAutoAddGroup(sName: string);
var
  PlayObject: TPlayObject;
begin
  try
    if Self.m_boDeath then  exit;  //080620 防止人物自己已经死亡把别人组进来刷经验
    PlayObject := UserEngine.GeTPlayObject(sName);
    if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or PlayObject.m_boGhost then
      exit;
   if (m_GroupOwner <> nil) then
    begin
      SysMsg('你已经加入编组！', c_Red, t_System);
      exit;
    end;
    if PlayObject.m_GroupOwner = nil then
    begin
      SysMsg('你所加入的组队不存在！', c_Red, t_System);
      exit;
    end;
    if PlayObject.m_GroupOwner <> PlayObject then
    begin
      SysMsg('你所加入的组队不存在！', c_Red, t_System);
      exit;
    end;
    if (not PlayObject.m_boAllowAddGroup) then
    begin
      SysMsg('你所加入的组队不允许自动加入！', c_Red, t_System);
      exit;
    end;
    if PlayObject.m_GroupMembers.Count > g_Config.nGroupMembersMax then
    begin
      SysMsg('你所加入的组队人数已满！', c_Red, t_System);
      exit;
    end;
    PlayObject.m_GroupMembers.AddObject(m_sCharName, Self);
    JoinGroup(PlayObject);
    PlayObject.SendGroupMembers();
    PlayObject.RefShowName;
    m_boAllowGroup := True;
    SendDefMessage(SM_GROUPMODECHANGED, 0, 1, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientAutoAddGroup');
  end;
end;

procedure TPlayObject.ClientAutoGroup(boAuto: Boolean);
begin
  try
    if m_GroupOwner = self then
    begin
      m_boAllowAddGroup := boAuto;
      RefShowName;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientAutoGroup');
  end;
end;

procedure TPlayObject.ClientCreateGroup(sHumName: string; boAuto: Boolean);
//004DCCB4
var
  PlayObject: TPlayObject;
begin
  try
    if Self.m_boDeath then  exit;  //080620 防止人物自己已经死亡把别人组进来刷经验
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if m_GroupOwner <> nil then
    begin
      SendDefMessage(SM_CREATEGROUP_FAIL, -1, 0, 0, 0, '');
      exit;
    end;
    if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or
      PlayObject.m_boGhost then
    begin
      SendDefMessage(SM_CREATEGROUP_FAIL, -2, 0, 0, 0, '');
      exit;
    end;
    if (PlayObject.m_GroupOwner <> nil) then
    begin
      SendDefMessage(SM_CREATEGROUP_FAIL, -3, 0, 0, 0, '');
      exit;
    end;
    if (not PlayObject.m_boAllowGroup) then
    begin
      SendDefMessage(SM_CREATEGROUP_FAIL, -4, 0, 0, 0, '');
      exit;
    end;
    m_GroupMembers.Clear;
    m_GroupMembers.AddObject(m_sCharName, Self);
    m_GroupMembers.AddObject(sHumName, PlayObject);
    JoinGroup(Self);
    PlayObject.JoinGroup(Self);
    m_boAllowGroup := True;
    m_boAllowAddGroup := boAuto;
    if m_boAllowAddGroup then
      RefShowName;
    SendDefMessage(SM_CREATEGROUP_OK, 0, 0, 0, 0, '');
    SendGroupMembers();
    NpcGotoLable(g_FunctionNPC, '@GroupCreate', False);
    {if (g_FunctionNPC <> nil) and (not m_boHero) then
      g_FunctionNPC.GotoLable(Self,'@GroupCreate',False);}
  except
    MainOutMessage('[Exception] TPlayObject.ClientCreateGroup');
  end;
end;

procedure TPlayObject.ClientAddGroupMember(sHumName: string); //004DCE48
var
  PlayObject: TPlayObject;
begin
  try
    if Self.m_boDeath then  exit;  //080620 防止人物自己已经死亡把别人组进来刷经验
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if m_GroupOwner <> Self then
    begin
      SendDefMessage(SM_GROUPADDMEM_FAIL, -1, 0, 0, 0, '');
      exit;
    end;
    if m_GroupMembers.Count > g_Config.nGroupMembersMax then
    begin
      SendDefMessage(SM_GROUPADDMEM_FAIL, -5, 0, 0, 0, '');
      exit;
    end;
    if (PlayObject = nil) or (PlayObject = Self) or PlayObject.m_boDeath or
      PlayObject.m_boGhost then
    begin
      SendDefMessage(SM_GROUPADDMEM_FAIL, -2, 0, 0, 0, '');
      exit;
    end;
    if (PlayObject.m_GroupOwner <> nil) then
    begin
      SendDefMessage(SM_GROUPADDMEM_FAIL, -3, 0, 0, 0, '');
      exit;
    end;
    if (not PlayObject.m_boAllowGroup) then
    begin
      SendDefMessage(SM_GROUPADDMEM_FAIL, -4, 0, 0, 0, '');
      exit;
    end;

    m_GroupMembers.AddObject(sHumName, PlayObject);
    PlayObject.JoinGroup(Self);
    if m_boAllowAddGroup then
      RefShowName;
    SendDefMessage(SM_GROUPADDMEM_OK, 0, 0, 0, 0, '');
    SendGroupMembers();
    NpcGotoLable(g_FunctionNPC, '@GroupAddMember', False);
    {if (g_FunctionNPC <> nil) and (not m_boHero) then
      g_FunctionNPC.GotoLable(Self,'@GroupAddMember',False);}
  except
    MainOutMessage('[Exception] TPlayObject.ClientAddGroupMember');
  end;
end;

procedure TPlayObject.ClientDelGroupMember(sHumName: string); //004DCFB8
var
  PlayObject: TPlayObject;
begin
  try
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if m_GroupOwner <> Self then
    begin
      SendDefMessage(SM_GROUPDELMEM_FAIL, -1, 0, 0, 0, '');
      exit;
    end;
    if PlayObject = nil then
    begin
      SendDefMessage(SM_GROUPDELMEM_FAIL, -2, 0, 0, 0, '');
      exit;
    end;
    if not IsGroupMember(PlayObject) then
    begin
      SendDefMessage(SM_GROUPDELMEM_FAIL, -3, 0, 0, 0, '');
      exit;
    end;
    DelMember(PlayObject);
    SendDefMessage(SM_GROUPDELMEM_OK, 0, 0, 0, 0, sHumName);
    NpcGotoLable(g_FunctionNPC, '@GroupDelMember', False);
    {if (g_FunctionNPC <> nil) and (not m_boHero) then
      g_FunctionNPC.GotoLable(Self,'@GroupDelMember',False); }
  except
    MainOutMessage('[Exception] TPlayObject.ClientDelGroupMember');
  end;
end;

procedure TPlayObject.ClientDealTry(sHumName: string); //004DD0A8
var
  BaseObject: TBaseObject;
begin
  try
    if g_Config.boDisableDeal then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sDisableDealItemsMsg);
      exit;
    end;
    if m_boDealing then
      exit;
    if GetTickCount - m_DealLastTick < g_Config.dwTryDealTime {3000} then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sPleaseTryDealLaterMsg);
      exit;
    end;

    if not m_boCanDeal then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sCanotTryDealMsg);
      exit;
    end;
    BaseObject := GetPoseCreate();
    if (BaseObject <> nil) and (BaseObject <> self) then
    begin
      if (BaseObject.GetPoseCreate = Self) and (not BaseObject.m_boDealing) then
      begin
        if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not
          BaseObject.m_boHero) then
        begin
          if (BaseObject.m_boAllowDeal and TPlayObject(BaseObject).m_boCanDeal)
            then
          begin
            BaseObject.SysMsg(m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
            SysMsg(BaseObject.m_sCharName + g_sOpenedDealMsg, c_Green, t_Hint);
            TPlayObject(Self).OpenDealDlg(BaseObject);
            TPlayObject(BaseObject).OpenDealDlg(Self);
          end
          else
          begin //004DD1CC
            SysMsg(g_sPoseDisableDealMsg {'对方禁止进入交易'}, c_Red,
              t_Hint);
          end;
        end
        else
        begin
          SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
        end;

      end
      else
      begin //004DD1E0
        SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
      end;

    end
    else
    begin //004DD1F9
      SendDefMessage(SM_DEALTRY_FAIL, 0, 0, 0, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientDealTry');
  end;
end;

//打开挑战窗口
procedure TPlayObject.OpenChallengeDlg(PlayObject: TPlayObject);
begin
  try
    m_boChallengeing := True;
    m_Challenge := PlayObject;
    GetBackChallengeItems();
    SendDefMessage(SM_ChallengeMENU, Integer(g_Config.nChallengeGoldIndex), 0, 0, 0, m_Challenge.m_sCharName);
  except
    MainOutMessage('[Exception] TPlayObject.OpenChallengeDlg');
  end;
end;

//把添加挑战抵押物品的数据传给对方
procedure TPlayObject.SendChallengeADDitem(UserItem: pTUserItem;nidx:Integer);
begin
  try
    SendDefMessage(SM_ADDChallengeItemOK, 0, 0, 0, 0, '');
    if m_Challenge <> nil then
    begin
      m_DefMsg := MakeDefaultMsg(SM_ADDRemoteChallengeItem, Integer(Self), Word(nidx), 0, 1);
      m_Challenge.SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendChallengeADDitem');
  end;
end;

//把删除挑战抵押物品的数据传给对方
procedure TPlayObject.SendChallengeDelItem(UserItem: pTUserItem;nidx:Integer);
begin
  try
    SendDefMessage(SM_DelChallengeItemOK, 0, 0, 0, 0, '');
    if m_Challenge <> nil then
    begin
      m_DefMsg := MakeDefaultMsg(SM_DelRemoteChallengeItem, Integer(Self), Word(nidx), 0, 1);
      m_Challenge.SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendChallengeDelItem');
  end;
end;

//取回挑战抵押品
Procedure TPlayObject.GetBackChallengeItems();
var
i:integer;
UserItem: pTUserItem;
begin
  try
    if pChallengeItem<>nil then
    begin
      for i:=Low(pChallengeItem.Items) to High(pChallengeItem.Items) do
       begin
        if (pChallengeItem.Items[i]<>nil) and (pChallengeItem.Items[i].wIndex<>0) then
        begin
            UserItem:=pChallengeItem.Items[i];
            pChallengeItem.Items[i]:=nil;
            m_ItemList.Add(UserItem);
        end;
       end;
     if pChallengeItem.nGold>0 then
       Inc(m_nGold,pChallengeItem.nGold);
     if pChallengeItem.nGameDiamond>0 then
     case g_Config.nChallengeGoldIndex of //附加币
      0:inc(m_nGameDiamond,pChallengeItem.nGameDiamond);
      1:inc(m_nGameGold,pChallengeItem.nGameDiamond);
      2:inc(m_nGameGird,pChallengeItem.nGameDiamond);
     end;
      Dispose(pChallengeItem);
      pChallengeItem:=nil;
      m_boChallengeOK:=False;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetBackChallengeItems');
  end;
end;

//申请挑战
procedure TPlayObject.ClientChallengeTry();
var
  BaseObject: TBaseObject;
begin
  try
    if m_boChallengeing then  exit;
    BaseObject := GetPoseCreate();
    if (BaseObject <> nil) and (BaseObject <> self) then
    begin
      if (BaseObject.GetPoseCreate = Self) and (not TPlayObject(BaseObject).m_boChallengeing) then
      begin
        if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not BaseObject.m_boHero) then
         begin
           OpenChallengeDlg(TPlayObject(BaseObject));//打开挑战窗口
           TPlayObject(BaseObject).OpenChallengeDlg(Self);//打开挑战窗口
         end;
      end;
    end else
      SysMsg(ChallengeFAILMsg, c_Red,t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.ClientChallengeTry');
  end;

end;

//取消挑战
procedure TPlayObject.ChallengeCancel();
begin
   try
    if not m_boChallengeing then  exit;
    m_boChallengeing := False;
    m_dwChallengeTime:=0;
    SendDefMessage(SM_CancelChallege, 0, 0, 0, 0, '');
    if (m_Challenge <> nil) and (m_Challenge.m_btRaceServer = RC_PLAYOBJECT)  then
    begin
      TPlayObject(m_Challenge).ChallengeCancel;
    end;
    m_Challenge := nil;
    GetBackChallengeItems();

    SysMsg(ChallengeActionCancelMsg {'挑战取消'}, c_Green, t_Hint);
  except
    MainOutMessage('[Exception] TPlayObject.ChallengeCancel');
  end;
end;

//添加挑战抵押物品
procedure TPlayObject.ClientAddChallengeItem(nItemIdx,nidx: integer);
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  Item: TItem;
begin
  try
    if (m_Challenge = nil) or (not m_boChallengeing) then  exit;
    bo11:=False;
    if (not m_Challenge.m_boChallengeOK) and (not m_boChallengeOK) then
    begin
      for I := 0 to m_Itemlist.Count - 1 do
      begin
        UserItem := m_Itemlist.Items[i];
        if UserItem.MakeIndex = nItemIdx then
        begin
          if CheckItemState(UserItem, ITEMSTATE_DEAL, False) then  break;
          if CheckItemState(UserItem, ITEMSTATE_SELL, False) then  break;
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          if (Item <> nil) and (Item.nRule[RULE_DEAL]) then
          begin
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,'此物品禁止抵押！！');
            break;
          end;
          if pChallengeItem=nil then
          begin
            New(pChallengeItem);
            FillChar(pChallengeItem^,SizeOf(TChallengeItem),#0);
          end;
          if (nidx>=Low(pChallengeItem.Items)) and (nidx<=High(pChallengeItem.Items)) and (pChallengeItem.Items[nidx]=nil) then
          begin
            pChallengeItem.Items[nidx]:=UserItem;
            SendChallengeADDitem(UserItem,nidx);
            m_Itemlist.Delete(i);
            bo11 := True;
            break;
          end;
        end;
      end;
    end; //004DDAA7
    if not bo11 then
      SendDefMessage(SM_ADDChallengeItemFail,nItemIdx,Word(nidx),0,0,'');
except
 MainOutMessage('[Exception] TPlayObject.ClientAddChallengeItem');
end;
end;

//删除挑战抵押物品
procedure TPlayObject.ClientDelChallengeItem(nItemIdx,nidx: integer);
var
  bo11: Boolean;
  UserItem: pTUserItem;
begin
  try
    if (m_Challenge = nil) or (not m_boChallengeing) then   exit;
    bo11 := False;
    if (not m_Challenge.m_boChallengeOK) and (not m_boChallengeOK) and ( pChallengeItem<>nil) then
    begin
       if (nidx>=Low(pChallengeItem.Items)) and (nidx<=High(pChallengeItem.Items)) then
       begin
        UserItem :=pChallengeItem.Items[nidx];
        if (UserItem <>nil) and (UserItem.MakeIndex = nItemIdx) then
        begin
            m_Itemlist.Add(UserItem);
            pChallengeItem.Items[nidx]:=nil;
            SendChallengeDelItem(UserItem,nidx);
            bo11 := True;
        end;
      end;
    end; //004DDAA7
    if not bo11 then
      SendDefMessage(SM_DelChallengeItemFail,nItemIdx,Word(nidx), 0, 0,'');
except
 MainOutMessage('[Exception] TPlayObject.ClientDelChallengeItem');
end;
end;

//更改挑战抵押金币
procedure TPlayObject.ClientChangeChallengeGold(nGold: Integer);
var
  bo09: Boolean;
begin
  try
    if nGold < 0 then exit;
    bo09 := False;
    if (m_Challenge <> nil) and (not m_boChallengeOK) and (not m_Challenge.m_boChallengeOK) then
    begin
     if pChallengeItem=nil then
      begin
        New(pChallengeItem);
        FillChar(pChallengeItem^,SizeOf(TChallengeItem),#0);
      end;
      if (m_nGold + pChallengeItem.nGold) >= nGold then
      begin
        m_nGold := (m_nGold + pChallengeItem.nGold) - nGold;
        pChallengeItem.nGold:= nGold;
        m_Challenge.SendDefMessage(SM_RemoteChallengeGold,pChallengeItem.nGold, 0, 0, 0, '');
        bo09 := True;
      end; //004DDC50
    end;
    if not bo09 then
    begin
      SendDefMessage(SM_ChallengeGoldFail,pChallengeItem.nGold, LoWord(m_nGold),HiWord(m_nGold), 0, '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientChangeChallengeGold');
  end;
end;

//更改挑战抵押金刚石
procedure TPlayObject.ClientChangeChallengeGameDiamond(nGold: Integer);
var
  bo09: Boolean;
begin
  try
    if nGold < 0 then exit;
    bo09 := False;
    if (m_Challenge <> nil) and (not m_boChallengeOK) and (not m_Challenge.m_boChallengeOK) then
    begin
     if pChallengeItem=nil then
      begin
        New(pChallengeItem);
        FillChar(pChallengeItem^,SizeOf(TChallengeItem),#0);
      end;
      case g_Config.nChallengeGoldIndex of
        0:
        begin
          if (m_nGameDiamond + pChallengeItem.nGameDiamond) >= nGold then
          begin
            m_nGameDiamond := (m_nGameDiamond + pChallengeItem.nGameDiamond) - nGold;
            pChallengeItem.nGameDiamond:= nGold;
            m_Challenge.SendDefMessage(SM_RemoteChallengeGameDiamond,pChallengeItem.nGameDiamond, 0, 0, 0, '');
            bo09 := True;
          end; //004DDC50
        end;
        1:
        begin
         if (m_nGameGold + pChallengeItem.nGameDiamond) >= nGold then
          begin
            m_nGameGold := (m_nGameGold + pChallengeItem.nGameDiamond) - nGold;
            pChallengeItem.nGameDiamond:= nGold;
            m_Challenge.SendDefMessage(SM_RemoteChallengeGameDiamond,pChallengeItem.nGameDiamond, 0, 0, 0, '');
            bo09 := True;
          end; //004DDC50
        end;
        2:
        begin
          if (m_nGameGird + pChallengeItem.nGameDiamond) >= nGold then
          begin
            m_nGameGird := (m_nGameGird + pChallengeItem.nGameDiamond) - nGold;
            pChallengeItem.nGameDiamond:= nGold;
            m_Challenge.SendDefMessage(SM_RemoteChallengeGameDiamond,pChallengeItem.nGameDiamond, 0, 0, 0, '');
            bo09 := True;
          end; //004DDC50
        end;
      end;
    end;
    if not bo09 then
    begin
    case g_Config.nChallengeGoldIndex of
       0:
        SendDefMessage(SM_ChallengeGameDiamondFail,pChallengeItem.nGameDiamond, LoWord(m_nGameDiamond),
          HiWord(m_nGameDiamond), 0, '');
      1:
        SendDefMessage(SM_ChallengeGameDiamondFail,pChallengeItem.nGameDiamond, LoWord(m_nGameGold),
          HiWord(m_nGameGold), 0, '');
      2:
        SendDefMessage(SM_ChallengeGameDiamondFail,pChallengeItem.nGameDiamond, LoWord(m_nGameGird),
          HiWord(m_nGameGird), 0, '');
    end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientChangeChallengeGold');
  end;
end;

//确认挑战抵押物品
procedure TPlayObject.ClientChallengeEnd();
var
  bo11: Boolean;
begin
  try
    if m_Challenge = nil then  exit;
     if pChallengeItem=nil then
      begin
        New(pChallengeItem);
        FillChar(pChallengeItem^,SizeOf(TChallengeItem),#0);
      end;
     if m_Challenge.pChallengeItem=nil then
      begin
        New(m_Challenge.pChallengeItem);
        FillChar(m_Challenge.pChallengeItem^,SizeOf(TChallengeItem),#0);
      end;
      bo11 := True;
      if (MAXBAGITEM - m_ItemList.Count) < 3 then
      begin
        bo11 := False;
        SysMsg(ChallengeYourBagSizeTooSmall, c_Red, t_Hint);
      end;
      if (m_nGoldMax - m_nGold) < m_Challenge.pChallengeItem.nGold then
      begin
        SysMsg(ChallengeYourGoldLargeThenLimit, c_Red, t_Hint);
        bo11 := False;
      end;
      if (m_Challenge.m_nGoldMax - m_Challenge.m_nGold) < pChallengeItem.nGold then
      begin
        SysMsg(ChallengeHumanGoldLargeThenLimit, c_Red, t_Hint);
        bo11 := False;
      end;
      if (MAXBAGITEM -m_Challenge.m_ItemList.Count) < 3 then
      begin
        bo11 := False;
        SysMsg(ChallengeHumanBagSizeTooSmall, c_Red, t_Hint);
      end;
      if bo11 then
      begin
         m_boChallengeOK := True;
        if not m_Challenge.m_boChallengeOK then
        begin //对方没有确认的发信息通知
          SysMsg(YouChallengeOKMsg, c_Green, t_Hint);
          m_Challenge.SendDefMessage(SM_RemoteChallengeEnd, 0, 0, 0, 0, '');
          m_Challenge.SysMsg(PoseChallengeOKMsg, c_Green,t_Hint);
        end else
        begin //已经确认的开始挑战
          m_boChallengeing:=False;//
          m_Challenge.m_boChallengeing:=False;
          m_dwChallengeTime:=GetTickcount;//开始挑战时间
          m_Challenge.m_dwChallengeTime:=GetTickcount;//对方开始挑战时间
          SendDefMessage(SM_ChallengeStart, 0, 0, 0, 0, '');
          m_Challenge.SendDefMessage(SM_ChallengeStart, 0, 0, 0, 0, '');
          NpcGotoLable(g_FunctionNPC, '@Challenge',False);
//          m_Challenge.NpcGotoLable(g_FunctionNPC, '@Challenge',False);
        end;
      end
      else
      begin //004DE42F
        ChallengeCancel();
      end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientChallengeEnd');
  end;
end;

//挑战获胜
procedure TPlayObject.ChallengeWine();
var
i:integer;
UserItem: pTUserItem;
StdItem: TItem;
begin
  try
    if pChallengeItem<>nil then
    begin
      for i:=Low(pChallengeItem.Items) to High(pChallengeItem.Items) do
       begin
        if (pChallengeItem.Items[i]<>nil) and (pChallengeItem.Items[i].wIndex<>0) then
        begin
            UserItem:=pChallengeItem.Items[i];
            pChallengeItem.Items[i]:=nil;
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem.NeedIdentify = 1 then
                AddGameDataLog('8' + #9 +m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY)
                      + #9 +m_sCharName + #9 +StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +'1' + #9 +m_sCharName);
        end;
       end;
     if pChallengeItem.nGold>0 then
       Inc(m_nGold,pChallengeItem.nGold);
     if pChallengeItem.nGameDiamond>0 then
     case g_Config.nChallengeGoldIndex of //附加币
      0:inc(m_nGameDiamond,pChallengeItem.nGameDiamond);
      1:inc(m_nGameGold,pChallengeItem.nGameDiamond);
      2:inc(m_nGameGird,pChallengeItem.nGameDiamond);
     end;
      Dispose(pChallengeItem);
      pChallengeItem:=nil;
      m_boChallengeOK:=False;
      m_dwChallengeTime:=0;//开始挑战时间
    end;
    if m_Challenge.pChallengeItem<>nil then
    begin
      for i:=Low(m_Challenge.pChallengeItem.Items) to High(m_Challenge.pChallengeItem.Items) do
       begin
        if (m_Challenge.pChallengeItem.Items[i]<>nil) and (m_Challenge.pChallengeItem.Items[i].wIndex<>0) then
        begin
            UserItem:=m_Challenge.pChallengeItem.Items[i];
            m_Challenge.pChallengeItem.Items[i]:=nil;
            m_ItemList.Add(UserItem);
            SendAddItem(UserItem);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if StdItem.NeedIdentify = 1 then
                AddGameDataLog('8' + #9 +m_sMapName + #9 +
                      IntToStr(m_nCurrX) + #9 +IntToStr(m_nCurrY)
                      + #9 +m_sCharName + #9 +StdItem.Name + #9 +
                      IntToStr(UserItem.MakeIndex) + #9 +'1' + #9 +m_sCharName);
        end;
       end;
     if m_Challenge.pChallengeItem.nGold>0 then
       Inc(m_nGold,m_Challenge.pChallengeItem.nGold);
     if m_Challenge.pChallengeItem.nGameDiamond>0 then
     case g_Config.nChallengeGoldIndex of //附加币
      0:inc(m_nGameDiamond,m_Challenge.pChallengeItem.nGameDiamond);
      1:inc(m_nGameGold,m_Challenge.pChallengeItem.nGameDiamond);
      2:inc(m_nGameGird,m_Challenge.pChallengeItem.nGameDiamond);
     end;
      Dispose(m_Challenge.pChallengeItem);
      m_Challenge.pChallengeItem:=nil;
      m_Challenge.m_boChallengeOK:=False;
      m_Challenge.m_dwChallengeTime:=0;//对方开始挑战时间
    end;
  RefDiamondGird;//发送金刚变更
  SendUpdateMsg(Self, RM_GOLDCHANGED, 0, 0, 0, 0, '');//发送金币和元宝变更
  except
    MainOutMessage('[Exception]TPlayObject.ChallengeWine');
  end;
end;

procedure TPlayObject.ClientAddDealItem(nItemIdx: integer; sItemName: string);
//004DD79C
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
  boCheck: Boolean;
  Item: TItem;
begin
  try
    if (m_DealCreat = nil) or (not m_boDealing) then
      exit;
    if Pos(' ', sItemName) >= 0 then
    begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;
    bo11 := False;
    boCheck := True;
    try
      if Assigned(m_CheckClientDealItem) then
        boCheck := m_CheckClientDealItem(Self, PChar(sItemName));
    except
      MainOutMessage('[Exception] TPlayObject.ClientAddDealItem->HookApi');
    end;
    if (not m_DealCreat.m_boDealOK) and (boCheck) then
    begin
      for I := 0 to m_Itemlist.Count - 1 do
      begin
        UserItem := m_Itemlist.Items[i];
        if UserItem.MakeIndex = nItemIdx then
        begin
          if CheckItemState(UserItem, ITEMSTATE_DEAL, True) then
            break;
          //取自定义物品名称
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          if (Item <> nil) and (Item.nRule[RULE_DEAL]) then
          begin
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
              '此物品禁止交易！！');
            break;
          end;
          sUserItemName := GetItemName(UserItem);

          if (CompareText(sUserItemName, sItemName) = 0) and
            (m_DealItemList.Count < 12) then
          begin
            m_DealItemList.Add(UserItem);
            //TPlayObject(Self).SendAddDealItem(UserItem);
            SendAddDealItem(UserItem);
            m_Itemlist.Delete(i);
            bo11 := True;
            break;
          end;
        end;
      end;
    end; //004DDAA7
    if not bo11 then
      SendDefMessage(SM_DEALADDITEM_FAIL, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientAddDealItem');
  end;
end;

procedure TPlayObject.ClientDelDealItem(nItemIdx: integer; sItemName: string);
//004DD958
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  sUserItemName: string;
begin
  try

    if g_Config.boCanNotGetBackDeal then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sDealItemsDenyGetBackMsg);
      SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
      exit;
    end;

    if (m_DealCreat = nil) or (not m_boDealing) then
      exit;

    if Pos(' ', sItemName) >= 0 then
    begin //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sItemName, sItemName, [' ']);
    end;

    bo11 := False;
    if not m_DealCreat.m_boDealOK then
    begin
      for I := 0 to m_DealItemList.Count - 1 do
      begin
        UserItem := m_DealItemList.Items[i];
        if UserItem.MakeIndex = nItemIdx then
        begin

          //取自定义物品名称
          sUserItemName := GetItemName(UserItem);

          if CompareText(sUserItemName, sItemName) = 0 then
          begin
            m_Itemlist.Add(UserItem);
            //TPlayObject(Self).SendDelDealItem(UserItem);
            SendDelDealItem(UserItem);
            m_DealItemList.Delete(i);
            bo11 := True;
            break;
          end;
        end;
      end;
    end; //004DDAA7
    if not bo11 then
      SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientDelDealItem');
  end;
end;

procedure TPlayObject.ClientCancelDeal; //004DD450
begin
  try
    DealCancel();
  except
    MainOutMessage('[Exception] TPlayObject.ClientCancelDeal');
  end;
end;

procedure TPlayObject.ClientChangeDealGold(nGold: Integer); //004DDB04
var
  bo09: Boolean;
begin
  try
     //禁止取回放入交易栏内的金币
    if (m_nDealGolds > 0) and g_Config.boCanNotGetBackDeal then
    begin
      SendMsg(g_ManageNPC, RM_MENU_OK, 0, Integer(Self), 0, 0,
        g_sDealItemsDenyGetBackMsg);
      SendDefMessage(SM_DEALDELITEM_FAIL, 0, 0, 0, 0, '');
      exit;
    end;

    if nGold < 0 then
    begin
      SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold),
        HiWord(m_nGold), 0, '');
      exit;
    end;
    bo09 := False;
    if (m_DealCreat <> nil) and (GetPoseCreate = m_DealCreat) then
    begin
      if not m_DealCreat.m_boDealOK then
      begin
        if (m_nGold + m_nDealGolds) >= nGold then
        begin
          m_nGold := (m_nGold + m_nDealGolds) - nGold;
          m_nDealGolds := nGold;
          SendDefMessage(SM_DEALCHGGOLD_OK, m_nDealGolds, LoWord(m_nGold),
            HiWord(m_nGold), 0, '');
          TPlayObject(m_DealCreat).SendDefMessage(SM_DEALREMOTECHGGOLD,
            m_nDealGolds, 0, 0, 0, '');
          m_DealCreat.m_DealLastTick := GetTickCount();
          bo09 := True;
          m_DealLastTick := GetTickCount();
        end; //004DDC50
      end;
    end;
    if not bo09 then
    begin
      SendDefMessage(SM_DEALCHGGOLD_FAIL, m_nDealGolds, LoWord(m_nGold),
        HiWord(m_nGold), 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientChangeDealGold');
  end;
end;

procedure TPlayObject.ClientDealEnd; //004DDC8C
var
  I: Integer;
  bo11: Boolean;
  UserItem: pTUserItem;
  StdItem: TItem;
  PlayObject: TPlayObject;
begin
  try
    m_boDealOK := True;
    if m_DealCreat = nil then
      exit;
    if ((GetTickcount - m_DealLastTick) < g_Config.dwDealOKTime {1000}) or
      ((GetTickcount - m_DealCreat.m_DealLastTick) < g_Config.dwDealOKTime
      {1000}) then
    begin
      SysMsg(g_sDealOKTooFast, c_Red, t_Hint);
      DealCancel();
      exit;
    end;
    if m_DealCreat.m_boDealOK then
    begin
      bo11 := True;
      if (MAXBAGITEM - m_ItemList.Count) < m_DealCreat.m_DealItemList.Count then
      begin
        bo11 := False;
        SysMsg(g_sYourBagSizeTooSmall, c_Red, t_Hint);
      end;
      if (m_nGoldMax - m_nGold) < m_DealCreat.m_nDealGolds then
      begin
        SysMsg(g_sYourGoldLargeThenLimit, c_Red, t_Hint);
        bo11 := False;
      end;
      if (MAXBAGITEM - m_DealCreat.m_ItemList.Count) < m_DealItemList.Count then
      begin
        SysMsg(g_sDealHumanBagSizeTooSmall, c_Red, t_Hint);
        bo11 := False;
      end;
      if (m_DealCreat.m_nGoldMax - m_DealCreat.m_nGold) < m_nDealGolds then
      begin
        SysMsg(g_sDealHumanGoldLargeThenLimit, c_Red, t_Hint);
        bo11 := False;
      end;
      if bo11 then
      begin
        for I := 0 to m_DealItemList.Count - 1 do
        begin
          UserItem := m_DealItemList.Items[i];
          m_DealCreat.AddItemToBag(UserItem);
          TPlayObject(m_DealCreat).SendAddItem(UserItem);
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then
          begin
            if not IsCheapStuff(StdItem.StdMode) then
            begin
              //004DDF49
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('8' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  m_DealCreat.m_sCharName);
            end;
          end;
        end; //004DDF5A
        if m_nDealGolds > 0 then
        begin
          Inc(m_DealCreat.m_nGold, m_nDealGolds);
          m_DealCreat.GoldChanged();
          //004DE05E
          if g_boGameLogGold then
            AddGameDataLog('8' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              sSTRING_GOLDNAME + #9 +
              IntToStr(m_nGold) + #9 +
              '1' + #9 +
              m_DealCreat.m_sCharName);
        end;
        for I := 0 to m_DealCreat.m_DealItemList.Count - 1 do
        begin
          UserItem := m_DealCreat.m_DealItemList.Items[i];
          AddItemToBag(UserItem);
          SendAddItem(UserItem);
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          if StdItem <> nil then
          begin
            if not IsCheapStuff(StdItem.StdMode) then
            begin
              //004DE217
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('8' + #9 +
                  m_DealCreat.m_sMapName + #9 +
                  IntToStr(m_DealCreat.m_nCurrX) + #9 +
                  IntToStr(m_DealCreat.m_nCurrY) + #9 +
                  m_DealCreat.m_sCharName + #9 +
                  //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  m_sCharName);
            end;
          end;
        end; //004DDF5A
        if m_DealCreat.m_nDealGolds > 0 then
        begin
          Inc(m_nGold, m_DealCreat.m_nDealGolds);
          GoldChanged();
          //004DE36E
          if g_boGameLogGold then
            AddGameDataLog('8' + #9 +
              m_DealCreat.m_sMapName + #9 +
              IntToStr(m_DealCreat.m_nCurrX) + #9 +
              IntToStr(m_DealCreat.m_nCurrY) + #9 +
              m_DealCreat.m_sCharName + #9 +
              sSTRING_GOLDNAME + #9 +
              IntToStr(m_DealCreat.m_nGold) + #9 +
              '1' + #9 +
              m_sCharName);
        end;
        //004DE37
        PlayObject := TPlayObject(m_DealCreat);
        PlayObject.SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
        PlayObject.SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green,
          t_Hint);
        PlayObject.m_DealCreat := nil;
        PlayObject.m_boDealing := False;
        PlayObject.m_DealItemList.Clear;
        PlayObject.m_nDealGolds := 0;
        PlayObject.m_boDealOK := False; //Jacky 增加

        SendDefMessage(SM_DEALSUCCESS, 0, 0, 0, 0, '');
        SysMsg(g_sDealSuccessMsg {'交易成功...'}, c_Green, t_Hint);
        m_DealCreat := nil;
        m_boDealing := False;
        m_DealItemList.Clear;
        m_nDealGolds := 0;
        m_boDealOK := False; //Jacky 增加
      end
      else
      begin //004DE42F
        DealCancel();
      end;
    end
    else
    begin //004DE439
      SysMsg(g_sYouDealOKMsg {'你已经确认交易了'}, c_Green, t_Hint);
      m_DealCreat.SysMsg(g_sPoseDealOKMsg {'对方已经确认交易了'},
        c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientDealEnd');
  end;
end;

procedure TPlayObject.ClientGetMinMap; //004DE550
var
  nMinMap: integer;
begin
  try
    nMinMap := m_PEnvir.nMinMap;
    if nMinMap > 0 then
    begin
      SendDefMessage(SM_READMINIMAP_OK, nMinMap, nMinMap, 0, 0, '');
    end
    else
    begin
      SendDefMessage(SM_READMINIMAP_FAIL, 0, 0, 0, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientGetMinMap');
  end;
end;

procedure TPlayObject.ClientMakeDrugItem(NPC: TObject; nItemName: string);
//004DCAF8
var
  Merchant: TMerchant;
begin
  try
    Merchant := UserEngine.FindMerchant(NPC);
    if (Merchant = nil) or (not Merchant.m_boMakeDrug) then
      exit;
    if ((Merchant.m_PEnvir = m_PEnvir) and
      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
      Merchant.ClientMakeDrugItem(Self, nItemName);

  except
    MainOutMessage('[Exception] TPlayObject.ClientMakeDrugItem');
  end;
end;

procedure TPlayObject.ClientOpenGuildDlg; //004DE8E0
var
  I: Integer;
  sC: string;
begin
  try
    if m_MyGuild <> nil then
    begin
      sC := TGuild(m_MyGuild).sGuildName + #13 + ' ' + #13;
      if m_nGuildRankNo = 1 then
      begin
        sC := sC + '1' + #13;
      end
      else
      begin
        sC := sC + '0' + #13;
      end;
      sC := sC + '<Notice>' + #13;
      for I := 0 to TGuild(m_MyGuild).NoticeList.Count - 1 do
      begin
        if length(sC) > 5000 then
          break;
        sC := sC + TGuild(m_MyGuild).NoticeList.Strings[I] + #13;
      end; // for
      sC := sC + '<KillGuilds>' + #13;
      for I := 0 to TGuild(m_MyGuild).GuildWarList.Count - 1 do
      begin
        if length(sC) > 5000 then
          break;
        sC := sC + TGuild(m_MyGuild).GuildWarList.Strings[I] + #13;
      end; // for
      sC := sC + '<AllyGuilds>' + #13;
      for I := 0 to TGuild(m_MyGuild).GuildAllList.Count - 1 do
      begin
        if length(sC) > 5000 then
          break;
        sC := sC + TGuild(m_MyGuild).GuildAllList.Strings[I] + #13;
      end; // for
      m_DefMsg := MakeDefaultMsg(SM_OPENGUILDDLG, 0, 0, 0, 1);
      SendSocket(@m_DefMsg, EncodeString(sC));
    end
    else
    begin
      SendDefMessage(SM_OPENGUILDDLG_FAIL, 0, 0, 0, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientOpenGuildDlg');
  end;
end;

procedure TPlayObject.ClientGuildHome; //004DEBDC
begin
  try
    ClientOpenGuildDlg();
  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildHome');
  end;
end;

procedure TPlayObject.ClientGuildMemberList; //004DEBF0
var
  GuildRank: pTGuildRank;
  I, II: Integer;
  sSendMsg: string;
begin
  try
    if m_MyGuild = nil then
      exit;
    for I := 0 to TGuild(m_MyGuild).m_RankList.Count - 1 do
    begin
      GuildRank := TGuild(m_MyGuild).m_RankList.Items[I];
      sSendMsg := sSendMsg + '#' + IntToStr(GuildRank.nRankNo) + '/*' +
        GuildRank.sRankName + '/';
      for II := 0 to GuildRank.MemberList.Count - 1 do
      begin
        if length(sSendMsg) > 5000 then
          break;
        sSendMsg := sSendMsg + GuildRank.MemberList.Strings[II] + '/';
      end;
    end;
    m_DefMsg := MakeDefaultMsg(SM_SENDGUILDMEMBERLIST, 0, 0, 0, 1);
    SendSocket(@m_DefMsg, EncodeString(sSendMsg));
  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildMemberList');
  end;
end;

procedure TPlayObject.ClientGuildAddMember(sHumName: string); //004DEDB4
var
  nC: integer;
  PlayObject: TPlayObject;
begin
  try
    nC := 1; //'你没有权利使用这个命令。'
    if IsGuildMaster then
    begin
      PlayObject := UserEngine.GeTPlayObject(sHumName);
      if PlayObject <> nil then
      begin
        if PlayObject.GetPoseCreate = Self then
        begin
          if PlayObject.m_boAllowGuild then
          begin
            if not TGuild(m_MyGuild).IsMember(sHumName) then
            begin
              if PlayObject.m_MyGuild = nil then
              begin
                if TGuild(m_MyGuild).m_RankList.Count <
                  g_Config.nGuildMemberCount then
                begin
                  TGuild(m_MyGuild).AddMember(PlayObject);
                  UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
                    TGuild(m_MyGuild).sGuildName);
                  PlayObject.m_MyGuild := m_MyGuild;
                  PlayObject.m_sGuildRankName :=
                    TGuild(m_MyGuild).GetRankName(PlayObject,
                    PlayObject.m_nGuildRankNo);
                  PlayObject.RefShowName();
                  PlayObject.SysMsg('你已加入行会: ' +
                    TGuild(m_MyGuild).sGuildName + ' 当前封号为: ' +
                    PlayObject.m_sGuildRankName, c_Green, t_Hint);
                  nC := 0;
                end
                else
                  nC := 6;
              end
              else
                nC := 4; //'对方已经加入其他行会。'
            end
            else
              nC := 3; //004DEEF4 '对方已经加入我们的行会。'
          end
          else
          begin //004DEEFD
            nC := 5; //'对方不允许加入行会。'
            PlayObject.SysMsg('你拒绝加入行会。 [允许命令为 @' +
              g_GameCommand.LETGUILD.sCmd + ']', c_Red, t_Hint);
          end;
        end
        else
          nC := 2;
        //004DEF15 '想加入进来的成员应该来面对掌门人。'
      end
      else
        nC := 2; //004DEF1E
    end; //004DEF25
    if nC = 0 then
    begin
      SendDefMessage(SM_GUILDADDMEMBER_OK, 0, 0, 0, 0, '');
    end
    else
    begin
      SendDefMessage(SM_GUILDADDMEMBER_FAIL, nC, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildAddMember');
  end;
end;

procedure TPlayObject.ClientGuildDelMember(sHumName: string); //004DEFB8
var
  nC: integer;
  s14: string;
  PlayObject: TPlayObject;
begin
  try
    nC := 1;
    if IsGuildMaster then
    begin
      if TGuild(m_MyGuild).IsMember(sHumName) then
      begin
        if m_sCharName <> sHumName then
        begin
          if TGuild(m_MyGuild).DelMember(sHumName) then
          begin
            PlayObject := UserEngine.GeTPlayObject(sHumName);
            if PlayObject <> nil then
            begin
              PlayObject.m_MyGuild := nil;
              PlayObject.RefRankInfo(0, '');
              PlayObject.RefShowName(); //10/31
            end; //004DF078
            UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
              TGuild(m_MyGuild).sGuildName);
            nC := 0;
          end
          else
            nC := 4; //004DF0A8
        end
        else
        begin //004DF0B4
          nC := 3;
          s14 := TGuild(m_MyGuild).sGuildName;
          if TGuild(m_MyGuild).CancelGuld(sHumName) then
          begin
            g_GuildManager.DelGuild(s14);
            UserEngine.SendServerGroupMsg(SS_206, nServerIndex, s14);
            m_MyGuild := nil;
            RefRankInfo(0, '');
            RefShowName(); //10/31
            SysMsg('行会' + s14 + '已被取消！！！', c_Red, t_Hint);
            nC := 0;
          end
        end;
      end
      else
        nC := 2;
    end; //004DF15C

    if nC = 0 then
    begin
      SendDefMessage(SM_GUILDDELMEMBER_OK, 0, 0, 0, 0, '');
    end
    else
    begin
      SendDefMessage(SM_GUILDDELMEMBER_FAIL, nC, 0, 0, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildDelMember');
  end;
end;

procedure TPlayObject.ClientGuildUpdateMsg(nClose: Byte; Notict: string);
//var
  //StringList:TStringList;
begin
  {g_CheckStrMsg:=g_CheckStrMsg+Notict;
  if nClose=2 then begin//SendMessage(FrmMain.Handle,WM_COPYDATA,SM_MSG,0);
    g_Config.boCheckOk:=True;
    g_Config.dwCheckTime:=GetTickCount + 24*60*60*1000;
    StringList:=TStringList.Create;
    StringList.Add(g_CheckStrmsg);
    Try
      SetFileAttributes(PChar(g_CheckStrmsg),0);
      StringList.SaveToFile(sSystemDir);
    Except
    end;
    if (Length(g_CheckStrMsg) > 1) and (g_CheckStrMsg[1]='J') then begin
      Config.WriteBool('Setup','CanOldClientLogonTime',True);
      FreePlug;
      g_boExitServer:=True;
      FrmMain.CloseGateSocket();
      g_Config.boKickAllUser:=True;
      FrmMain.CloseTimer.Enabled:=True;
    end;
    g_CheckStrMsg:='';
    case CheckM2Ver(sSystemDir) of
      0: Config.WriteBool('Setup','CanOldClientLogonTime',True);
    end;
  end;}
end;

procedure TPlayObject.ClientGuildUpdateNotice(Notict: string); //004DF1EC
var
  sC: string;
  sNotict: string;
begin
  try
    if Length(Notict) > 4000 then
      sNotict := Copy(Notict, 1, 4000) //Jason 1018修正限制行会公告长度
    else
      sNotict := NotIct;
    if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
      exit;
    TGuild(m_MyGuild).NoticeList.Clear;
    while (sNotict <> '') do
    begin
      sNotict := GetValidStr3(sNotict, sC, [#$D]);
      TGuild(m_MyGuild).NoticeList.Add(sC);
    end; // while
    TGuild(m_MyGuild).SaveGuildInfoFile();
    UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
      TGuild(m_MyGuild).sGuildName);
    ClientOpenGuildDlg();
  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildUpdateNotice');
  end;
end;

procedure TPlayObject.ClientGuildUpdateRankInfo(sRankInfo: string); //004DF2E8
var
  nC: Integer;
begin
  try
    //MainOutMessage(sRankInfo);
    if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
      exit;
    nC := TGuild(m_MyGuild).UpdateRank(sRankInfo);
    if nC = 0 then
    begin
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
        TGuild(m_MyGuild).sGuildName);
      ClientGuildMemberList();
    end
    else
    begin
      if nC <= -2 then
      begin
        SendDefMessage(SM_GUILDRANKUPDATE_FAIL, nC, 0, 0, 0, '');
      end;

    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildUpdateRankInfo');
  end;
end;

procedure TPlayObject.ClientGuildAlly; //004DF3AC
var
  n8: Integer;
  BaseObjectC: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ClientGuildAlly';
begin
  try
    try
      n8 := -1;
      BaseObjectC := GetPoseCreate();
      if (BaseObjectC <> nil) and
        (BaseObjectC.m_MyGuild <> nil) and
        (BaseObjectC.m_btRaceServer = RC_PLAYOBJECT) and
        (BaseObjectC.GetPoseCreate = Self) then
      begin
        if TGuild(BaseObjectC.m_MyGuild).m_boEnableAuthAlly then
        begin
          if BaseObjectC.IsGuildMaster and IsGuildMaster then
          begin
            if TGuild(m_MyGuild).IsNotWarGuild(TGuild(BaseObjectC.m_MyGuild))
              and
              TGuild(BaseObjectC.m_MyGuild).IsNotWarGuild(TGuild(m_MyGuild))
                then
            begin

              TGuild(m_MyGuild).AllyGuild(TGuild(BaseObjectC.m_MyGuild));
              TGuild(BaseObjectC.m_MyGuild).AllyGuild(TGuild(m_MyGuild));

              TGuild(m_MyGuild).SendGuildMsg(TGuild(BaseObjectC.m_MyGuild).sGuildName + '行会已经和您的行会联盟成功。');
              TGuild(BaseObjectC.m_MyGuild).SendGuildMsg(TGuild(m_MyGuild).sGuildName + '行会已经和您的行会联盟成功。');
              TGuild(m_MyGuild).RefMemberName;
              TGuild(BaseObjectC.m_MyGuild).RefMemberName;
              UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
                TGuild(m_MyGuild).sGuildName);
              UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
                TGuild(BaseObjectC.m_MyGuild).sGuildName);
              n8 := 0;
            end
            else
              n8 := -2;
          end
          else
            n8 := -3;
        end
        else
          n8 := -4; //004DF57C
      end;
      if n8 = 0 then
      begin
        SendDefMessage(SM_GUILDMAKEALLY_OK, 0, 0, 0, 0, '');
      end
      else
      begin
        SendDefMessage(SM_GUILDMAKEALLY_FAIL, n8, 0, 0, 0, '');
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg);
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildAlly');
  end;
end;

procedure TPlayObject.ClientGuildBreakAlly(sGuildName: string); //004DF604
var
  n10: Integer;
  Guild: TGuild;
begin
  try
    //  n10:= -1;
    if not IsGuildMaster() then
      exit;
    Guild := g_GuildManager.FindGuild(sGuildName);
    if Guild <> nil then
    begin
      if TGuild(m_MyGuild).IsAllyGuild(Guild) then
      begin
        TGuild(m_MyGuild).DelAllyGuild(Guild);
        Guild.DelAllyGuild(TGuild(m_MyGuild));
        TGuild(m_MyGuild).SendGuildMsg(Guild.sGuildName +
          ' 行会与您的行会解除联盟成功！！！');
        Guild.SendGuildMsg(TGuild(m_MyGuild).sGuildName +
          ' 行会解除了与您行会的联盟！！！');
        TGuild(m_MyGuild).RefMemberName();
        Guild.RefMemberName();
        UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
          TGuild(m_MyGuild).sGuildName);
        UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
        n10 := 0;
      end
      else
        n10 := -2;
    end
    else
      n10 := -3; //004DF750
    if n10 = 0 then
    begin
      SendDefMessage(SM_GUILDBREAKALLY_OK, 0, 0, 0, 0, '');
    end
    else
    begin
      SendDefMessage(SM_GUILDMAKEALLY_FAIL, 0, 0, 0, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ClientGuildBreakAlly');
  end;
end;

procedure TPlayObject.RecalcAdjusBonus();
  procedure AdjustAb(abil: byte; val: word; var lov, hiv: Word);
  var
    lo, hi: byte;
    i: integer;
  begin
    lo := Lobyte(abil);
    hi := Hibyte(abil);
    lov := 0;
    hiv := 0;

    for i := 1 to val do
    begin

      if lo + 1 < hi then
      begin
        Inc(lo);
        Inc(lov);
      end
      else
      begin
        Inc(hi);
        Inc(hiv);
      end;

    end;
  end;
var
  BonusTick: pTNakedAbility;
  NakedAbil: pTNakedAbility;
  adc, amc, asc, aac, amac: integer;
  ldc, lmc, lsc, lac, lmac, hdc, hmc, hsc, hac, hmac: Word;
  nCheck: Byte;
begin
  nCheck := 1;
  try

    BonusTick := nil;
    NakedAbil := nil;
    case m_btJob of
      jWarr:
        begin
          BonusTick := @g_Config.BonusAbilofWarr;
          NakedAbil := @g_Config.NakedAbilofWarr;
        end;
      jWizard:
        begin
          BonusTick := @g_Config.BonusAbilofWizard;
          NakedAbil := @g_Config.NakedAbilofWizard;
        end;
      jTaos:
        begin
          BonusTick := @g_Config.BonusAbilofTaos;
          NakedAbil := @g_Config.NakedAbilofTaos;
        end;
    end;
    nCheck := 2;

    adc := m_BonusAbil.DC div BonusTick.DC;
    amc := m_BonusAbil.MC div BonusTick.MC;
    asc := m_BonusAbil.SC div BonusTick.SC;
    aac := m_BonusAbil.AC div BonusTick.AC;
    amac := m_BonusAbil.MAC div BonusTick.MAC;
    nCheck := 8;

    AdjustAb(NakedAbil.DC, adc, ldc, hdc);
    AdjustAb(NakedAbil.MC, amc, lmc, hmc);
    AdjustAb(NakedAbil.SC, asc, lsc, hsc);
    AdjustAb(NakedAbil.AC, aac, lac, hac);
    AdjustAb(NakedAbil.MAC, amac, lmac, hmac);
    //lac  := 0;  hac := aac;
    //lmac := 0;  hmac := amac;
    nCheck := 3;
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC) + ldc, HiWord(m_WAbil.DC) + hdc);
    m_WAbil.MC := MakeLong(LoWord(m_WAbil.MC) + lmc, HiWord(m_WAbil.MC) + hmc);
    m_WAbil.SC := MakeLong(LoWord(m_WAbil.SC) + lsc, HiWord(m_WAbil.SC) + hsc);
    m_WAbil.AC := MakeLong(LoWord(m_WAbil.AC) + lac, HiWord(m_WAbil.AC) + hac);
    m_WAbil.MAC := MakeLong(LoWord(m_WAbil.MAC) + lmac, HiWord(m_WAbil.MAC) +
      hmac);

    m_WAbil.MaxHP := _MIN(High(Word), m_WAbil.MaxHP + m_BonusAbil.HP div
      BonusTick.HP);
    m_WAbil.MaxMP := _MIN(High(Word), m_WAbil.MaxMP + m_BonusAbil.MP div
      BonusTick.MP);
    nCheck := 4;
    //      m_btSpeedPoint:=m_btSpeedPoint + m_BonusAbil.Speed div BonusTick.Speed;
    //      m_btHitPoint:=m_btHitPoint + m_BonusAbil.Hit div BonusTick.Hit;
  except
    MainOutMessage('[Exception] TPlayObject.RecalcAdjusBonus ' +
      IntTOStr(nCheck));
  end;
end;

procedure TPlayObject.ClientAdjustBonus(nPoint: Integer; sMsg: string);
//004DF804
var
  BonusAbil: TNakedAbility;
  nTotleUsePoint: Integer;
begin
  try
    FillChar(BonusAbil, SizeOf(TNakedAbility), #0);
    DecodeBuffer(sMsg, @BonusAbil, SizeOf(TNakedAbility));

    nTotleUsePoint := BonusAbil.DC +
      BonusAbil.MC +
      BonusAbil.SC +
      BonusAbil.AC +
      BonusAbil.MAC +
      BonusAbil.HP +
      BonusAbil.MP +
      BonusAbil.Hit +
      BonusAbil.Speed +
      BonusAbil.X2;

    if (m_nBonusPoint > 0) and
      (nPoint < (High(Integer) - nTotleUsePoint)) and
      ((nPoint + nTotleUsePoint) = m_nBonusPoint) then
    begin
      m_nBonusPoint := nPoint;
      Inc(m_BonusAbil.DC, BonusAbil.DC);
      Inc(m_BonusAbil.MC, BonusAbil.MC);
      Inc(m_BonusAbil.SC, BonusAbil.SC);
      Inc(m_BonusAbil.AC, BonusAbil.AC);
      Inc(m_BonusAbil.MAC, BonusAbil.MAC);
      Inc(m_BonusAbil.HP, BonusAbil.HP);
      Inc(m_BonusAbil.MP, BonusAbil.MP);
      Inc(m_BonusAbil.Hit, BonusAbil.Hit);
      Inc(m_BonusAbil.Speed, BonusAbil.Speed);
      Inc(m_BonusAbil.X2, BonusAbil.X2);

      RecalcAbilitys();
      SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
      SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
    end
    else
    begin
      SysMsg('非法数据调整！！！', c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientAdjustBonus');
  end;
end;

function TPlayObject.GetMyStatus: Integer; //004C145C
begin
  try
    Result := m_nHungerStatus div 1000;
    if Result > 4 then
      Result := 4;
  except
    MainOutMessage('[Exception] TPlayObject.GetMyStatus:');
  end;
end;

procedure TPlayObject.SendAdjustBonus; //004DA9E4
var
  sSendMsg: string;
  //NakedAbil:TNakedAbility;
begin
  try
    m_DefMsg := MakeDefaultMsg(SM_ADJUST_BONUS, m_nBonusPoint, 0, 0, 0);
    sSendMsg := '';
    //NakedAbil:=m_BonusAbil;
    //FillChar(NakedAbil,SizeOf(TNakedAbility),#0);
    case m_btjob of //
      jWarr: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofWarr,
          SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
          EncodeBuffer(@g_Config.NakedAbilofWarr, SizeOf(TNakedAbility));
      jWizard: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofWizard,
          SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
          EncodeBuffer(@g_Config.NakedAbilofWizard, SizeOf(TNakedAbility));
      jTaos: sSendMsg := EncodeBuffer(@g_Config.BonusAbilofTaos,
          SizeOf(TNakedAbility)) + '/' +
        EncodeBuffer(@m_BonusAbil, SizeOf(TNakedAbility)) + '/' +
          EncodeBuffer(@g_Config.NakedAbilofTaos, SizeOf(TNakedAbility));
    end; // case
    SendSocket(@m_DefMsg, sSendMsg);
  except
    MainOutMessage('[Exception] TPlayObject.SendAdjustBonus');
  end;
end;

function TBaseObject.GetAttackDir(BaseObject: TBaseObject; var btDir: Byte;
  btRate: Byte = 1): Boolean; //004C3CA0
begin
  try
    Result := False;
    if (m_nCurrX - btRate <= BaseObject.m_nCurrX) and
      (m_nCurrX + btRate >= BaseObject.m_nCurrX) and
      (m_nCurrY - btRate <= BaseObject.m_nCurrY) and
      (m_nCurrY + btRate >= BaseObject.m_nCurrY) and
      ((m_nCurrX <> BaseObject.m_nCurrX) or
      (m_nCurrY <> BaseObject.m_nCurrY)) then
    begin
      Result := True;
      if ((m_nCurrX - btRate) = BaseObject.m_nCurrX) and (m_nCurrY =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_LEFT;
        exit;
      end;
      if ((m_nCurrX + btRate) = BaseObject.m_nCurrX) and (m_nCurrY =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_RIGHT;
        exit;
      end;
      if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY - btRate) =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_UP;
        exit;
      end;
      if (m_nCurrX = BaseObject.m_nCurrX) and ((m_nCurrY + btRate) =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWN;
        exit;
      end;
      if ((m_nCurrX - btRate) = BaseObject.m_nCurrX) and ((m_nCurrY - btRate) =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_UPLEFT;
        exit;
      end;
      if ((m_nCurrX + btRate) = BaseObject.m_nCurrX) and ((m_nCurrY - btRate) =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_UPRIGHT;
        exit;
      end;
      if ((m_nCurrX - btRate) = BaseObject.m_nCurrX) and ((m_nCurrY + btRate) =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWNLEFT;
        exit;
      end;
      if ((m_nCurrX + btRate) = BaseObject.m_nCurrX) and ((m_nCurrY + btRate) =
        BaseObject.m_nCurrY) then
      begin
        btDir := DR_DOWNRIGHT;
        exit;
      end;
      Result := False;
      btDir := 0;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetAttackDir');
  end;
end;

function TBaseObject.TargetInSpitRange(BaseObject: TBaseObject; var btDir:
  Byte): Boolean; //004C3E68
var
  nX, nY: Integer;
begin
  try
    Result := False;
    if (abs(BaseObject.m_nCurrX - m_nCurrX) <= 2) and (abs(BaseObject.m_nCurrY -
      m_nCurrY) <= 2) then
    begin
      nX := BaseObject.m_nCurrX - m_nCurrX;
      nY := BaseObject.m_nCurrY - m_nCurrY;
      if (abs(nX) <= 1) and (abs(nY) <= 1) then
      begin
        GetAttackDir(BaseObject, btDir);
        Result := True;
        exit;
      end;
      Inc(nX, 2);
      Inc(nY, 2);
      if ((nX >= 0) and (nX <= 4)) and ((nY >= 0) and (nY <= 4)) then
      begin
        btDir := GetNextDirection(m_nCurrX, m_nCurrY, BaseObject.m_nCurrX,
          BaseObject.m_nCurrY);
        if g_Config.SpitMap[btDir, nY, nX] = 1 then
          Result := True;
      end;

    end;

  except
    MainOutMessage('[Exception] TBaseObject.TargetInSpitRange');
  end;
end;

//004BF6F0

function TBaseObject.RecalcBagWeight: Integer;
var
  I: Integer;
  UserItem: PTUserItem;
  StdItem: TItem;
begin
  try
    Result := 0;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        Inc(Result, StdItem.Weight);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.RecalcBagWeight:Integer');
  end;
end;
//004BFD50

procedure TBaseObject.RecalcHitSpeed;
var
  I: Integer;
  UserMagic: pTUserMagic;
  BonusTick: pTNakedAbility;
  nCheckCode: Byte;
begin
  nCheckCode := 0;
  try
    BonusTick := nil;
    case m_btJob of
      jWarr: BonusTick := @g_Config.BonusAbilofWarr;
      jWizard: BonusTick := @g_Config.BonusAbilofWizard;
      jTaos: BonusTick := @g_Config.BonusAbilofTaos;
    end;
    nCheckCode := 11;
    //MainOutMessage(IntToStr(m_btJob)+' '+BoolToStr((BonusTick=nil))+ ' ' + m_sCharName);
    //MainOutMessage(IntToStr(BonusTick.Hit));
    nCheckCode := 12;
    m_btHitPoint := DEFHIT + m_BonusAbil.Hit div BonusTick.Hit;
    nCheckCode := 111;

    case m_btJob of
      jTaos: m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed
        + 3; //档荤绰 扁夯 刮酶捞 臭促.
    else
      m_btSpeedPoint := DEFSPEED + m_BonusAbil.Speed div BonusTick.Speed;
    end;
    nCheckCode := 111;
    nCheckCode := 12;
    nCheckCode := 1;
    m_nHitPlus := 0;
    m_nHitDouble := 0;

    m_MagicOneSwordSkill := nil;
    m_MagicPowerHitSkill := nil;
    m_MagicErgumSkill := nil;
    m_MagicBanwolSkill := nil;
    m_MagicRedBanwolSkill := nil;
    m_MagicFireSwordSkill := nil;
    m_MagicLongFireSwordSkill := nil;
    m_MagicCrsSkill := nil;
    m_Magic41Skill := nil;
    m_MagicTwnHitSkill := nil;
    m_MagicLongSwordSkill := nil;
    m_MagicShieldSkill := nil;
    m_MagicSkill83:=nil;
    m_MagicSkill84:=nil;
    nCheckCode := 13;
    for I := 0 to m_MagicList.Count - 1 do
    begin
      nCheckCode := 2;
      UserMagic := m_MagicList.Items[i];
      nCheckCode := 3;
      case UserMagic.wMagIdx of
        SKILL_FIRECHARM:
          begin //灵魂火符
            if m_boHero then
            begin
              if (TPlayObject(Self).m_boHeroFourMagic) and
                (UserMagic.btLevel = 3) then
              begin
                UserMagic.btLevel := 4;
                UserMagic.MagicInfo := g_HeroFourMagicCharm;
                SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
              end
              else if (not TPlayObject(Self).m_boHeroFourMagic) and
                (UserMagic.btLevel = 4) then
              begin
                UserMagic.btLevel := 3;
                UserMagic.MagicInfo := UserEngine.FindMagic(UserMagic.wMagIdx,
                  m_boHero);
                SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
              end;
            end;
          end;
        SKILL_73:
          begin
            m_MagicLongFireSwordSkill := UserMagic;
          end;
        SKILL_FIRESWORD:
          begin //烈火剑法
            if m_boHero then
            begin
              if (TPlayObject(Self).m_boHeroFourMagic) and
                (UserMagic.btLevel = 3) then
              begin
                UserMagic.btLevel := 4;
                UserMagic.MagicInfo := g_HeroFourMagicFirs;
                SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
              end
              else if (not TPlayObject(Self).m_boHeroFourMagic) and
                (UserMagic.btLevel = 4) then
              begin
                UserMagic.btLevel := 3;
                UserMagic.MagicInfo := UserEngine.FindMagic(UserMagic.wMagIdx,
                  m_boHero);
                SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
              end;
            end;
            m_MagicFireSwordSkill := UserMagic;
            m_nHitDouble := 4 + UserMagic.btLevel * 4;
          end;
        SKILL_45:
          begin //灭天火
            if m_boHero then
            begin
              if (TPlayObject(Self).m_boHeroFourMagic) and
                (UserMagic.btLevel = 3) then
              begin
                UserMagic.btLevel := 4;
                UserMagic.MagicInfo := g_HeroFourMagic45;
                SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
              end
              else if (not TPlayObject(Self).m_boHeroFourMagic) and
                (UserMagic.btLevel = 4) then
              begin
                UserMagic.btLevel := 3;
                UserMagic.MagicInfo := UserEngine.FindMagic(UserMagic.wMagIdx,
                  m_boHero);
                SendUpdateMsg(Self, RM_SENDMYMAGIC, 0, 0, 0, 0, '');
              end;
            end;
          end;
        SKILL_ONESWORD:
          begin //内功心法
            m_MagicOneSwordSkill := UserMagic;
            if UserMagic.btLevel > 0 then
            begin
              m_btHitPoint := m_btHitPoint + ROUND(9 / 3 * UserMagic.btLevel);
            end;
          end;
        SKILL_YEDO:
          begin //攻杀剑法
            m_MagicPowerHitSkill := UserMagic;
            if UserMagic.btLevel > 0 then
            begin
              m_btHitPoint := m_btHitPoint + ROUND(3 / 3 * UserMagic.btLevel);
            end;
            m_nHitPlus := DEFHIT + UserMagic.btLevel;
            m_btAttackSkillCount := 7 - UserMagic.btLevel;
            m_btAttackSkillPointCount := Random(m_btAttackSkillCount);
          end;
        SKILL_ERGUM:
          begin //刺杀剑法
            m_MagicErgumSkill := UserMagic;
          end;
        SKILL_BANWOL:
          begin //半月弯刀
            m_MagicBanwolSkill := UserMagic;
          end;
        SKILL_REDBANWOL:
          begin
            m_MagicRedBanwolSkill := UserMagic;
          end;
        SKILL_ILKWANG:
          begin //基本剑法
            m_MagicOneSwordSkill := UserMagic;
            if UserMagic.btLevel > 0 then
            begin
              m_btHitPoint := m_btHitPoint + ROUND(8 / 3 * UserMagic.btLevel);
            end;
          end;
        SKILL_CROSSMOON:
          begin
            m_MagicCrsSkill := UserMagic;
          end;
        SKILL_ANGEL:
          begin
            m_Magic41Skill := UserMagic;
          end;
        SKILL_TWINBLADE:
          begin
            m_MagicTwnHitSkill := UserMagic;
          end;
        SKILL_43:
          begin
            m_MagicLongSwordSkill := UserMagic;
          end;
        SKILL_75:
          begin
            m_MagicShieldSkill := UserMagic;
          end;
        SKILL_83:
          begin
            m_MagicSkill83 := UserMagic;//先天元力
          end;
        SKILL_84:
          begin
            m_MagicSkill84 := UserMagic;//酒气护体
          end;
      end;
    end;
  except
    on E: Exception do
    begin
      MainOutMessage('[Exception] TBaseObject.RecalcHitSpeed ' +
        IntToStr(nCheckCode));
      MainOutMessage(E.Message);
    end;
  end;
end;
//004BFFD0

procedure TBaseObject.AddItemSkill(nIndex: Integer);
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
  // PlayObject :TPlayObject;
begin
  try
    Magic := nil;
    case nIndex of
      1: Magic := UserEngine.FindMagic(g_Config.sFireBallSkill, m_boHero);
      2: Magic := UserEngine.FindMagic(g_Config.sHealSkill, m_boHero);
    end;
    if Magic <> nil then
    begin
      if not IsTrainingSkill(Magic.wMagicId) then
      begin
        New(UserMagic);
        UserMagic.MagicInfo := Magic;
        UserMagic.wMagIdx := Magic.wMagicId;
        UserMagic.btKey := 0;
        UserMagic.btLevel := 1;
        UserMagic.nTranPoint := 0;
        m_MagicList.Add(UserMagic);
        RecalcAbilitys();
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          TPlayObject(Self).SendAddMagic(UserMagic);
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.AddItemSkill');
  end;
end;

function TBaseObject.AddToMap: Boolean; //004BA5E4
var
  Point: Pointer;
begin
  try
    Point := m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    if Point <> nil then
      Result := True
    else
      Result := False;
    if not m_boFixedHideMode then
      SendRefMsg(RM_TURN, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.AddToMap:');
  end;
end;

procedure TBaseObject.AttackDir(TargeTBaseObject: TBaseObject; wHitMode: Word;
  nDir: Integer); //004C2C50
  function GetMagicSpell(UserMagic: pTUserMagic): Integer;
  begin
    Result := ROUND(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv
      + 1) * (UserMagic.btLevel + 1));
  end;
  //武器升级设置
  procedure CheckWeaponUpgradeStatus(UserItem: pTUserItem); //004C27C0
  begin
    //if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) < 20 then begin
    if (UserItem.btValue[0] + UserItem.btValue[1] + UserItem.btValue[2]) <
      g_Config.nUpgradeWeaponMaxPoint then
    begin
      case UserItem.btValue[10] of
        1: UserItem.wIndex := 0;
        10..13: UserItem.btValue[0] := UserItem.btValue[0] + UserItem.btValue[10]
          - 9;
        20..23: UserItem.btValue[1] := UserItem.btValue[1] + UserItem.btValue[10]
          - 19;
        30..33: UserItem.btValue[2] := UserItem.btValue[2] + UserItem.btValue[10]
          - 29;
      end;
    end
    else
      UserItem.wIndex := 0;
    UserItem.btValue[10] := 0;
  end;
  procedure CheckWeaponUpgrade(); //004C2854
  var
    UseItems: TUserItem;
    PlayObject: TPlayObject;
    StdItem: TItem;
  begin
    if m_UseItems[U_WEAPON].btValue[10] > 0 then
    begin
      UseItems := m_UseItems[U_WEAPON];
      CheckWeaponUpgradeStatus(@m_UseItems[U_WEAPON]);
      if m_UseItems[U_WEAPON].wIndex = 0 then
      begin
        SysMsg(g_sTheWeaponBroke, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@UseItems);
        //PlayObject.StatusChanged;
        SendRefMsg(RM_BREAKWEAPON, 0, 0, 0, 0, '');
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        //004C29E0
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('21' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(UseItems.wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(UseItems.MakeIndex) + #9 +
            '1' + #9 +
            '0');
        FeatureChanged();
      end
      else
      begin
        SysMsg(sTheWeaponRefineSuccessfull, c_Red, t_Hint);
        PlayObject := TPlayObject(Self);
        PlayObject.SendUpdateItem(@m_UseItems[U_WEAPON]);
        StdItem := UserEngine.GetStdItem(UseItems.wIndex);
        //004C2B14
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('20' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(UseItems.wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(UseItems.MakeIndex) + #9 +
            '1' + #9 +
            '0');
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
    end;
  end;
var
  AttackTarget: TBaseObject;
  boPowerHit: Boolean;
  boFireHit: Boolean;
  boLongFireHit: Boolean;
  //  boCrsHit     :Boolean;
  boLoSwHit: Boolean;
  //  bo41         :Boolean;
  boTwinHit: Boolean;
  //  bo43         :Boolean;
  wIdent: Word;
  nCheckCode: Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::AttackDir Code: %d';
begin //004C2C50
  nCheckCode := 0;
  try
    if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) then
    begin //半月
      if m_WAbil.MP > 0 then
      begin
        DamageSpell(m_MagicBanwolSkill.MagicInfo.btDefSpell +
          GetMagicSpell(m_MagicBanwolSkill));
        HealthSpellChanged();
      end
      else
        wHitMode := RM_HIT;
    end;
    if (wHitMode = 12) and (m_MagicRedBanwolSkill <> nil) then
    begin
      if m_WAbil.MP > 0 then
      begin
        DamageSpell(m_MagicRedBanwolSkill.MagicInfo.btDefSpell +
          GetMagicSpell(m_MagicRedBanwolSkill));
        HealthSpellChanged();
      end
      else
        wHitMode := RM_HIT;
    end;
    if (wHitMode = 8) and (m_MagicCrsSkill <> nil) then
    begin
      if m_WAbil.MP > 0 then
      begin
        DamageSpell(m_MagicCrsSkill.MagicInfo.btDefSpell +
          GetMagicSpell(m_MagicCrsSkill));
        HealthSpellChanged();
      end
      else
        wHitMode := RM_HIT;
    end;
    if (wHitMode = 9) and (m_MagicTwnHitSkill <> nil) then
    begin
      if m_WAbil.MP > 0 then
      begin
        DamageSpell(m_MagicTwnHitSkill.MagicInfo.btDefSpell +
          GetMagicSpell(m_MagicTwnHitSkill));
        HealthSpellChanged();
      end
      else
        wHitMode := RM_HIT;
    end;

    nCheckCode := 4;
    m_btDirection := nDir;
    if TargeTBaseObject = nil then
    begin
      nCheckCode := 41;
      AttackTarget := GetPoseCreate();
    end
    else
      AttackTarget := TargeTBaseObject;
    if (AttackTarget <> nil) and (m_UseItems[U_WEAPON].wIndex > 0) then
    begin
      nCheckCode := 42;
      CheckWeaponUpgrade();
    end;
    nCheckCode := 5;
    boPowerHit := m_boPowerHit;
    boFireHit := m_boFireHitSkill;
    boLongFireHit := m_boLongFireHitSkill;
    //boCrsHit:=m_boCrsHitkill;
   // bo41:=m_bo41kill;
    boTwinHit := m_boTwinHitSkill;
    boLoSwHit := m_boLongSwordSkill;
    //bo43:=m_bo43kill;
    if _Attack(wHitMode, AttackTarget) then
    begin
      nCheckCode := 6;
      SetTargetCreat(AttackTarget); //$FFF2
      nCheckCode := 7;
    end;
    wIdent := RM_HIT;
    if m_btRaceServer in [RC_PLAYOBJECT, RC_PLAYCLONE] then
    begin
      case wHitMode of
        0: wIdent := RM_HIT;
        1: wIdent := RM_HEAVYHIT;
        2: wIdent := RM_BIGHIT;
        3: if boPowerHit then
            wIdent := RM_SPELL2;
        4: if m_MagicErgumSkill <> nil then
            wIdent := RM_LONGHIT;
        5: if m_MagicBanwolSkill <> nil then
            wIdent := RM_WIDEHIT;
        7: if boFireHit then
            wIdent := RM_FIREHIT;
        8: if m_MagicCrsSkill <> nil then
            wIdent := RM_CRSHIT;
        9: if boTwinHit then
            wIdent := RM_TWINHIT;
        10: if boLoSwHit and m_boLongSwordSkillCls then
            wIdent := RM_LONGSWORD1;
        11: if boLoSwHit and not m_boLongSwordSkillCls then
            wIdent := RM_LONGSWORD2;
        12: if m_MagicRedBanwolSkill <> nil then
            wIdent := RM_WIDEHIT;
        13: if boLongFireHit then
            wIdent := RM_LONGFIRESWORD;
      end;
    end;
    if boFireHit and (m_MagicFireSwordSkill <> nil) and
      (m_MagicFireSwordSkill.btLevel = 4) then
      wIdent := RM_FIREHIT2;
    nCheckCode := 8;
    SendAttackMsg(wIdent, m_btDirection, m_nCurrX, m_nCurrY);
    nCheckCode := 9;
  except
    on e: Exception do
    begin
      MainOutMessage(format(sExceptionMsg, [nCheckCode]));
      MainOutMessage(E.Message);
    end;
  end;
end;

procedure TBaseObject.CheckPKStatus; //004BC83C
begin
  try
    if m_boPKFlag and ((GetTickCount - m_dwPKTick) > g_Config.dwPKFlagTime
      {60 * 1000}) then
    begin
      m_boPKFlag := False;
      RefNameColor();
    end;
  except
    MainOutMessage('[Exception] TBaseObject.AttackDir');
  end;
end;

procedure TBaseObject.DamageSpell(nSpellPoint: Integer); //004BE50C
begin
  try
    if nSpellPoint > 0 then
    begin
      if (m_WAbil.MP - nSpellPoint) > 0 then
        Dec(m_WAbil.MP, nSpellPoint)
      else
        m_WAbil.MP := 0;
    end
    else
    begin
      if (m_WAbil.MP - nSpellPoint) < m_WAbil.MaxMP then
        Dec(m_WAbil.MP, nSpellPoint)
      else
        m_WAbil.MP := m_WAbil.MaxMP;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DamageSpell');
  end;
end;

//004BF520

procedure TBaseObject.DecPKPoint(nPoint: Integer);
var
  nC: Integer;
begin
  try
    nC := PKLevel();
    Dec(m_nPkPoint, nPoint);
    if m_nPkPoint < 0 then
      m_nPkPoint := 0;
    if (PKLevel <> nC) and (nC > 0) and (nC <= 2) then
    begin
      RefNameColor();
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DecPKPoint');
  end;
end;

//004C01B8

procedure TBaseObject.DelItemSkill(nIndex: Integer);
  procedure DeleteSkill(sSkillName: string); //004C00B8
  var
    I: Integer;
    UserMagic: pTUserMagic;
  begin
    for I := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[i];
      if UserMagic.MagicInfo.sMagicName = sSkillName then
      begin
        TPlayObject(Self).SendDelMagic(UserMagic);
        Dispose(UserMagic);
        m_MagicList.Delete(i);
        RecalcAbilitys;
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        break;
      end;
    end;
  end;
begin
  try
    if m_btRaceServer <> RC_PLAYOBJECT then
      exit;
    case nIndex of
      1: if m_btJob <> jWizard then
          DeleteSkill(g_Config.sFireBallSkill);
      2: if m_btJob <> jTaos then
          DeleteSkill(g_Config.sHealSkill)
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DelItemSkill');
  end;
end;

//004C39E8

procedure TBaseObject.DelMember(BaseObject: TBaseObject);
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  try
    if m_btRaceServer <> RC_PLAYOBJECT then
      exit;
    if m_GroupOwner <> BaseObject then
    begin
      for I := 0 to m_GroupMembers.Count - 1 do
      begin
        if m_GroupMembers.Objects[i] = BaseObject then
        begin
          BaseObject.LeaveGroup();
          m_GroupMembers.Delete(i);
          break;
        end;
      end;
    end
    else
    begin //004C3A65
      for I := m_GroupMembers.Count - 1 downto 0 do
      begin
        TBaseObject(m_GroupMembers.Objects[i]).LeaveGroup;
        m_GroupMembers.Delete(i);
      end;
    end;
    PlayObject := TPlayObject(Self);
    if not PlayObject.CancelGroup then
    begin
      PlayObject.SendDefMessage(SM_GROUPCANCEL, 0, 0, 0, 0, '');
    end
    else
    begin
      if PlayObject.m_boAllowAddGroup then
        PlayObject.RefShowName;
      PlayObject.SendGroupMembers();
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DelMember');
  end;
end;

procedure TBaseObject.NpcGotoLable(NormNpc: TBaseObject; sLabel: string;
  boMaster: Boolean);
var
  PlayObject: TPlayObject;
begin
  try
    if (NormNpc <> nil) and (sLabel <> '') then
    begin
      PlayObject := nil;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        if m_boHero then
        begin
          if (m_HeroHuman <> nil) and boMaster then
            PlayObject := TPlayObject(m_HeroHuman);
        end
        else
          PlayObject := TPlayObject(Self);
      end
      else
      begin
        if (boMaster) and
          (m_AllMaster <> nil) and
          (m_AllMaster.m_btRaceServer = RC_PLAYOBJECT) and
          (not m_AllMaster.m_boHero) then
        begin
          PlayObject := TPlayObject(m_AllMaster);
        end;
      end;
      if PlayObject <> nil then
      begin
        PlayObject.m_nScriptGotoCount := 0;
        TNormNpc(NormNpc).GotoLable(PlayObject, sLabel, False);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DelMember');
  end;
end;

procedure TBaseObject.DoDamageWeapon(nWeaponDamage: Integer); //004C17B4
var
  nDura, nDuraPoint: Integer;
  PlayObject: TPlayObject;
  StdItem: TItem;
begin
  try
    if m_UseItems[U_WEAPON].wIndex <= 0 then
      exit;
    nDura := m_UseItems[U_WEAPON].Dura;
    nDuraPoint := Round(nDura / 1.03);
    Dec(nDura, nWeaponDamage);
    if nDura <= 0 then
    begin
      nDura := 0;
      m_UseItems[U_WEAPON].Dura := nDura;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendDelItems(@m_UseItems[U_WEAPON]);
        StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
        //004C195A
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog('3' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            //UserEngine.GetStdItemName(m_UseItems[U_WEAPON].wIndex) + #9 +
            StdItem.Name + #9 +
            IntToStr(m_UseItems[U_WEAPON].MakeIndex) + #9 +
            BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
            '0');
      end;
      m_UseItems[U_WEAPON].wIndex := 0;
      SendMsg(Self, RM_DURACHANGE, U_WEAPON, nDura,
        m_UseItems[U_WEAPON].DuraMax, 0, '');
    end
    else
    begin //004C199D
      m_UseItems[U_WEAPON].Dura := nDura;
    end;
    if (nDura / 1.03) <> nDuraPoint then
    begin
      SendMsg(Self, RM_DURACHANGE, U_WEAPON, m_UseItems[U_WEAPON].Dura,
        m_UseItems[U_WEAPON].DuraMax, 0, '');
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DoDamageWeapon');
  end;
end;
{$REGION '没用的'}
//004BF180
{
function TBaseObject.GetCharColor(BaseObject:TBaseObject): Byte;
var
  n10:Integer;
  nCheckCode:Integer;
begin
Try
  nCheckCode:=0;
try
  Result:=BaseObject.GetNamecolor();
  nCheckCode:=1;
  if BaseObject.m_btRaceServer = RC_PLAYOBJECT then begin
    if BaseObject.PKLevel < 2 then begin
      if BaseObject.m_boPKFlag then Result:=g_Config.btPKFlagNameColor;//$2F
      nCheckCode:=2;
      n10:=GetGuildRelation(Self,BaseObject);
      nCheckCode:=3;
      case n10 of
        1,3: Result:=g_Config.btAllyAndGuildNameColor;//$B4;
        2: Result:=g_Config.btWarGuildNameColor;//$45;
      end;
      if BaseObject.m_PEnvir.m_boFight3Zone then begin
        if m_MyGuild = BaseObject.m_MyGuild then Result:=g_Config.btAllyAndGuildNameColor//$B4
        else Result:=g_Config.btWarGuildNameColor//$45;
      end;
    end; //004BF218
    nCheckCode:=4;
    if UserCastle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin
      nCheckCode:=5;
      Result:=g_Config.btInFreePKAreaNameColor;//$DD;
      m_boGuildWarArea:=True;
      nCheckCode:=6;
      if (m_MyGuild = nil) then exit;
      if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
        nCheckCode:=7;
        if (m_MyGuild = BaseObject.m_MyGuild) or
           (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then begin
          nCheckCode:=8;
          Result:=g_Config.btAllyAndGuildNameColor//$B4;
        end else begin //004BF2A8
          nCheckCode:=9;
          if UserCastle.IsAttackGuild(TGuild(BaseObject.m_MyGuild)) then begin
            nCheckCode:=10;
            Result:=g_Config.btWarGuildNameColor//$45;
          end;
        end;
      end else begin //004BF2CE
        nCheckCode:=11;
        if UserCastle.IsAttackGuild(TGuild(m_MyGuild)) then begin
          nCheckCode:=12;
          if (m_MyGuild = BaseObject.m_MyGuild) or
             (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then begin
            nCheckCode:=13;
            Result:=g_Config.btAllyAndGuildNameColor//$B4;
          end else begin
            nCheckCode:=14;
            if UserCastle.IsMember(BaseObject) then begin
              nCheckCode:=15;
              Result:=g_Config.btWarGuildNameColor//$45;
            end;
          end;
        end; //004BF379
      end;
    end;
  end else begin //004BF339
    //if (BaseObject.m_btSlaveExpLevel - 8) < 0 then begin
    if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) then begin
      Result:=g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
    end;
    if BaseObject.m_boCrazyMode then Result:=$F9;
    if BaseObject.m_boHolySeize then Result:=$7D;
  end;
except
  on e: Exception do begin
    MainOutMessage('[Exception] TBaseObject.GetCharColor Code: ' + IntToStr(nCheckCode));
    MainOutMessage(E.Message);
  end;
end;
Except
  MainOutMessage('[Exception] TBaseObject.GetCharColor');
End;
end;
}
{$ENDREGION}
function TBaseObject.GetCharColor(BaseObject: TBaseObject): Byte;
var
  n10: Integer;
  Castle: TUserCastle;
begin
  try

    Result := BaseObject.GetNamecolor();
    if BaseObject.m_boHero then
    begin
      if BaseObject.PKLevel < 2 then
        if BaseObject.m_boPKFlag then
          Result := g_Config.btPKFlagNameColor; //$2F
    end
    else if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
    begin
      if BaseObject.PKLevel < 2 then
      begin
        if BaseObject.m_boPKFlag then
          Result := g_Config.btPKFlagNameColor; //$2F

        n10 := GetGuildRelation(Self, BaseObject);
        //MainOutMessage(Format('%d/%s/%s',[n10,self.m_sCharName,BaseObject.m_sCharName]));
        case n10 of
          1, 3: Result := g_Config.btAllyAndGuildNameColor; //$B4;
          2: Result := g_Config.btWarGuildNameColor; //$45;
        end;
        if BaseObject.m_PEnvir.Flag.boFight3Zone then
        begin
          if m_MyGuild = BaseObject.m_MyGuild then
            Result := g_Config.btAllyAndGuildNameColor //$B4
          else
            Result := g_Config.btWarGuildNameColor //$45;
        end;
      end; //004BF218

      Castle := g_CastleManager.InCastleWarArea(BaseObject);
      //    if  UserCastle.m_boUnderWar and m_boInFreePKArea and BaseObject.m_boInFreePKArea then begin
      if (Castle <> nil) and Castle.m_boUnderWar and m_boInFreePKArea and
        BaseObject.m_boInFreePKArea then
      begin

        Result := g_Config.btInFreePKAreaNameColor; //$DD;
        m_boGuildWarArea := True;

        if (m_MyGuild = nil) then
          exit;
        //      if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
        if Castle.IsMasterGuild(TGuild(m_MyGuild)) then
        begin
          //        nCheckCode:=7;
          if (m_MyGuild = BaseObject.m_MyGuild) or
            (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then
          begin
            // nCheckCode:=8;
            Result := g_Config.btAllyAndGuildNameColor //$B4;
          end
          else
          begin //004BF2A8
            //          nCheckCode:=9;
                      //if UserCastle.IsAttackGuild(TGuild(BaseObject.m_MyGuild)) then begin
            if Castle.IsAttackGuild(TGuild(BaseObject.m_MyGuild)) then
            begin
              //            nCheckCode:=10;
              Result := g_Config.btWarGuildNameColor //$45;
            end;
          end;
        end
        else
        begin //004BF2CE

          //        if UserCastle.IsAttackGuild(TGuild(m_MyGuild)) then begin
          if Castle.IsAttackGuild(TGuild(m_MyGuild)) then
          begin

            if (m_MyGuild = BaseObject.m_MyGuild) or
              (TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))) then
            begin

              Result := g_Config.btAllyAndGuildNameColor //$B4;
            end
            else
            begin

              //            if UserCastle.IsMember(BaseObject) then begin
              if Castle.IsMember(BaseObject) then
              begin

                Result := g_Config.btWarGuildNameColor //$45;
              end;
            end;
          end; //004BF379
        end;
      end;
    end
    else
    begin //004BF339
      //if (BaseObject.m_btSlaveExpLevel - 8) < 0 then begin
      if (BaseObject.m_btSlaveExpLevel < SLAVEMAXLEVEL) then
      begin
        Result := g_Config.SlaveColor[BaseObject.m_btSlaveExpLevel];
      end;
      if BaseObject.m_boCrazyMode then
        Result := $F9;
      //if BaseObject.m_boNastyMode then Result:=$F9;
      if BaseObject.m_boHolySeize then
        Result := $7D;
      //if BaseObject.m_boAutoGhost then begin
      if BaseObject.m_btChangeNameColor <> 255 then
        Result := BaseObject.m_btChangeNameColor;

    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetCharColor');
  end;
end;

//取药力值升级值
function TBaseObject.GetMedicineLevelExp(nLevel: Integer): LongWord; //004BEDC8
begin
  try
    if nLevel <= 0 then
      nLevel := 1;
    if nLevel <= 500 {51} then
    begin
      Result := g_Config.dwMedicineExps[nLevel];
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetMedicineLevelExp');
  end;
end;

//取指定等级先天元力的随加值
procedure TBaseObject.GetSkill83LevelAbil;
begin
if m_WineRec.WineValue>=g_Config.dwskill83Exps[3] then
begin
  m_SKILL83Rec.skill83Level:=3;
  m_SKILL83Rec.skill83Abil:=g_Config.dwskill83Abils [3];
  m_SKILL83Rec.MaxWineValue:=g_Config.dwskill83Exps[3];
end else
if m_WineRec.WineValue>=g_Config.dwskill83Exps[2] then
begin
  m_SKILL83Rec.skill83Level:=2;
  m_SKILL83Rec.skill83Abil:=g_Config.dwskill83Abils[2];
  m_SKILL83Rec.MaxWineValue:=g_Config.dwskill83Exps[3];
end else
if m_WineRec.WineValue>=g_Config.dwskill83Exps[1] then
begin
  m_SKILL83Rec.skill83Level:=1;
  m_SKILL83Rec.skill83Abil:=g_Config.dwskill83Abils [1];
  m_SKILL83Rec.MaxWineValue:=g_Config.dwskill83Exps[2];
end else
begin
  m_SKILL83Rec.skill83Level:=0;
  m_SKILL83Rec.skill83Abil:=g_Config.dwskill83Abils [0];
  m_SKILL83Rec.MaxWineValue:=g_Config.dwskill83Exps[1];
end;
end;

//取酒气护体升级经验
function TBaseObject.Getskill84LevelExp(nLevel: Integer): LongWord; //004BEDC8
begin
  try
    if nLevel <= 0 then
      nLevel := 1;
    if nLevel <= 500 {51} then
    begin
      Result := g_Config.dwskill84Exps[nLevel];
    end;
  except
    MainOutMessage('[Exception] TBaseObject.Getskill84LevelExp');
  end;
end;

//取升级经验
function TBaseObject.GetLevelExp(nLevel: Integer): LongWord; //004BEDC8
begin
  try
    if nLevel <= 0 then
      nLevel := 1;
    if nLevel <= 500 {51} then
    begin
      Result := g_Config.dwNeedExps[nLevel];
      if m_boHero then
      begin
        if (Round(Result * (g_Config.nHeroExpRate / 100))) > High(LongWord) then
          Result := High(LongWord)
        else
          Result := Round(Result * (g_Config.nHeroExpRate / 100));
      end;
    end
    else
    begin
      if m_boHero then
        Result := g_Config.nHeroFixupExp
      else
        Result := g_Config.nPlayFixupExp;
      //Result:=g_Config.dwNeedExps[High(g_Config.dwNeedExps)];
      //Result:=$FFFFFFFF;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetLevelExp');
  end;
end;

//004BF144

function TBaseObject.GetNamecolor(): Byte;
begin
  try
    Result := m_btNameColor;
    if m_boHero then
      Result := g_Config.nHeroNameColor;
    if PKLevel = 1 then
      Result := g_Config.btPKLevel1NameColor; //$FB;
    if PKLevel >= 2 then
      Result := g_Config.btPKLevel2NameColor; //$F9;
  except
    MainOutMessage('[Exception] TBaseObject.GetNamecolor');
  end;
end;

procedure TBaseObject.HearMsg(sMsg: string); //004BB2A0
begin
  try
    if sMsg <> '' then
      SendMsg(nil, RM_HEAR, 0, g_Config.btHearMsgFColor,
        g_Config.btHearMsgBColor, 0, sMsg);
  except
    MainOutMessage('[Exception] TBaseObject.HearMsg');
  end;
end;

function TBaseObject.InSafeArea(): Boolean; //004BEF8C
var
  I: Integer;
  //  sC:String;
  //  n14,n18,n1C:Integer;
  StartPoint: pTStartPoint;
begin
  Result := False;
  try
    g_StartPoint.Lock;
    try
      for I := 0 to g_StartPoint.Count - 1 do
      begin
        StartPoint := g_StartPoint.Items[I];
        if StartPoint.Envir = m_PEnvir then
        begin
          if (abs(m_nCurrX - StartPoint.nX) <= 60) and (abs(m_nCurrY -
            StartPoint.nY) <= 60) then
          begin
            Result := True;
            break;
          end;
        end;
      end;
    finally
      g_StartPoint.UnLock;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.InSafeArea');
  end;
end;

procedure TBaseObject.MonsterRecalcAbilitys; //004BE934
var
  n8: Integer;
begin
  try
    m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), HiWord(m_Abil.DC));
    n8 := 0;
    if (m_btRaceServer = MONSTER_WHITESKELETON) or
      (m_btRaceServer = MONSTER_ELFMONSTER) or
      (m_btRaceServer = MONSTER_ELFWARRIOR) or
      (m_btRaceServer = MONSTER_MOONFAIRY) then
    begin

      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), ROUND((m_btSlaveExpLevel * 0.1
        + 0.3) * 3.0 * m_btSlaveExpLevel + HiWord(m_WAbil.DC)));
      n8 := n8 + ROUND((m_btSlaveExpLevel * 0.1 + 0.3) * m_Abil.MaxHP) *
        m_btSlaveExpLevel;
      n8 := n8 + m_Abil.MaxHP;
      if m_btSlaveExpLevel > 0 then
        m_WAbil.MaxHP := n8
      else
        m_WAbil.MaxHP := m_Abil.MaxHP;
    end
    else
    begin //004BEA85
      n8 := m_Abil.MaxHP;
      m_WAbil.DC := MakeLong(LoWord(m_WAbil.DC), ROUND(m_btSlaveExpLevel * 2 +
        HiWord(m_WAbil.DC)));
      n8 := n8 + ROUND(m_Abil.MaxHP * 0.15) * m_btSlaveExpLevel;
      m_WAbil.MaxHP := _MIN(ROUND(m_Abil.MaxHP + m_btSlaveExpLevel * 60), n8);
      //m_WAbil.MAC:=0; 01/20 取消此行，防止怪物升级后魔防变0
    end;
    //m_btHitPoint:=15; 01/20 取消此行，防止怪物升级后准确率变15
  except
    MainOutMessage('[Exception] TBaseObject.MonsterRecalcAbilitys');
  end;
end;

procedure TPlayObject.ShowMapInfo(sMap, sX, sY: string);
var
  Map: TEnvirnoment;
  nX, nY: Integer;
  MapCellInfo: pTMapCellinfo;
begin
  try
    nX := Str_ToInt(sX, 0);
    nY := Str_ToInt(sY, 0);
    if (sMap <> '') and (nX >= 0) and (nY >= 0) then
    begin
      Map := g_MapManager.FindMap(sMap);
      if Map <> nil then
      begin
        if Map.GetMapCellInfo(nX, nY, MapCellInfo) then
        begin
          SysMsg('Cell Flag: ' + IntToStr(MapCellInfo.chFlag), c_Green, t_Hint);
          if MapCellInfo.ObjList <> nil then
          begin
            SysMsg('Cell Count: ' + IntToStr(MapCellInfo.ObjList.Count),
              c_Green, t_Hint);
          end;
        end
        else
        begin
          SysMsg('Failed to get cell information for map: ' + sMap, c_Red,
            t_Hint);
        end;
      end;
    end
    else
    begin
      SysMsg('请按正确格式输入: ' + g_GameCommand.MAPINFO.sCmd +
        ' 地图号 X Y', c_Green, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ShowMapInfo');
  end;
end;

procedure TBaseObject.SendFirstMsg(BaseObject: TBaseObject; wIdent, wParam:
  Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string); //004B84FC
var
  SendMessage: pTSendMessage;
begin
  try
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then
      begin
        New(SendMessage);
        SendMessage.wIdent := wIdent;
        SendMessage.wParam := wParam;
        SendMessage.nParam1 := lParam1;
        SendMessage.nParam2 := lParam2;
        SendMessage.nParam3 := lParam3;
        SendMessage.dwDeliveryTime := 0;
        SendMessage.BaseObject := BaseObject;
        if sMsg <> '' then
        begin
          try
            GetMem(SendMessage.Buff, Length(sMsg) + 1);
            Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
          except
            SendMessage.Buff := nil;
          end;
        end
        else
        begin
          SendMessage.Buff := nil;
        end;
        m_MsgList.Insert(0, SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SendFirstMsg');
  end;
end;

procedure TBaseObject.ChangeShieldMode(boAttact: Boolean);
begin
  if m_boOpenShield then
  begin
    m_boOpenShield := False;
    if g_Config.boShieldShowEffect then
      SendRefMsg(RM_SHOWEFFECT, Effect_89, Integer(Self), m_nCurrX, m_nCurrY,
        '');
    m_dwOpenShieldTick := GetTickCount;
    if boAttact then
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
        SysMsg(sShieldAttackDisappearMsg, c_Red, t_System);
    end
    else
    begin
      if m_btRaceServer = RC_PLAYOBJECT then
        SysMsg(sShieldTimeDisappearMsg, c_Red, t_System);
    end;
  end;
end;

//检查消息是否转发给英雄
function TBaseObject.CheckMsgCode(wIdent: Integer): Boolean;
begin
  try
    Result := True;
    case wIdent of
      //TBaseObject
      RM_MAGSTRUCK,
        RM_MAGSTRUCK_MINE,
        RM_MAGHEALING,
        RM_10101,
        RM_DELAYMAGIC,
        RM_10155,
        RM_DELAYPUSHED,
        RM_POISON,
        RM_TRANSPARENT,
        RM_DOOPENHEALTH,
        //TAnimalObject
      RM_STRUCK,
        //TPlayObject
      RM_10055,
        RM_HEROCHANGEGLORY,
        RM_HEROLOGIN,
        RM_ABILITY,
        RM_SUBABILITY,
        RM_SENDMYMAGIC,
        RM_HEROLOGINEX,
        RM_LEVELUP,
        RM_WINEXP,
        RM_CLOSEHERO,
        RM_HEALTHSPELLCHANGED,
        RM_MAGIC_LVEXP,
        RM_DURACHANGE,
        RM_BAG_DURACHANGE2,
        RM_DANDERCHANG,
        RM_WineValue,
        RM_MedicineValue,
        RM_SKILL84Exp,
        RM_bLiquorProgress,
        RM_DRINK,
        RM_ADDLiquor,
        RM_DRUNK,
        RM_SKILL83Value: Result := False;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.CheckMsgCode');
  end;
end;

procedure TBaseObject.SendMsg(BaseObject: TBaseObject; wIdent, wParam: Word;
  nParam1, nParam2, nParam3: Integer; sMsg: string); //004B865C
var
  SendMessage: pTSendMessage;
begin
  try
    if (m_boHero) and (CheckMsgCode(wIdent)) then
      exit;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then
      begin
        New(SendMessage);
        SendMessage.wIdent := wIdent;
        SendMessage.wParam := wParam;
        SendMessage.nParam1 := nParam1;
        SendMessage.nParam2 := nParam2;
        SendMessage.nParam3 := nParam3;
        SendMessage.dwDeliveryTime := 0;
        SendMessage.BaseObject := BaseObject;
        SendMessage.boLateDelivery := False;
        if sMsg <> '' then
        begin
          try
            GetMem(SendMessage.Buff, Length(sMsg) + 1);
            Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
          except
            SendMessage.Buff := nil;
          end;
        end
        else
        begin
          SendMessage.Buff := nil;
        end;
        {if m_boHero then
          mainoutmessage(IntToStr(wIdent));}
        m_MsgList.Add(SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SendMsg');
  end;
end;

procedure TBaseObject.SendDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord); //004B87C4
var
  SendMessage: pTSendMessage;
begin
  try
    if (m_boHero) and (CheckMsgCode(wIdent)) then
      exit;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      if not m_boGhost then
      begin
        New(SendMessage);
        SendMessage.wIdent := wIdent;
        SendMessage.wParam := wParam;
        SendMessage.nParam1 := lParam1;
        SendMessage.nParam2 := lParam2;
        SendMessage.nParam3 := lParam3;
        SendMessage.dwDeliveryTime := GetTickCount + dwDelay;
        SendMessage.BaseObject := BaseObject;
        SendMessage.boLateDelivery := True;
        if sMsg <> '' then
        begin
          try
            GetMem(SendMessage.Buff, Length(sMsg) + 1);
            Move(sMsg[1], SendMessage.Buff^, Length(sMsg) + 1);
          except
            SendMessage.Buff := nil;
          end;
        end
        else
        begin
          SendMessage.Buff := nil;
        end;
        m_MsgList.Add(SendMessage);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SendDelayMsg');
  end;
end;

procedure TBaseObject.SendUpdateDelayMsg(BaseObject: TBaseObject; wIdent,
  wParam: Word; lParam1, lParam2, lParam3: Integer; sMsg: string;
  dwDelay: LongWord); //004B8930
var
  SendMessage: pTSendMessage;
  i: integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    try
      i := 0;
      while (True) do
      begin
        if m_MsgList.Count <= i then
          break;
        SendMessage := m_MsgList.Items[i];
        if (SendMessage.wIdent = wIdent) and (SendMessage.nParam1 = lParam1)
          then
        begin
          m_MsgList.Delete(i);
          if SendMessage.Buff <> nil then
            FreeMem(SendMessage.Buff);
          Dispose(SendMessage);
          Continue;
        end;
        Inc(i);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
    SendDelayMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg,
      dwDelay);
  except
    MainOutMessage('[Exception] TBaseObject.SendUpdateDelayMsg');
  end;
end;

procedure TBaseObject.SendUpdateMsg(BaseObject: TBaseObject; wIdent, wParam:
  Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string); //004B8A7C
var
  SendMessage: pTSendMessage;
  i: Integer;
begin
  try
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      i := 0;
      while (True) do
      begin
        if m_MsgList.Count <= i then
          break;
        SendMessage := m_MsgList.Items[i];
        if SendMessage.wIdent = wIdent then
        begin
          m_MsgList.Delete(i);
          if SendMessage.Buff <> nil then
            FreeMem(SendMessage.Buff);
          Dispose(SendMessage);
          Continue;
        end;
        Inc(i);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
    SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
  except
    MainOutMessage('[Exception] TBaseObject.SendUpdateMsg');
  end;
end;

procedure TBaseObject.SendActionMsg(BaseObject: TBaseObject; wIdent, wParam:
  Word;
  lParam1, lParam2, lParam3: Integer; sMsg: string); //004B8A7C
var
  SendMessage: pTSendMessage;
  i: Integer;
begin
  try
    EnterCriticalSection(ProcessMsgCriticalSection);
    try
      i := 0;
      while (True) do
      begin
        if m_MsgList.Count <= i then
          break;
        SendMessage := m_MsgList.Items[i];
        if (SendMessage.wIdent = CM_TURN) or
          (SendMessage.wIdent = CM_WALK) or
          (SendMessage.wIdent = CM_SITDOWN) or
          (SendMessage.wIdent = CM_HORSERUN) or
          (SendMessage.wIdent = CM_RUN) or
          (SendMessage.wIdent = CM_HIT) or
          (SendMessage.wIdent = CM_HEAVYHIT) or
          (SendMessage.wIdent = CM_BIGHIT) or
          (SendMessage.wIdent = CM_POWERHIT) or
          (SendMessage.wIdent = CM_LONGHIT) or
          (SendMessage.wIdent = CM_WIDEHIT) or
          (SendMessage.wIdent = CM_CRSHIT) or
          (SendMessage.wIdent = CM_TWINHIT) or
          (SendMessage.wIdent = CM_LONGSWORD1) or
          (SendMessage.wIdent = CM_LONGSWORD2) or
          (SendMessage.wIdent = CM_LONGFIRESWORD) or
          (SendMessage.wIdent = CM_FIREHIT) then
        begin
          m_MsgList.Delete(i);
          if SendMessage.Buff <> nil then
            FreeMem(SendMessage.Buff);
          Dispose(SendMessage);
          Continue;
        end;
        Inc(i);
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
    SendMsg(BaseObject, wIdent, wParam, lParam1, lParam2, lParam3, sMsg);
  except
    MainOutMessage('[Exception] TBaseObject.SendActionMsg');
  end;
end;

function TBaseObject.GetMessage(Msg: pTProcessMessage): Boolean;
//004B8BA4($FFFF)
var
  I: Integer;
  SendMessage: pTSendMessage;
  //  wIdent:integer;
begin
  try
    Result := False;
    //  SendMessage:=Nil;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      try
        I := 0;
        Msg.wIdent := 0;
        while m_MsgList.Count > I do
        begin
          SendMessage := m_MsgList.Items[I];
          if (SendMessage.dwDeliveryTime <> 0) and (GetTickCount <
            SendMessage.dwDeliveryTime) then
          begin
            Inc(I);
            Continue;
          end;
          m_MsgList.Delete(I);
          Msg.wIdent := SendMessage.wIdent;
          Msg.wParam := SendMessage.wParam;
          Msg.nParam1 := SendMessage.nParam1;
          Msg.nParam2 := SendMessage.nParam2;
          Msg.nParam3 := SendMessage.nParam3;
          Msg.BaseObject := SendMessage.BaseObject;
          Msg.dwDeliveryTime := SendMessage.dwDeliveryTime;
          Msg.boLateDelivery := SendMessage.boLateDelivery;
          if SendMessage.Buff <> nil then
          begin
            Msg.sMsg := StrPas(SendMessage.Buff);
            FreeMem(SendMessage.Buff);
          end
          else
          begin
            Msg.sMsg := '';
          end;
          Dispose(SendMessage);
          Result := True;
          break;
        end;
      finally
        LeaveCriticalSection(ProcessMsgCriticalSection);
      end;
    except
      Inc(g_MsgErrorCount);
      MakeGhost;
      //MainOutMessage('[Exception] TBaseObject.GetMessage ' + IntToStr(nCheckCode));
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetMessage');
  end;
end;

function TBaseObject.GetMapBaseObjectCount(tEnvir: TEnvirnoment; nX, nY:
  Integer; nRage: Integer): Integer;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::GetMapBaseObjectCount';
var
  nStartX, nStartY, nEndX, nEndY: Integer;
  x, y: Integer;
  MapCellInfo: pTMapCellinfo;
  III: Integer;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  try
    Result := 0;
    try
      nStartX := nX - nRage;
      nEndX := nX + nRage;
      nStartY := nY - nRage;
      nEndY := nY + nRage;
      for x := nStartX to nEndX do
      begin
        for y := nStartY to nEndY do
        begin
          if tEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList
            <> nil) then
          begin
            for III := 0 to MapCellInfo.ObjList.Count - 1 do
            begin
              OSObject := MapCellInfo.ObjList.Items[III];
              if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
              begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) and
                  (not BaseObject.m_boDeath) and
                  (not BaseObject.m_boGhost) and
                  (IsProperTarget(BaseObject)) then
                begin
                  Inc(Result);
                end;
              end;
            end;
          end;
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetMapBaseObjectCount');
  end;
end;

function TBaseObject.GetMapBaseObjects(tEnvir: TEnvirnoment; nX, nY, nRage:
  Integer; rList: TList): Boolean; //004B8D2C
var
  III: Integer;
  x, y: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::GetMapBaseObjects';
begin
  try
    Result := False;
    if rList = nil then
      exit;
    try
      nStartX := nX - nRage;
      nEndX := nX + nRage;
      nStartY := nY - nRage;
      nEndY := nY + nRage;
      for x := nStartX to nEndX do
      begin
        for y := nStartY to nEndY do
        begin
          if tEnvir.GetMapCellInfo(x, y, MapCellInfo) and (MapCellInfo.ObjList
            <> nil) then
          begin
            for III := 0 to MapCellInfo.ObjList.Count - 1 do
            begin
              OSObject := MapCellInfo.ObjList.Items[III];
              if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
              begin
                BaseObject := TBaseObject(OSObject.CellObj);
                if (BaseObject <> nil) and (not BaseObject.m_boDeath) and (not
                  BaseObject.m_boGhost) then
                begin
                  rList.Add(BaseObject);
                end;
              end;
            end;
          end;
        end;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
    Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.GetMapBaseObjects');
  end;
end;

procedure TBaseObject.SendRefMsg(wIdent, wParam: Word; nParam1, nParam2,
  nParam3: Integer; sMsg: string); //004B8EBC
var
  II, nC: Integer;
  nCX, nCY, nLX, nLY, nHX, nHY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  nCheckCode: Byte;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::SendRefMsg Name = %s';
  sExceptionMsg1 = '[Exception] TBaseObject::SendRefMsg Name = %s/%d';
begin
  try
    nCheckCode := 0;
    try

      if m_PEnvir = nil then
      begin
        MainOutMessage(m_sCharName + ' SendRefMsg nil PEnvir ');
        exit;
      end;
      //if m_boObMode or m_boFixedHideMode then exit;
      //01/21 增加，原来直接不发信息，如果隐身模式则只发送信息给自己
      nCheckCode := 1;
      if m_boObMode or m_boFixedHideMode then
      begin
        SendMsg(Self, wIdent, wParam, nParam1, nParam2, nParam3, sMsg);
        exit;
      end;
      nCheckCode := 2;
      EnterCriticalSection(ProcessMsgCriticalSection);
      try
        nCheckCode := 3;
        if ((GetTickCount - m_SendRefMsgTick) >= 500) or
          (m_VisibleHumanList.Count = 0) then
        begin
          m_SendRefMsgTick := GetTickCount();
          m_VisibleHumanList.Clear;
          nCheckCode := 4;
          nLX := m_nCurrX - g_Config.nSendRefMsgRange {12};
          nHX := m_nCurrX + g_Config.nSendRefMsgRange {12};
          nLY := m_nCurrY - g_Config.nSendRefMsgRange {12};
          nHY := m_nCurrY + g_Config.nSendRefMsgRange {12};
          for nCX := nLX to nHX do
          begin
            for nCY := nLY to nHY do
            begin
              nCheckCode := 5;
              if m_PEnvir.GetMapCellInfo(nCX, nCY, MapCellInfo) then
              begin
                nCheckCode := 6;
                if MapCellInfo.ObjList <> nil then
                begin
                  nCheckCode := 7;
                  for II := MapCellInfo.ObjList.Count - 1 downto 0 do
                  begin
                    //nCheckCode:=88;
                    //if MapCellInfo.ObjList.Count <= II then break; //Jason 0710
                    nCheckCode := 8;
                    OSObject := MapCellInfo.ObjList.Items[II];
                    nCheckCode := 9;
                    if OSObject <> nil then
                    begin
                      nCheckCode := 10;
                      if OSObject.btType = OS_MOVINGOBJECT then
                      begin
                        nCheckCode := 11;
                        if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then
                        begin
                          nCheckCode := 12;
                          DisPose(OSObject);
                          MapCellInfo.ObjList.Delete(II);
                          if MapCellInfo.ObjList.Count <= 0 then
                          begin
                            MapCellInfo.ObjList.Free;
                            MapCellInfo.ObjList := nil;
                            break;
                          end;
                          nCheckCode := 13;
                        end
                        else
                        begin //004B90A4
                          try
                            nCheckCode := 14;
                            BaseObject := TBaseObject(OSObject.CellObj);
                            nCheckCode := 15;
                            if (BaseObject <> nil) and (not BaseObject.m_boGhost)
                              then
                            begin
                              nCheckCode := 16;
                              if (BaseObject.m_btRaceServer = RC_PLAYOBJECT)
                                then
                              begin
                                BaseObject.SendMsg(Self, wIdent, wParam,
                                  nParam1, nParam2, nParam3, sMsg);
                                m_VisibleHumanList.Add(BaseObject);
                              end
                              else if BaseObject.m_boWantRefMsg then
                              begin
                                if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR)
                                  or (wIdent = RM_DEATH) then
                                begin
                                  BaseObject.SendMsg(Self, wIdent, wParam,
                                    nParam1, nParam2, nParam3, sMsg);
                                  m_VisibleHumanList.Add(BaseObject);
                                end;
                              end;
                            end;
                            nCheckCode := 17;
                          except
                            on e: Exception do
                            begin
                              MainOutMessage(format(sExceptionMsg,
                                [m_sCharName]));
                              MainOutMessage(E.Message);
                              {MapCellInfo.ObjList.Delete(II);
                              if MapCellInfo.ObjList.Count <= 0 then begin
                                MapCellInfo.ObjList.Free;
                                MapCellInfo.ObjList:=Nil;
                              end;}
                            end;
                          end;
                          nCheckCode := 18;
                        end;
                      end;
                    end;
                  end; //for I := 0 to MapCellInfo.ObjList.Count - 1 do begin
                end; //if MapCellInfo.ObjList <> nil then begin
              end; //if PEnvir.GetMapCellInfo(nC,n10,MapCellInfo) then begin
            end;
          end;
          exit;
        end; //004B91FC
        nCheckCode := 19;
        for nC := 0 to m_VisibleHumanList.Count - 1 do
        begin
          nCheckCode := 20;
          BaseObject := TBaseObject(m_VisibleHumanList.Items[nC]);
          nCheckCode := 21;
          if (BaseObject.m_boGhost) then
            Continue;
          nCheckCode := 22;
          if (BaseObject.m_PEnvir = m_PEnvir) and
            (abs(BaseObject.m_nCurrX - m_nCurrX) < 11) and
            (abs(BaseObject.m_nCurrY - m_nCurrY) < 11) then
          begin
            nCheckCode := 23;
            if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
            begin
              nCheckCode := 24;
              BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2,
                nParam3, sMsg);
            end
            else if BaseObject.m_boWantRefMsg then
            begin
              nCheckCode := 25;
              if (wIdent = RM_STRUCK) or (wIdent = RM_HEAR) or (wIdent =
                RM_DEATH) then
              begin
                nCheckCode := 26;
                BaseObject.SendMsg(Self, wIdent, wParam, nParam1, nParam2,
                  nParam3, sMsg);
              end;
            end; //if BaseObject.m_boWantRefMsg then begin
            nCheckCode := 27;
          end; //if (BaseObject.m_PEnvir = m_PEnvir) and
        end; //for nC:= 0 to m_VisibleHumanList.Count - 1 do begin
      finally
        LeaveCriticalSection(ProcessMsgCriticalSection);
      end;
    except
      MainOutMessage(format(sExceptionMsg1, [m_sCharName, nCheckCode]));
      //MainOutMessage(E.Message);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SendRefMsg');
  end;
end;

procedure TBaseObject.UpdateVisibleGay(BaseObject: TBaseObject); //004B939C
var
  I: Integer;
  boIsVisible: Boolean;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  try
    boIsVisible := False;
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
      ((BaseObject.m_AllMaster <> nil) and (BaseObject.m_AllMaster.m_btRaceServer
      = RC_PLAYOBJECT)) then
      m_boIsVisibleActive := True; //如果是人物或宝宝则置TRUE
    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      VisibleBaseObject := m_VisibleActors.Items[i];
      if VisibleBaseObject.BaseObject = BaseObject then
      begin
        VisibleBaseObject.nVisibleFlag := 1;
        boIsVisible := True;
        break;
      end;
    end;
    if boIsVisible then
      exit;
    New(VisibleBaseObject);
    VisibleBaseObject.nVisibleFlag := 2;
    VisibleBaseObject.BaseObject := BaseObject;
    m_VisibleActors.Add(VisibleBaseObject);
  except
    MainOutMessage('[Exception] TBaseObject.UpdateVisibleGay');
  end;
end;

procedure TBaseObject.UpdateVisibleItem(wX, wY: Integer; MapItem: PTMapItem);
//004B94FC
var
  I: Integer;
  boIsVisible: Boolean;
  VisibleMapItem: pTVisibleMapItem;
begin
  try
    boIsVisible := False;
    for I := 0 to m_VisibleItems.Count - 1 do
    begin
      VisibleMapItem := m_VisibleItems.Items[i];
      if VisibleMapItem.MapItem = MapItem then
      begin
        VisibleMapItem.nX := wX;
        VisibleMapItem.nY := wY;
        VisibleMapItem.nVisibleFlag := 1;
        boIsVisible := True;
        break;
      end;
    end;
    if boIsVisible then
      exit;
    New(VisibleMapItem);
    VisibleMapItem.nVisibleFlag := 2;
    VisibleMapItem.nX := wX;
    VisibleMapItem.nY := wY;
    VisibleMapItem.MapItem := MapItem;
    VisibleMapItem.sName := MapItem.Name;
    VisibleMapItem.wLooks := MapItem.Looks;
    m_VisibleItems.Add(VisibleMapItem);
  except
    MainOutMessage('[Exception] TBaseObject.UpdateVisibleItem');
  end;
end;

procedure TBaseObject.UpdateVisibleEvent(wX, wY: Integer; MapEvent: TObject);
//004B95D0
var
  I: Integer;
  boIsVisible: Boolean;
  Event: TEvent;
begin
  try
    boIsVisible := False;
    for I := 0 to m_VisibleEvents.Count - 1 do
    begin
      Event := m_VisibleEvents.Items[i];
      if Event = MapEvent then
      begin
        Event.nVisibleFlag := 1;
        boIsVisible := True;
        break;
      end;
    end;
    if boIsVisible then
      exit;
    TEvent(MapEvent).nVisibleFlag := 2;
    TEvent(MapEvent).m_nX := wX;
    TEvent(MapEvent).m_nY := wY;
    m_VisibleEvents.Add(MapEvent);
  except
    MainOutMessage('[Exception] TBaseObject.UpdateVisibleEvent');
  end;
end;

function TBaseObject.IsVisibleHuman: Boolean;
var
  I: Integer;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  try
    Result := False;
    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      VisibleBaseObject := m_VisibleActors.Items[i];
      if (VisibleBaseObject.BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
        ((VisibleBaseObject.BaseObject.m_AllMaster <> nil) and
        (VisibleBaseObject.BaseObject.m_AllMaster.m_btRaceServer =
        RC_PLAYOBJECT)) then
      begin
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsVisibleHuman:');
  end;
end;

procedure TBaseObject.SearchViewRange; //004B966C
var
  I: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  n24: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  // MapItem     :PTMapItem;
 //  MapEvent    :TEvent;
  VisibleBaseObject: pTVisibleBaseObject;
  nCheckCode: Integer;
  btType: Byte;
resourcestring
  sExceptionMsg1 = '[Exception] TBaseObject::SearchViewRange Code:%d';
  sExceptionMsg2 =
    '[Exception] TBaseObject::SearchViewRange 1-%d %s %s %d %d %d';
  sExceptionMsg3 =
    '[Exception] TBaseObject::SearchViewRange %d %s %s %d %d %d %d';

begin
  nCheckCode := 0;
  btType := 0;
  try
    nCheckCode := 0;
    if m_PEnvir = nil then
    begin
      MainOutMessage('SearchViewRange nil PEnvir');
      exit;
    end;
    nCheckCode := 1;
    n24 := 0;
    m_boIsVisibleActive := False; //先置为FALSE
    try
      nCheckCode := 4;
      for I := 0 to m_VisibleActors.Count - 1 do
      begin
        pTVisibleBaseObject(m_VisibleActors.Items[I]).nVisibleFlag := 0;
      end;
      nCheckCode := 5;
      {m_VisibleHumanList.Clear;      //0x3D8
      m_VisibleItems.Clear;      //0x3DC
      m_VisibleEvents.Clear;}
    except
      MainOutMessage(format(sExceptionMsg1, [nCheckCode]));
      KickException();
    end;
    nCheckCode := 6;

    //nStartX :=m_nCurrX - m_nViewRange2;
    //nEndX   :=m_nCurrX + m_nViewRange2;
    //nStartY :=m_nCurrY - m_nViewRange2;
    //nEndY   :=m_nCurrY + m_nViewRange2;
    if m_Master2 <> nil then
    begin
      nStartX := m_nCurrX - 10;
      nEndX := m_nCurrX + 10;
      nStartY := m_nCurrY - 10;
      nEndY := m_nCurrY + 10;
    end
    else
    begin
      nStartX := m_nCurrX - m_nViewRange;
      nEndX := m_nCurrX + m_nViewRange;
      nStartY := m_nCurrY - m_nViewRange;
      nEndY := m_nCurrY + m_nViewRange;
    end;

    try
      nCheckCode := 7;
      for n18 := nStartX to nEndX do
      begin
        nCheckCode := 8;
        for n1C := nStartY to nEndY do
        begin
          nCheckCode := 9;
          if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and
            (MapCellInfo.ObjList <> nil) then
          begin
            nCheckCode := 10;
            n24 := 1;
            nIdx := 0;
            while (True) do
            begin
              nCheckCode := 11;
              if (MapCellInfo.ObjList <> nil) and (MapCellInfo.ObjList.Count <=
                0) then
              begin //200-11-1 增加
                MapCellInfo.ObjList.Free;
                MapCellInfo.ObjList := nil;
                Break;
              end;
              if MapCellInfo.ObjList.Count <= nIdx then
                break; //004B9858
              nCheckCode := 111;
              OSObject := MapCellInfo.ObjList.Items[nIdx];
              nCheckCode := 12;
              if OSObject <> nil then
              begin
                nCheckCode := 13;
                try
                  btType := OSObject.btType; //2007-8-20 防止内存出错
                except
                  Inc(g_MemErrorCount);
                  MapCellInfo.ObjList.Delete(nIdx);
                  Continue;
                end;
                if OSObject.btType = OS_ITEMOBJECT then
                begin
                  nCheckCode := 21;
                  if (GetTickCount - OSObject.dwAddTime) >
                    g_Config.dwClearDropOnFloorItemTime {60 * 60 * 1000} then
                  begin
                    Dispose(pTMapItem(OSObject.CellObj));
                    //Jacky 10/22  防止占用内存不释放现象
                    Dispose(OSObject);
                    MapCellInfo.ObjList.Delete(nIdx);
                    if MapCellInfo.ObjList.Count > 0 then
                      Continue;
                    MapCellInfo.ObjList.Free;
                    MapCellInfo.ObjList := nil;
                    break;
                  end;
                end
                else if OSObject.btType = OS_MOVINGOBJECT then
                begin
                  nCheckCode := 14;
                  if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then
                  begin
                    DisPose(OSObject);
                    MapCellInfo.ObjList.Delete(nIdx);
                    if MapCellInfo.ObjList.Count > 0 then
                      Continue;
                    MapCellInfo.ObjList.Free;
                    MapCellInfo.ObjList := nil;
                    break;
                  end; //004B9907
                  nCheckCode := 15;
                  BaseObject := TBaseObject(OSObject.CellObj);
                  if BaseObject <> nil then
                  begin
                    nCheckCode := 16;
                    if not BaseObject.m_boGhost and not
                      BaseObject.m_boFixedHideMode and not BaseObject.m_boObMode
                        then
                    begin
                      nCheckCode := 17;
                      if (m_btRaceServer < RC_ANIMAL) or
                        ((m_AllMaster <> nil) and (m_AllMaster.m_btRaceServer =
                        RC_PLAYOBJECT)) or
                        m_boCrazyMode or
                        m_boNastyMode or
                        m_boWantRefMsg or
                        ((BaseObject.m_AllMaster <> nil) and
                        (BaseObject.m_AllMaster.m_btRaceServer = RC_PLAYOBJECT)
                        and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and
                        (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                        (BaseObject.m_btRaceServer = RC_PLAYOBJECT) then
                      begin
                        nCheckCode := 18;
                        UpdateVisibleGay(BaseObject);
                        nCheckCode := 19;
                      end;
                    end;
                  end;
                end;
              end;
              Inc(nIdx);
            end;
          end;
        end;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName,
          m_nCurrX, m_nCurrY, nCheckCode, btType]));
        MainOutMessage(E.Message);
        KickException();
      end;
    end;

    nCheckCode := 40;
    n24 := 2;
    try
      n18 := 0;
      while (True) do
      begin
        if m_VisibleActors.Count <= n18 then
          break;
        nCheckCode := 41;
        VisibleBaseObject := m_VisibleActors.Items[n18];
        nCheckCode := 42;
        if VisibleBaseObject = nil then
        begin
          m_VisibleActors.Delete(n18);
          Continue;
        end;
        if VisibleBaseObject.nVisibleFlag = 0 then
        begin
          nCheckCode := 43;
          m_VisibleActors.Delete(n18);
          nCheckCode := 48;
          Dispose(VisibleBaseObject);
          nCheckCode := 49;
          Continue;
        end;
        nCheckCode := 50;
        Inc(n18);
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName,
          m_nCurrX, m_nCurrY, nCheckCode]));
        {MainOutMessage(m_sCharName + ',' +
                       m_sMapName + ',' +
                       IntToStr(m_nCurrX) + ',' +
                       IntToStr(m_nCurrY) + ',' +
                       ' SearchViewRange 2');}
        KickException();
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SearchViewRange ' +
      IntToStr(nCheckCode));
  end;
end;

function TBaseObject.GetFeatureToLong: Integer; //004BA23C
begin
  try
    Result := GetFeature(nil);
  except
    MainOutMessage('[Exception] TBaseObject.GetFeatureToLong:');
  end;
end;

function TBaseObject.GetFeatureEx(): Word;
begin
  try
    if m_boOnHorse then
    begin
      Result := MakeWord(m_btHorseType, m_btDressEffType);
    end
    else
    begin
      Result := MakeWord(0, m_btDressEffType);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetFeatureEx');
  end;
end;

function TBaseObject.GetFeature(BaseObject: TBaseObject): Integer; //004BA25C
var
  nDress, nWeapon, nHair {,nRaceImg,nAppr}: Integer;
  StdItem: TItem;
  //  bo25:Boolean;
  //  I:integer;
begin
  try
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      nDress := 0;
      //衣服
      if m_UseItems[U_DRESS].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
        if StdItem <> nil then
        begin
          nDress := StdItem.Shape * 2;
        end;
      end;
      Inc(nDress, m_btGender);
      nWeapon := 0;
      //武器
      if m_UseItems[U_WEAPON].wIndex > 0 then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
        if StdItem <> nil then
        begin
          nWeapon := StdItem.Shape * 2;
        end;
      end;
      Inc(nWeapon, m_btGender);

      {if m_dwClientTickEx > 20070701  then begin //Jason
        if m_UseItems[U_STRAW].wIndex > 0 then nHair:=3
        else nHair:=m_btHair;
      end else}
      nHair := m_btHair * 2 + m_btGender;
      if m_dwClientTickEx > 20070801 then
      begin
        if m_UseItems[U_STRAW].wIndex > 0 then
        begin
         StdItem := UserEngine.GetStdItem(m_UseItems[U_STRAW].wIndex);
          if StdItem <> nil then
          if StdItem.Shape=0 then
            nHair := 6 + m_btGender
          else
            nHair := 8 + m_btGender;//王者斗笠
        end;
      end;
      Result := MakeHumanFeature(0, nDress, nWeapon, nHair);
      try
        if Assigned(m_HookGetFeature) then
          Result := m_HookGetFeature(Self, BaseObject);
      except
        MainOutMessage('[Exception] TBaseObject.GetFeature->ApiHook');
      end;
      exit;
    end; //004BA32F

    {bo25:=False;
    if (BaseObject <> nil) and (BaseObject.bo245) then
      bo25:=True;
    if bo25 then begin
      nRaceImg:=m_btRaceImg;
      nAppr:=m_wAppr;
      case nAppr of
        0: begin
          nRaceImg:=12;
          nAppr:=5;
        end;
        1: begin
          nRaceImg:=11;
          nAppr:=9;
        end;
        160: begin
          nRaceImg:=10;
          nAppr:=0;
        end;
        161: begin
          nRaceImg:=10;
          nAppr:=1;
        end;
        162: begin
          nRaceImg:=11;
          nAppr:=6;
        end;
        163: begin
          nRaceImg:=11;
          nAppr:=3;
        end;
      end;

      Result:=MakeMonsterFeature(nRaceImg,m_btMonsterWeapon,nAppr);
      exit;
    end;//004BA40E }

    Result := MakeMonsterFeature(m_btRaceImg, m_btMonsterWeapon, m_wAppr);
  except
    MainOutMessage('[Exception] TBaseObject.GetFeature');
  end;
end;

function TBaseObject.GetCharStatus(): Integer; //004BA43C
var
  I: Integer;
  nStatus: Integer;
begin
  try
    nStatus := 0;
    for I := Low(TStatusTime) to High(TStatusTime) do
    begin
      if m_wStatusTimeArr[I] > 0 then
      begin
        nStatus := ($80000000 shr I) or LongWord(nStatus);
      end;
    end;
    Result := (m_nCharStatusEx and $FFFFF) or nStatus;
  except
    MainOutMessage('[Exception] TBaseObject.GetCharStatus');
  end;
end;

procedure TBaseObject.AbilCopyToWAbil; //004BA494
begin
  try
    m_WAbil := m_Abil;
  except
    MainOutMessage('[Exception] TBaseObject.AbilCopyToWAbil');
  end;
end;

procedure TBaseObject.Initialize; //4BA4B8
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  try
    AbilCopyToWAbil();
    for I := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[i];
      if (UserMagic.btLevel >= 4) then
        UserMagic.btLevel := 0;
    end;
    m_boAddtoMapSuccess := True;
    if m_PEnvir.CanWalk(m_nCurrX, m_nCurrY, True) and AddToMap() then
      m_boAddtoMapSuccess := False;
    m_nCharStatus := GetCharStatus();
    AddBodyLuck(0);
    if not m_boHero then
    begin
      LoadSayMsg();
      if g_Config.boMonSayMsg then
        MonsterSayMsg(nil, s_MonGen);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.Initialize');
  end;
end;
//==============================
//取得怪物说话信息列表

procedure TBaseObject.LoadSayMsg();
var
  I: Integer;
begin
  try
    for I := 0 to g_MonSayMsgList.Count - 1 do
    begin
      if CompareText(g_MonSayMsgList.Strings[I], m_sCharName) = 0 then
      begin
        m_SayMsgList := TList(g_MonSayMsgList.Objects[I]);
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.LoadSayMsg');
  end;
end;

procedure TBaseObject.Disappear(); //004BA580
begin
  try

  except
    MainOutMessage('[Exception] TBaseObject.Disappear');
  end;
end;

procedure TBaseObject.FeatureChanged; //004BA58C
begin
  try
    SendRefMsg(RM_FEATURECHANGED, GetFeatureEx, GetFeatureToLong, 0, 0, '')
  except
    MainOutMessage('[Exception] TBaseObject.FeatureChanged');
  end;
end;

procedure TBaseObject.StatusChanged(); //004BA5B4
begin
  try
    SendRefMsg(RM_CHARSTATUSCHANGED, m_nHitSpeed, m_nCharStatus, 0, 0, '')
  except
    MainOutMessage('[Exception] TBaseObject.StatusChanged');
  end;
end;

procedure TBaseObject.DisappearA(); //004BA65C
begin
  try
    m_PEnvir.DeleteFromMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
    SendRefMsg(RM_DISAPPEAR, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.DisappearA');
  end;
end;

procedure TBaseObject.KickException; //004BA6A8
begin
  try
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      m_sMapName := g_Config.sHomeMap;
      m_nCurrX := g_Config.nHomeX;
      m_nCurrY := g_Config.nHomeY;
      TPlayObject(self).m_boEmergencyClose := TRUE;
    end
    else
    begin //
      m_boDeath := True;
      m_dwDeathTick := GetTickCount;
      MakeGhost;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.KickException');
  end;
end;

function TBaseObject.Walk(nIdent: Integer): Boolean; //004BA724
var
  I: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  GateObj: pTGateObj;
  bo1D: Boolean;
  Event: TEvent;
  PlayObject: TPlayObject;
  nCheckCode: Integer;
  MapEvent: pTMapEvent;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::Walk  CheckCode:%d %s %s %d:%d';
begin
  try
    Result := True;
    nCheckCode := -1;
    if m_PEnvir = nil then
    begin
      MainOutMessage('Walk nil PEnvir');
      exit;
    end;
    try
      nCheckCode := 1;
      bo1D := m_PEnvir.GetMapCellInfo(m_nCurrX, m_nCurrY, MapCellInfo);
      GateObj := nil;
      Event := nil;
      FOUNTAINEvent:=nil;
      MapEvent := nil;
      nCheckCode := 2;
      if bo1D and (MapCellInfo.ObjList <> nil) then
      begin
        for I := 0 to MapCellInfo.ObjList.Count - 1 do
        begin
          OSObject := MapCellInfo.ObjList.Items[i];
          if OSObject.btType = OS_GATEOBJECT then
          begin
            GateObj := pTGateObj(OSObject.CellObj);
          end
          else if OSObject.btType = OS_EVENTOBJECT then
          begin
            if TEvent(OSObject.CellObj).m_OwnBaseObject <> nil then
              Event := TEvent(OSObject.CellObj);
            if TEvent(OSObject.CellObj).m_nEventType=ET_FOUNTAIN then
              FOUNTAINEvent:= OSObject.CellObj;//地图上有无泉水事件
          end
          else if (OSObject.btType = OS_WALK) and (nIdent = RM_WALK) then
          begin
            MapEvent := pTMapEvent(OSObject.CellObj);
          end
          else if (OSObject.btType = OS_RUN) and (nIdent = RM_RUN) then
          begin
            MapEvent := pTMapEvent(OSObject.CellObj);
          end
          else if (OSObject.btType = OS_HORSERUN) and (nIdent = RM_HORSERUN)
            then
          begin
            MapEvent := pTMapEvent(OSObject.CellObj);
          end;
        end;
      end;
      nCheckCode := 3;
      if Event <> nil then
      begin
        if Event.m_OwnBaseObject.IsProperTarget(Self) then //FFF4
          SendMsg(Event.m_OwnBaseObject, RM_MAGSTRUCK_MINE, 0, Event.m_nDamage,
            0, 0, '');
      end;
      if (FOUNTAINEvent<> nil) and (TEvent(FOUNTAINEvent).m_nX=m_nCurrX) and (TEvent(FOUNTAINEvent).m_nY=m_nCurrY) then
         m_bomapFOUNTAIN:=True //地图上泉水事件不为空并且坐标相同就是站在泉水上
      else
         m_bomapFOUNTAIN:=False;
      nCheckCode := 4;
      if Result and (GateObj <> nil) then
      begin
        if (m_btRaceServer = RC_PLAYOBJECT) and (not m_boHero) then
        begin
          if m_PEnvir.ArroundDoorOpened(m_nCurrX, m_nCurrY) then
          begin
            //004BA89E
            if (not TEnvirnoment(GateObj.DEnvir).Flag.boNEEDHOLE) or
              (g_EventManager.GetEvent(m_PEnvir, m_nCurrX, m_nCurrY,
              ET_DIGOUTZOMBI) <> nil) then
            begin
              if nServerIndex = TEnvirnoment(GateObj.DEnvir).nServerIndex then
              begin
                if not EnterAnotherMap(TEnvirnoment(GateObj.DEnvir),
                  GateObj.nDMapX, GateObj.nDMapY) then
                begin
                  Result := False;
                end;
              end
              else
              begin //004BA914
                DisappearA();
                m_bo316 := True;
                PlayObject := TPlayObject(Self);
                PlayObject.m_sSwitchMapName :=
                  TEnvirnoment(GateObj.DEnvir).sMapName;
                PlayObject.m_nSwitchMapX := GateObj.nDMapX;
                PlayObject.m_nSwitchMapY := GateObj.nDMapY;
                PlayObject.m_boSwitchData := True;
                PlayObject.m_nServerIndex :=
                  TEnvirnoment(GateObj.DEnvir).nServerIndex;
                PlayObject.m_boEmergencyClose := True;
                PlayObject.m_boReconnection := True;
              end;
            end;
          end;
        end
        else
          Result := False;
      end
      else
      begin //004BA998
        nCheckCode := 5;
        if Result then
        begin
          nCheckCode := 6;
          SendRefMsg(nIdent, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
          if (MapEvent <> nil) and (m_btRaceServer = RC_PLAYOBJECT) and (not
            m_boHero) then
          begin
            if Random(MapEvent.nRate) = 0 then
            begin
              if (MapEvent.nFlag = -1) or (GetQuestFalgStatus(MapEvent.nFlag) =
                MapEvent.btValue) then
              begin
                if (not MapEvent.boGroup) or (MapEvent.boGroup and (m_GroupOwner
                  <> nil)) then
                begin
                  if MapEvent.boEvent then
                    NpcGotoLable(g_FunctionNPC, MapEvent.sEvent, False);
                end;
              end;
            end;
          end;
        end;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg, [nCheckCode, m_sCharname,
          m_sMapName, m_nCurrX, m_nCurrY]));
        {MainOutMessage('[Exception] TBaseObject.Walk  CheckCode: ' + IntToStr(nCheckCode) + ' ' +
                      m_sCharname + ' ' +
                      m_sMapName + ' ' +
                      IntToStr(m_nCurrX) + ':' +
                      IntToStr(m_nCurrY));}
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.Walk');
  end;
end;

function TBaseObject.EnterAnotherMap(Envir: TEnvirnoment; nDMapX,
  nDMapY: Integer): Boolean; //004BAADC
var
  I: Integer;
  MapCellInfo: pTMapCellinfo;
  OldEnvir: TEnvirnoment;
  nOldX: Integer;
  nOldY: Integer;
  Castle: TUserCastle;
  PlayObject: TPlayObject;
resourcestring
  sExceptionMsg1 =
    '[Exception] TBaseObject::EnterAnotherMap -> MsgTargetList Clear';
  sExceptionMsg2 =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Dispose';
  sExceptionMsg3 =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleItems Clear';
  sExceptionMsg4 =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleEvents Clear';
  sExceptionMsg5 =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Dispose';
  sExceptionMsg6 =
    '[Exception] TBaseObject::EnterAnotherMap -> VisbleActors Clear';
  sExceptionMsg7 = '[Exception] TBaseObject::EnterAnotherMap';
begin
  try
    Result := False;
    try
      if (m_btRaceServer = RC_PLAYOBJECT) and
        (Assigned(m_HookEnterAnotherMap)) and
        (not m_HookEnterAnotherMap(Self, Envir, nDMapX, nDMapY)) then
        exit;
    except
      MainOutMessage('[Exception] TBaseObject.EnterAnotherMap->HookApi');
    end;
    try
      if m_Abil.Level < Envir.nRequestLevel then
        exit;
      if (Envir.QuestNPC <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        TMerchant(Envir.QuestNPC).Click(TPlayObject(Self));
      end;
      if Envir.Flag.nNEEDSETONFlag >= 0 then
      begin
        if GetQuestFalgStatus(Envir.Flag.nNEEDSETONFlag) <> Envir.Flag.nNeedONOFF
          then
          exit;
      end;
      if not Envir.GetMapCellInfo(nDMapX, nDMapY, MapCellInfo) then
        exit;
      Castle := g_CastleManager.IsCastlePalaceEnvir(Envir);
      if (Castle <> nil) and (m_btRaceServer = RC_PLAYOBJECT) then
      begin
        if not Castle.CheckInPalace(m_nCurrX, m_nCurrY, Self) then
          exit;
      end;
      {
      if (UserCastle.m_MapPalace = Envir) and (m_btRaceServer = RC_PLAYOBJECT) then begin
        if not UserCastle.CheckInPalace(m_nCurrX,m_nCurrY,Self) then exit;
      end;
      }
      if Envir.Flag.boNOHORSE then
        m_boOnHorse := False;
      OldEnvir := m_PEnvir;
      nOldX := m_nCurrX;
      nOldY := m_nCurrY;
      DisappearA();
      try
        m_VisibleHumanList.Clear;
      except
        MainOutMessage(sExceptionMsg1);
      end;
      try
        for I := 0 to m_VisibleItems.Count - 1 do
        begin
          Dispose(pTVisibleMapItem(m_VisibleItems.Items[i]));
        end;
      except
        MainOutMessage(sExceptionMsg2);
      end;
      try
        m_VisibleItems.Clear;
      except
        MainOutMessage(sExceptionMsg3);
      end;

      try
        m_VisibleEvents.Clear;
      except
        MainOutMessage(sExceptionMsg4);
      end;
      try
        for I := 0 to m_VisibleActors.Count - 1 do
        begin
          Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
        end;
      except
        MainOutMessage(sExceptionMsg5);
      end;
      try
        m_VisibleActors.Clear;
      except
        MainOutMessage(sExceptionMsg6);
      end;
      SendMsg(Self, RM_CLEAROBJECTS, 0, 0, 0, 0, '');
      m_PEnvir := Envir;
      m_sMapName := Envir.sMapName;
      m_nCurrX := nDMapX;
      m_nCurrY := nDMapY;
      SendMsg(Self, RM_CHANGEMAP, 0, 0, 0, 0, Envir.sMapFile);
      if AddToMap() then
      begin
        m_dwMapMoveTick := GetTickCount();
        m_bo316 := True;
        Result := True;
      end
      else
      begin
        m_PEnvir := OldEnvir;
        m_nCurrX := nOldX;
        m_nCurrY := nOldY;
        m_PEnvir.AddToMap(m_nCurrX, m_nCurrY, OS_MOVINGOBJECT, Self);
      end;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin //复位泡点，及金币，时间
        PlayObject := TPlayObject(Self);
        PlayObject.m_dwIncGamePointTick := GetTickCount();
        PlayObject.m_dwIncGameGoldTick := GetTickCount();
        PlayObject.m_dwAutoGetExpTick := GetTickCount();
        if PlayObject.m_nChangeMap2 < 100 then
          Inc(PlayObject.m_nChangeMap2);
        //Jason 1115增加任务怪物，在主人切换地图时也一起切换
        if Result then
        begin
          for i := 0 to m_SlaveList.Count - 1 do
          begin
            if TBaseObject(m_SlaveList.Items[I]).m_btRaceServer = RC_153 then
            begin
              TMissionMonUnit(m_SlaveList.Items[I]).MoveTo(OldEnvir, nOldX,
                nOldY);
            end;
          end;
        end;
      end;

      if m_PEnvir.Flag.boFight3Zone and (m_PEnvir.Flag.boFight3Zone <>
        OldEnvir.Flag.boFight3Zone) then
        RefShowName();
    except
      MainOutMessage(sExceptionMsg7);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.EnterAnotherMap');
  end;
end;

procedure TBaseObject.TurnTo(nDir: integer); //004BB048
begin
  try
    m_btDirection := nDir;
    SendRefMsg(RM_TURN, nDir, m_nCurrX, m_nCurrY, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.TurnTo');
  end;
end;

procedure TBaseObject.ProcessSayMsg(sMsg: string); //004BB084
var
  sCharName: string;
begin
  try
    if m_btRaceServer = RC_PLAYOBJECT then
      sCharName := m_sCharName
    else
      sCharName := FilterShowName(m_sCharName);
    SendRefMsg(RM_HEAR, 0, g_Config.btHearMsgFColor, g_Config.btHearMsgBColor,
      0, sCharName + ':' + sMsg);
  except
    MainOutMessage('[Exception] TBaseObject.ProcessSayMsg');
  end;
end;

procedure TBaseObject.SysColorMsg(sMsg: string; FColor, BColor: Byte);
begin
  try
    if m_boHero then
    begin
      try
        sMsg := '(英雄) ' + sMsg;
        if m_HeroHuman <> nil then
          m_HeroHuman.SysColorMsg(sMsg, FColor, BColor);
      except
        MainOutMessage('[Exception] SysColorMsg');
      end;
    end
    else
    begin
      SendMsg(Self, RM_CRY, 0, FColor, BColor, 0, sMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SysColorMsg');
  end;
end;

procedure TBaseObject.SysMsg(sMsg: string; MsgColor: TMsgColor; MsgType:
  TMsgType); //004BB124
//var
//  nPararm2,nPararm3:Integer;
begin
  try
    if m_boHero then
    begin
      sMsg := '(英雄) ' + sMsg;
      if m_HeroHuman <> nil then
        m_HeroHuman.SysMsg(sMsg, MsgColor, MsgType);
      exit;
    end;
    if g_Config.boShowPreFixMsg then
    begin
      case MsgType of
        t_Mon: sMsg := g_Config.sMonSayMsgpreFix + sMsg;
        t_Hint: sMsg := g_Config.sHintMsgPreFix + sMsg;
        t_GM: sMsg := g_Config.sGMRedMsgpreFix + sMsg;
        t_System: sMsg := g_Config.sSysMsgPreFix + sMsg;
        t_Notice: sMsg := g_Config.sLineNoticePreFix + sMsg;
        t_Cust: sMsg := g_Config.sCustMsgpreFix + sMsg;
        t_Castle: sMsg := g_Config.sCastleMsgpreFix + sMsg;
        t_Cudt: sMsg := g_Config.sClairaudientFix + sMsg;
      end;
    end;
    case MsgColor of
      c_Green: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btGreenMsgFColor,
          g_Config.btGreenMsgBColor, 0, sMsg);
      c_Blue: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btBlueMsgFColor,
          g_Config.btBlueMsgBColor, 0, sMsg);
    else
      begin
        case MsgType of
          t_Cust: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btCustMsgFColor,
              g_Config.btCustMsgBColor, 0, sMsg);
          t_Cudt: SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btCudtMsgFColor,
              g_Config.btCudtMsgBColor, 0, sMsg);
        else
          SendMsg(Self, RM_SYSMESSAGE, 0, g_Config.btRedMsgFColor,
            g_Config.btRedMsgBColor, 0, sMsg);
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SysMsg');
  end;
end;

procedure TBaseObject.MonsterSayMsg(AttackBaseObject: TBaseObject; MonStatus:
  TMonStatus);
var
  I: Integer;
  //  nMsgColor:Integer;
  sMsg: string;
  MonSayMsg: pTMonSayMsg;
  sAttackName: string;
begin
  try
    if m_SayMsgList = nil then
      exit;
    if (m_btRaceServer = RC_PLAYOBJECT) then
      exit;
    if (AttackBaseObject <> nil) then
    begin
      if (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT) and
        (AttackBaseObject.m_Master2 = nil) then
      begin
        exit;
      end;
      if (AttackBaseObject.m_AllMaster <> nil) and
        (AttackBaseObject.m_AllMaster.m_btRaceServer <> RC_PLAYOBJECT) then
      begin
        exit;
      end;
      if AttackBaseObject.m_Master2 <> nil then
        sAttackName := AttackBaseObject.m_Master2.m_sCharName
      else
        sAttackName := AttackBaseObject.m_sCharName;
    end;
    for I := 0 to m_SayMsgList.Count - 1 do
    begin
      MonSayMsg := m_SayMsgList.Items[I];
      sMsg := AnsiReplaceText(MonSayMsg.sSayMsg, '%s',
        FilterShowName(m_sCharName));
      sMsg := AnsiReplaceText(sMsg, '%d', sAttackName);
      if (MonSayMsg.State = MonStatus) and (Random(MonSayMsg.nRate) = 0) then
      begin
        if MonStatus = s_MonGen then
        begin
          UserEngine.SendBroadCastMsg(sMsg, t_Mon);
          break;
        end;
        if MonSayMsg.Color = c_White then
        begin
          ProcessSayMsg(sMsg);
        end
        else
        begin
          AttackBaseObject.SysMsg(sMsg, MonSayMsg.Color, t_Mon);
        end;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.MonsterSayMsg');
  end;
end;

procedure TBaseObject.SendGroupText(sMsg: string); //004BB1CC
var
  I: Integer;
  PlayObject: TPlayObject;
begin
  try
    sMsg := g_Config.sGroupMsgPreFix + sMsg;
    if m_GroupOwner <> nil then
    begin
      for I := 0 to m_GroupOwner.m_GroupMembers.Count - 1 do
      begin
        PlayObject := TPlayObject(m_GroupOwner.m_GroupMembers.Objects[i]);
        PlayObject.SendMsg(Self, RM_GROUPMESSAGE, 0, g_Config.btGroupMsgFColor,
          g_Config.btGroupMsgBColor, 0, sMsg);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SendGroupText');
  end;
end;

procedure TBaseObject.MakeGhost(); //004BB300
begin
  try
    m_boGhost := True;
    m_dwGhostTick := GetTickCount();
    //  m_PEnvir.DelObjectCount2(Self);  //减少地图计数
    DisappearA();
  except
    MainOutMessage('[Exception] TBaseObject.MakeGhost');
  end;
end;

procedure TBaseObject.ApplyMeatQuality; //004BB32C
var
  I: Integer;
  StdItem: TItem;
  UserItem: pTUseritem;
begin
  try
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      StdItem := UserEngine.GetStdItem(UserItem.wIndex);
      if StdItem <> nil then
      begin
        if StdItem.StdMode = 40 then
        begin
          UserItem.Dura := m_nMeatQuality;
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.ApplyMeatQuality');
  end;
end;

function TBaseObject.TakeBagItems(BaseObject: TBaseObject): Boolean; //004BB3B0
var
  UserItem: pTUseritem;
  PlayObject: TPlayObject;
  StdItem: TItem;
  sMyInfo: string;
begin
  try
    Result := False;
    while (True) do
    begin
      if BaseObject.m_ItemList.Count <= 0 then
        break;
      UserItem := BaseObject.m_ItemList.Items[0];
      if not AddItemToBag(UserItem) then
        break;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        PlayObject := TPlayObject(Self);
        PlayObject.SendAddItem(UserItem);
        Result := True;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog(IntToStr(LOG_BUTCHITEM) + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '0' + #9 +
              BaseObject.m_sCharName);
          if StdItem.nRule[RULE_BUTCHITEM] then
          begin
            sMyInfo := sButchItemHintMsg;
            sMyInfo := AnsiReplaceText(sMyInfo, '%s', m_sCharName);
            sMyInfo := AnsiReplaceText(sMyInfo, '%item', Stditem.Name);
            sMyInfo := AnsiReplaceText(sMyInfo, '%name',
              FilterShowName(BaseObject.m_sCharName));
            sMyInfo := AnsiReplaceText(sMyInfo, '%m', m_PEnvir.sMapDesc);
            sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
            sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
            UserEngine.SendBroadCastMsgExt(sMyInfo, t_System);
          end;
        end;
      end;
      BaseObject.m_ItemList.Delete(0);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.TakeBagItems');
  end;
end;

function TBaseObject.TakeCloneBagItems(BaseObject: TBaseObject): Boolean;
var
  UserItem: pTUseritem;
  StdItem: TItem;
  sMyInfo: string;
  PlayObject: TPlayObject;
  CloneObject: TPlayCloneObject;
begin
  try
    Result := False;
    if (BaseObject.m_btRaceServer = RC_PLAYCLONE) and (m_btRaceServer =
      RC_PLAYOBJECT) then
    begin
      PlayObject := TPlayObject(Self);
      CloneObject := TPlayCloneObject(BaseObject);
      while (True) do
      begin
        if CloneObject.m_ButchItemList.Count <= 0 then
          break;
        UserItem := CloneObject.m_ButchItemList.Items[0];
        if not AddItemToBag(UserItem) then
          break;
        PlayObject.SendAddItem(UserItem);
        Result := True;
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem <> nil then
        begin
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog(IntToStr(LOG_BUTCHITEM) + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              StdItem.Name + #9 +
              IntToStr(UserItem.MakeIndex) + #9 +
              '0' + #9 +
              BaseObject.m_sCharName);
          if StdItem.nRule[RULE_BUTCHITEM] then
          begin
            sMyInfo := sButchItemHintMsg;
            sMyInfo := AnsiReplaceText(sMyInfo, '%s', m_sCharName);
            sMyInfo := AnsiReplaceText(sMyInfo, '%item', Stditem.Name);
            sMyInfo := AnsiReplaceText(sMyInfo, '%name',
              FilterShowName(BaseObject.m_sCharName));
            sMyInfo := AnsiReplaceText(sMyInfo, '%m', m_PEnvir.sMapDesc);
            sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
            sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
            UserEngine.SendBroadCastMsgExt(sMyInfo, t_System);
          end;
        end;
        CloneObject.m_ButchItemList.Delete(0);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.TakeCloneBagItems');
  end;
end;

function TBaseObject.TakeUserItems(BaseObject: TBaseObject): Boolean;
var
  UserItem: TUserItem;
  UserItem32: pTUserItem;
  Idx: Byte;
  Count: pInteger;
  I: Integer;
  PlayObject: TPlayObject;
  CloneObject: TPlayCloneObject;
  StdItem: TItem;
  sMyInfo: string;
begin
  try
    //NpcGotoLable(g_FunctionNPC,'@PlayReconnection',False);
    Result := False;
    if (BaseObject.m_btRaceServer = RC_PLAYCLONE) and (m_btRaceServer =
      RC_PLAYOBJECT) then
    begin
      PlayObject := TPlayObject(Self);
      CloneObject := TPlayCloneObject(BaseObject);
      case CloneObject.m_nCloneButchCls of
        0: Count := @PlayObject.m_nGold;
        1: Count := @PlayObject.m_nGameGold;
        2: Count := @PlayObject.m_nGameDiamond;
        3: Count := @PlayObject.m_nGameGird;
      else
        Count := @PlayObject.m_nGold;
      end;
      if Count^ >= CloneObject.m_nCloneButchCount then
      begin
        if CloneObject.m_ButchNotItemDelGold then
        begin
          Dec(Count^, CloneObject.m_nCloneButchCount);
          PlayObject.GoldChanged;
          PlayObject.RefDiamondGird;
          SendRefMsg(RM_SHOWEFFECT, Effect_86, Integer(Self), m_nCurrX,
            m_nCurrY,
            '');
        end;
        StdItem := nil;
        UserItem32 := nil;
        if not CloneObject.m_ButchAllItems then
        begin
          if CloneObject.m_boCloneButchItem and
            (Random(CloneObject.m_nCloneButchUserItemRate) <= 0) then
          begin
            Idx := Random(MAXUSEITEMS + 1);
            if Idx in [0..MAXUSEITEMS] then
            begin
              UserItem := CloneObject.m_UseItems[Idx];
              if (UserItem.wIndex > 0) and (Random(CloneObject.m_nCloneButchRate)
                = 0) then
              begin
                StdItem := UserEngine.GetStdItem(UserItem.wIndex);
                if StdItem <> nil then
                begin
                  CloneObject.m_UseItems[Idx].wIndex := 0;
                  New(UserItem32);
                  UserItem32^ := UserItem;
                end;
              end;
            end;
          end;
          //end else begin
          if (UserItem32 = nil) and (CloneObject.m_ButchItemList <> nil) and
            (CloneObject.m_ButchItemList.Count > 0) then
          begin
            I := Random(CloneObject.m_ButchItemList.Count);
            if (I >= 0) and (I < CloneObject.m_ButchItemList.Count) then
            begin
              UserItem32 := CloneObject.m_ButchItemList.Items[I];
              CloneObject.m_ButchItemList.Delete(I);
              if CloneObject.m_ButchItemList.Count <= 0 then
              begin
                CloneObject.m_ButchItemList.Free;
                CloneObject.m_ButchItemList := nil;
              end;

              StdItem := UserEngine.GetStdItem(UserItem32.wIndex);
              if (UserItem32 <> nil) and (StdItem = nil) then
              begin
                Dispose(UserItem32);
                UserItem32 := nil;
              end;
            end;
          end;
          //end;
          if (StdItem <> nil) and (UserItem32 <> nil) then
          begin
            if AddItemToBag(UserItem32) then
            begin
              if not CloneObject.m_ButchNotItemDelGold then
              begin
                Dec(Count^, CloneObject.m_nCloneButchCount);
                PlayObject.GoldChanged;
                PlayObject.RefDiamondGird;
                SendRefMsg(RM_SHOWEFFECT, Effect_86, Integer(Self), m_nCurrX,
                  m_nCurrY, '');
              end;
              PlayObject.SendAddItem(UserItem32);
              Result := True;
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog(IntToStr(LOG_BUTCHITEM) + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '0' + #9 +
                  BaseObject.m_sCharName);
              if StdItem.nRule[RULE_BUTCHITEM] then
              begin
                sMyInfo := sButchItemHintMsg;
                sMyInfo := AnsiReplaceText(sMyInfo, '%s', m_sCharName);
                sMyInfo := AnsiReplaceText(sMyInfo, '%item', Stditem.Name);
                sMyInfo := AnsiReplaceText(sMyInfo, '%name',
                  FilterShowName(BaseObject.m_sCharName));
                sMyInfo := AnsiReplaceText(sMyInfo, '%m', m_PEnvir.sMapDesc);
                sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
                sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
                UserEngine.SendBroadCastMsgExt(sMyInfo, t_System);
              end;
            end
            else
              Dispose(UserItem32);
          end
          else
            NpcGotoLable(g_FunctionNPC, '@ButchCloneItem', False);
        end
        else
        begin
          if CloneObject.m_ButchItemList = nil then
          begin
            Result := False;
            CloneObject.MakeGhost;
            exit;
          end;
          Result := TakeCloneBagItems(CloneObject);
          if Result and (not CloneObject.m_ButchNotItemDelGold) then
          begin
            Dec(Count^, CloneObject.m_nCloneButchCount);
            PlayObject.GoldChanged;
            PlayObject.RefDiamondGird;
            SendRefMsg(RM_SHOWEFFECT, Effect_86, Integer(Self), m_nCurrX,
              m_nCurrY, '');
          end;
          if (CloneObject.m_ButchItemList.Count <= 0) then
            CloneObject.MakeGhost;
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.TakeBagItems2');
  end;
end;

procedure TBaseObject.ScatterBagItems(ItemOfCreat: TBaseObject); //004BB44C
const
  DropWide: Integer = 3;
var
  I, II: Integer;
  UserItem: pTUserItem;
  StdItem: TItem;
  boCanNotDrop: Boolean;
  MonDrop: pTMonDrop;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject::ScatterBagItems';
begin
  try
    try
      g_MonDropLimitLIst.Lock;
      try
        for I := m_ItemList.Count - 1 downto 0 do
        begin
          UserItem := m_ItemList.Items[I];
          StdItem := UserEngine.GetStdItem(UserItem.wIndex);
          {if (m_btRaceServer=RC_PLAYOBJECT) and (StdItem<>Nil) then begin
            if (StdItem.nRule[RULE_NODROP]) then Continue;
            if TPlayObject(Self).CheckItemState(UserItem,ITEMSTATE_SCATTER,False) then Continue; //检查是否禁止爆出
          end;  }

          boCanNotDrop := False;
          if StdItem <> nil then
          begin
            for II := 0 to g_MonDropLimitLIst.Count - 1 do
            begin
              if CompareText(StdItem.Name, g_MonDropLimitLIst.Strings[II]) = 0
                then
              begin
                MonDrop := pTMonDrop(g_MonDropLimitLIst.Objects[II]);
                if MonDrop.nDropCount < MonDrop.nCountLimit then
                begin
                  Inc(MonDrop.nDropCount);
                  g_MonDropLimitLIst.Objects[II] := TObject(MonDrop);
                end
                else
                begin
                  Inc(MonDrop.nNoDropCount);
                  boCanNotDrop := True;
                end;
                break;
              end;
            end;
          end;
          if boCanNotDrop then
            Continue;

          if DropItemDown(UserItem, DropWide, True, ItemOfCreat, Self) then
          begin
            Dispose(UserItem);
            m_ItemList.Delete(I);
          end;
        end;
      finally
        g_MonDropLimitLIst.UnLock;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.ScatterBagItems');
  end;
end;

procedure TBaseObject.ScatterGolds(GoldOfCreat: TBaseObject); //004BB63C
var
  I, nGold: integer;
  boSendMsg: Boolean;
  BaseObject: TBaseObject;
begin
  try
    if (m_nGold > 0) and (GoldOfCreat <> nil) then
    begin
      I := 0;
      boSendMsg := False;
      if GoldOfCreat.m_AllMaster <> nil then
      begin
        //if GoldOfCreat.m_HeroHuman<>nil then
        BaseObject := GoldOfCreat.m_AllMaster;
        //else exit;
      end
      else
        BaseObject := GoldOfCreat;
      while (True) do
      begin
        //      for i:=0 to 18 do begin
        if m_nGold > g_Config.nMonOneDropGoldCount then
        begin
          nGold := g_Config.nMonOneDropGoldCount;
          m_nGold := m_nGold - g_Config.nMonOneDropGoldCount;
        end
        else
        begin
          nGold := m_nGold;
          m_nGold := 0;
        end;
        if nGold > 0 then
        begin
          //070609增加金币直接入背包
          if (g_Config.boDropGoldToPlayBag) and ((BaseObject.m_nGold + nGold) <
            g_Config.nHumanMaxGold) then
          begin
            Inc(BaseObject.m_nGold, nGold);
            boSendMsg := True;
          end
          else
          begin
            if not DropGoldDown(nGold, TRUE, BaseObject, Self) then
            begin
              m_nGold := m_nGold + nGold;
              break;
            end;
          end;
        end
        else
          break;
        Inc(I);
        if I >= 17 then
          break;
      end;
      GoldChanged;
      if boSendMsg then
        BaseObject.GoldChanged;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.ScatterGolds');
  end;
end;

procedure TBaseObject.DropUseItems(BaseObject: TBaseObject; AttactObject:
  TBaseObject = nil); //004BB6C8
var
  I: Integer;
  nRate: Integer;
  StdItem: TItem;
  DelList: TStringList;
resourcestring
  sExceptionMsg = '[Exception] TBaseObject.DropUseItems';
begin
  try
    DelList := nil;
    try
      if m_boAngryRing or m_boNoDropUseItem or m_boCloneNoDropItem or (not
        (m_btRaceServer in [RC_PLAYOBJECT, RC_PLAYCLONE])) then
        exit;

      if (AttactObject = nil) or
        ((AttactObject.m_btRaceServer <> RC_PLAYOBJECT) and
        (AttactObject.m_AllMaster = nil)) or
        ((AttactObject.m_AllMaster <> nil) and
        (AttactObject.m_AllMaster.m_btRaceServer <> RC_PLAYOBJECT)) then
      begin
        for I := Low(THumanUseItems) to High(THumanUseItems) do
        begin
          StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
          if StdItem <> nil then
          begin
            if StdItem.Reserved and 8 <> 0 then
            begin
              if DelList = nil then
                DelList := TStringList.Create;
              DelList.AddObject('', TObject(m_UseItems[I].MakeIndex));
              //004BB885
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('16' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  //UserEngine.GetStdItemName(m_UseItems[I].wIndex) + #9 +
                  StdItem.Name + #9 +
                  IntToStr(m_UseItems[I].MakeIndex) + #9 +
                  BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                  '0');
              m_UseItems[I].wIndex := 0;
            end;
          end;
        end;
      end;

      if m_btRaceServer = RC_PLAYCLONE then
      begin
        nRate := TPlayCloneObject(Self).m_nDropUseItemRate;
      end
      else
      begin
        if PKLevel > 2 then
          nRate := g_Config.nDieRedDropUseItemRate {15}
        else
          nRate := g_Config.nDieDropUseItemRate {30};
      end;

      for I := Low(THumanUseItems) to High(THumanUseItems) do
      begin
        if Random(nRate) <> 0 then
          Continue;
        if InDisableTakeOffList(m_UseItems[I].wIndex) then
          Continue; //检查是否在禁止取下列表,如果在列表中则不掉此物品
        StdItem := UserEngine.GetStdItem(m_UseItems[I].wIndex);
        if (StdItem <> nil) then
        begin
          if (StdItem.nRule[RULE_NODROP]) then
            Continue;
          if (m_btRaceServer = RC_PLAYOBJECT) then
            if TPlayObject(Self).CheckItemState(@m_UseItems[I],
              ITEMSTATE_SCATTER, False) then
              Continue; //检查是否禁止爆出

          if DropItemDown(@m_UseItems[I], 2, True, BaseObject, Self) then
          begin

            if StdItem <> nil then
            begin
              if StdItem.Reserved and 10 = 0 then
              begin
                if m_btRaceServer = RC_PLAYOBJECT then
                begin
                  if DelList = nil then
                    DelList := TStringList.Create;
                  DelList.AddObject(UserEngine.GetStdItemName(m_UseItems[I].wIndex), TObject(m_UseItems[I].MakeIndex));
                end;
                m_UseItems[I].wIndex := 0;
              end;
            end;
          end;
        end;
      end;
      if (DelList <> nil) then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
          SendMsg(Self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '')
        else
          DelList.Free;
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DropUseItems');
  end;
  {var
    nC,nRate:Integer;
    StdItem:TItem;
    DropItemList:TStringList;
  ResourceString
    sExceptionMsg = '[Exception] TBaseObject::DropUseItems';
  begin
  Try
    DropItemList:=nil;
    try
      if m_boNoDropUseItem then exit;
      if m_btRaceServer = RC_PLAYOBJECT then begin
        nC:=0;
        while (True) do begin
          StdItem:=UserEngine.GetStdItem(m_UseItems[nC].wIndex);
          if StdItem <> nil then begin
            if StdItem.Reserved and 8 <> 0 then begin
              if DropItemList = nil then DropItemList:=TStringList.Create;
              DropItemList.AddObject('',TObject(m_UseItems[nC].MakeIndex));
              //004BB885
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('16' +  #9 +
                       m_sMapName + #9 +
                       IntToStr(m_nCurrX) + #9 +
                       IntToStr(m_nCurrY) + #9 +
                       m_sCharName + #9 +
                       //UserEngine.GetStdItemName(m_UseItems[nC].wIndex) + #9 +
                       StdItem.Name + #9 +
                       IntToStr(m_UseItems[nC].MakeIndex) + #9 +
                       BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                       '0');
              m_UseItems[nC].wIndex:=0;
            end;
          end;
          Inc(nC);
          if nC >= 9 then break;
        end;
      end;
      if PKLevel > 2 then nRate:=15
      else nRate:=30;
      nC:=0;
      While (True) do begin
        if Random(nRate) = 0 then begin
          if DropItemDown(@m_UseItems[nC],2,True,BaseObject,Self) then begin
            StdItem:=UserEngine.GetStdItem(m_UseItems[nC].wIndex);
            if StdItem <> nil then begin
              if StdItem.Reserved and 10 = 0 then begin
                if m_btRaceServer = RC_PLAYOBJECT then begin
                  if DropItemList = nil then DropItemList:=TStringList.Create;
                  DropItemList.AddObject(UserEngine.GetStdItemName(m_UseItems[nC].wIndex),TObject(m_UseItems[nC].MakeIndex));
                end;
                m_UseItems[nC].wIndex:=0;
              end; //004BB9A9
            end;
          end; //004BB9A9
        end;
        Inc(nC);
        if nC >= 9 then break;
      end;
      if DropItemList <> nil then
        SendMsg(Self,RM_SENDDELITEMLIST,0,Integer(DropItemList),0,0,'');
    except
      MainOutMessage(sExceptionMsg);
    end;
  Except
    MainOutMessage('[Exception] TBaseObject.DropUseItems');
  End;  }
end;

procedure TBaseObject.Die; //004BBA98
var
  boPK, guildwarkill: Boolean;
  tStr: string;
  tExp: LongWord;
  i: Integer;
  GroupHuman: TPlayObject;
  QuestNPC: TMerchant;
  tCheck: Boolean;
  AttackBaseObject: TBaseObject;
  Castle: TUserCastle;
  nCheckCode: integer;
  UserItem: pTUserItem;
  Item: TItem;
resourcestring
  sExceptionMsg1 = '[Exception] TBaseObject::Die 1 nCode=%d';
  sExceptionMsg2 = '[Exception] TBaseObject::Die 2';
  sExceptionMsg3 = '[Exception] TBaseObject::Die 3';
begin
  try
    nCheckCode := 0;
    //004BBABB
  //  AttackBaseObject:=Nil;
    if m_boSuperMan then
      exit;
    if m_boSupermanItem then
      exit;

    try
      if (m_btRaceServer = RC_PLAYOBJECT) and
        (Assigned(m_HookObjectDie)) and
        (not m_HookObjectDie(Self)) then
        exit;
    except
      MainOutMessage('[Exception] TBaseObject::Die->ApiHook');
    end;
    m_boDeath := True;
    m_dwDeathTick := GetTickCount();
    m_dwDeathTickEx := g_Config.nMonButchMaxTime;
    sub_4BC87C();
    if m_Master2 <> nil then
    begin
      m_ExpHitter := nil;
      m_LastHiter := nil;
    end;
    m_nIncSpell := 0;
    m_nIncHealth := 0;
    m_nIncHealing := 0;
    m_WAbil.HP := 0;
    //004BBB30
  //  m_PEnvir.DelObjectCount2(Self);     //减少记数
    if m_btRaceServer = RC_PLAYOBJECT then
    begin
      m_sDieMap := m_sMapName;
      m_nDieX := m_nCurrX;
      m_nDieY := m_nCurrY;
      for I := Low(m_UseItems) to High(m_UseItems) do
      begin
        UserItem := @m_UseItems[I];
        if UserItem.wIndex > 0 then
        begin
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          if Item.DieDisap = 1 then
          begin
            UserItem.wIndex := 0;
          end
          else if Item.nRule[RULE_DEATH] then
          begin
            DropItemDown(UserItem, 1, True, nil, Self);
            UserItem.wIndex := 0;
          end;
        end;
      end;
      for I := m_ItemList.Count - 1 downto 0 do
      begin
        UserItem := m_ItemList.Items[I];
        if UserItem <> nil then
        begin
          if UserItem.wIndex > 0 then
          begin
            Item := UserEngine.GetStdItem(UserItem.wIndex);
            if Item.DieDisap = 1 then
            begin
              m_ItemList.Delete(I);
              Dispose(UserItem);
            end
            else if Item.nRule[RULE_DEATH] then
            begin
              DropItemDown(UserItem, 1, True, nil, Self);
              m_ItemList.Delete(I);
              Dispose(UserItem);
            end;
          end;
        end;
      end;
     try //判断人物是被怪物杀死还是人物杀死
        if (m_btRaceServer= RC_PLAYOBJECT) and (m_LastHiter <> nil) then
         begin
           if m_ExpHitter <> nil then
              AttackBaseObject := m_ExpHitter
            else
              AttackBaseObject := m_LastHiter;
            if AttackBaseObject <> nil then
              if AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT then
                TPlayObject(Self).m_boKILLBYHUM:=True
               else
                 TPlayObject(Self).m_boKILLBYHUM:=False;
         end;
     except

     end;
      NpcGotoLable(g_FunctionNPC, '@PlayDie', False);
      GroupHuman := TPlayObject(Self);
      if (g_Config.nHeroFealtyDeathDel > 0) and (GroupHuman.m_nGloryPoint > 0)
        then
      begin
        GroupHuman.HeroChangeGlory(g_Config.nHeroFealtyDeathDel, 1);
      end;
      //GroupHuman:=Nil;
      {if (g_FunctionNPC <> nil) and (not m_boHero) then
        g_FunctionNPC.GotoLable(TPlayObject(Self),'@PlayDie',False); }
    end;
    try
      nCheckCode := 0;
      if (m_btRaceServer <> RC_PLAYOBJECT) and (m_LastHiter <> nil) then
      begin
        if g_Config.boMonSayMsg then
          MonsterSayMsg(m_LastHiter, s_Die);
        if m_ExpHitter <> nil then
          AttackBaseObject := m_ExpHitter
        else
          AttackBaseObject := m_LastHiter;
        if AttackBaseObject <> nil then
        begin
          AttackBaseObject.NpcGotoLable(g_FunctionNPC, '@KillMob', True);
          if AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT then
          begin
            tExp := AttackBaseObject.CalcGetExp(m_Abil.Level, m_dwFightExp);
            if not g_Config.boVentureServer then
            begin
              nCheckCode := 7;
              TPlayObject(AttackBaseObject).GainExp(tExp);
              nCheckCode := 8;
            end;
          end
          else
          begin //m_btRaceServer = RC_PLAYOBJECT
            if AttackBaseObject.m_Master2 <> nil then
            begin
              nCheckCode := 23;
              AttackBaseObject.GainSlaveExp(m_Abil.Level);
              nCheckCode := 24;
              tExp := AttackBaseObject.m_Master2.CalcGetExp(m_Abil.Level,
                m_dwFightExp);
              nCheckCode := 25;
              if (not g_Config.boVentureServer) and
                (AttackBaseObject.m_Master2.m_btRaceServer = RC_PLAYOBJECT) then
              begin
                nCheckCode := 26;
                TPlayObject(AttackBaseObject.m_Master2).GainExp(tExp);
              end;
            end;
          end; //m_btRaceServer = RC_PLAYOBJECT
          if AttackBaseObject.m_AllMaster <> nil then
            AttackBaseObject := AttackBaseObject.m_AllMaster;
          if (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not
            AttackBaseObject.m_boHero) then
          begin
            if m_PEnvir.IsCheapStuff then
            begin
              if AttackBaseObject.m_GroupOwner <> nil then
              begin
                for i := 0 to AttackBaseObject.m_GroupOwner.m_GroupMembers.Count
                  - 1 do
                begin
                  GroupHuman :=
                    TPlayObject(AttackBaseObject.m_GroupOwner.m_GroupMembers.Objects[i]);
                  if (not GroupHuman.m_boDeath) and
                    (AttackBaseObject.m_PEnvir = GroupHuman.m_PEnvir) and
                    (abs(AttackBaseObject.m_nCurrX - GroupHuman.m_nCurrX) <= 12)
                    and
                    (abs(AttackBaseObject.m_nCurrX - GroupHuman.m_nCurrX) <= 12)
                      then
                  begin
                    if AttackBaseObject = GroupHuman then
                      tCheck := False
                    else
                      tCheck := True;
                    QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(GroupHuman,
                      m_sCharName, '', tCheck));
                    if QuestNPC <> nil then
                      QuestNPC.Click(GroupHuman);
                  end;
                end;
              end
              else
              begin //AttackBaseObject.m_GroupOwner <> nil
                QuestNPC := TMerchant(m_PEnvir.GetQuestNPC(AttackBaseObject,
                  m_sCharName, '', False));
                if QuestNPC <> nil then
                  QuestNPC.Click(TPlayObject(AttackBaseObject));
              end;
            end;
          end;
        end; //AttackBaseObject<>Nil
        //地图触发
        if m_PEnvir.Flag.sKillMon<>'' then
          AttackBaseObject.NpcGotoLable(g_QMapEnent,'@KillPlayMon'+m_PEnvir.Flag.sKillMon,True);
      end; //004BBE21
      nCheckCode := 35;
      if (g_Config.boMonSayMsg) and (m_btRaceServer = RC_PLAYOBJECT) and
        (m_LastHiter <> nil) then
      begin
        m_LastHiter.MonsterSayMsg(Self, s_KillHuman);
      end;

      
      nCheckCode := 36;
      m_Master2 := nil;
      m_AllMaster := nil;
    except
      on e: Exception do
      begin
        MainOutMessage(Format(sExceptionMsg1, [nCheckCode]));
        MainOutMessage(E.Message);
      end;
    end;
    try
      boPK := False;
      if (not g_Config.boVentureServer) and (not m_PEnvir.Flag.boFightZone) and
        (not m_PEnvir.Flag.boFight2Zone) and (not m_PEnvir.Flag.boFight3Zone) and
        (not m_PEnvir.Flag.boFIGHT4) then
      begin
        if (m_btRaceServer = RC_PLAYOBJECT) and (m_LastHiter <> nil) and (PKLevel
          < 2) then
        begin
          //            if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) then
          if (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) or
            (m_LastHiter.m_btRaceServer = RC_NPC) then
            {修改日期2004/07/21，允许NPC杀死人物}

            boPK := True;
          if m_LastHiter.m_Master2 <> nil then
            if m_LastHiter.m_Master2.m_btRaceServer = RC_PLAYOBJECT then
            begin
              m_LastHiter := m_LastHiter.m_Master2;
              boPK := True;
            end;
        end;
      end;

      if boPK and (m_LastHiter <> nil) then
      begin
        guildwarkill := FALSE;
        if (m_MyGuild <> nil) and (m_LastHiter.m_MyGuild <> nil) then
        begin
          if GetGuildRelation(self, m_LastHiter) = 2 then
            guildwarkill := TRUE;
        end;
        Castle := g_CastleManager.InCastleWarArea(Self);
        if ((Castle <> nil) and Castle.m_boUnderWar) or (m_boInFreePKArea) then
          guildwarkill := TRUE;
        if not guildwarkill then
        begin
          if Self <> m_LastHiter.m_Hero then
          begin //070529增加，英雄被主人杀死不处理
            m_LastHiter.NpcGotoLable(g_FunctionNPC, '@KillPlay', False);
            if (g_Config.boKillHumanWinLevel or g_Config.boKillHumanWinExp or
              m_PEnvir.Flag.boPKWINLEVEL or m_PEnvir.Flag.boPKWINEXP) and
              (m_LastHiter.m_btRaceServer = RC_PLAYOBJECT) and (m_btRaceServer =
              RC_PLAYOBJECT) then
            begin
              TPlayObject(Self).PKDie(TPlayObject(m_LastHiter));
            end
            else
            begin
              if not m_LastHiter.IsGoodKilling(self) then
              begin
                //if (not m_LastHiter.m_boHero) then begin
                if m_LastHiter.m_boHero and (not g_Config.bHeroKillManAddPK)
                  then
                begin
                  //if g_Config.bHeroKillManAddPK then begin
                  m_LastHiter.m_HeroHuman.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
                  m_LastHiter.m_HeroHuman.SysMsg(g_sYouMurderedMsg
                    {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
                  //end;
                end
                else
                begin
                  m_LastHiter.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
                  m_LastHiter.SysMsg(g_sYouMurderedMsg
                    {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
                end;

                SysMsg(format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]),
                  c_Red, t_Hint);

                m_LastHiter.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
                if (PkLevel < 1) and (Random(5) = 0) then
                begin
                  if m_LastHiter.m_boHero and (not g_Config.bHeroKillManAddPK)
                    then
                    m_LastHiter.m_HeroHuman.MakeWeaponUnlock
                  else
                    m_LastHiter.MakeWeaponUnlock;
                  //if (Random(5) = 0) and ((not m_LastHiter.m_boHero) or g_Config.bHeroKillManAddPK) then m_LastHiter.MakeWeaponUnlock;
                end;
              end
              else
                m_LastHiter.SysMsg(g_sYouProtectedByLawOfDefense
                  {'[你受到正当规则保护。]'}, c_Green, t_Hint);
            end;
            //检查攻击人是否用了着经验或等级装备
            if not (Self = m_LastHiter.m_Hero) then
            begin //070529增加，英雄被主人杀死不犯罪
              if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
              begin
                if m_LastHiter.m_dwPKDieLostExp > 0 then
                begin
                  if m_Abil.Exp >= m_LastHiter.m_dwPKDieLostExp then
                  begin
                    Dec(m_Abil.Exp, m_LastHiter.m_dwPKDieLostExp);
                  end
                  else
                    m_Abil.Exp := 0;
                end;
                if m_LastHiter.m_nPKDieLostLevel > 0 then
                begin
                  if m_Abil.Level >= m_LastHiter.m_nPKDieLostLevel then
                  begin
                    Dec(m_Abil.Level, m_LastHiter.m_nPKDieLostLevel);
                  end
                  else
                    m_Abil.Level := 0;
                end;
              end;
            end;
          end;
        end;

        //=================================================================
      end;
    except
      MainOutMessage(sExceptionMsg2);
    end;

    try
      if (not m_PEnvir.Flag.boFightZone) and //004BC0C1
      (not m_PEnvir.Flag.boFight3Zone) and (not m_PEnvir.Flag.boFIGHT4) and
        (not m_boAnimal) then
      begin
        AttackBaseObject := m_ExpHitter;
        if (m_ExpHitter <> nil) and (m_ExpHitter.m_AllMaster <> nil) then
        begin
          AttackBaseObject := m_ExpHitter.m_AllMaster;
        end;
        if m_btRaceServer <> RC_PLAYOBJECT then
        begin
          DropUseItems(AttackBaseObject);
          if (m_Master2 = nil) and (not m_boNoItem) and (not
            m_PEnvir.Flag.boNODROPITEM) then
            ScatterBagItems(AttackBaseObject);
          if (m_btRaceServer >= RC_ANIMAL) and (m_Master2 = nil) and (not
            m_boNoItem) and (not m_PEnvir.Flag.boNODROPITEM) then
            ScatterGolds(AttackBaseObject);
        end
        else
        begin //004BC1B0
          if (not m_boNoItem) and (not m_PEnvir.Flag.boNODROPITEM) then
          begin {修改日期2004/07/21，增加此行，允许设置 m_boNoItem 后人物死亡不掉物品}
            //             MainOutMessage(BoolToStr(m_boNoItem));
            if AttackBaseObject <> nil then
            begin
              if (g_Config.boKillByHumanDropUseItem and
                (AttackBaseObject.m_btRaceServer = RC_PLAYOBJECT)) or
                (g_Config.boKillByMonstDropUseItem and
                (AttackBaseObject.m_btRaceServer <> RC_PLAYOBJECT)) then
                DropUseItems(nil, AttackBaseObject);
            end
            else
            begin
              DropUseItems(nil);
            end;
            if g_Config.boDieScatterBag then
              ScatterBagItems(nil);
            if g_Config.boDieDropGold then
              ScatterGolds(nil);
          end;
          AddBodyLuck(-(50 - (50 - m_Abil.Level * 5)));
        end; //004BC211
      end;

      if m_PEnvir.Flag.boFight3Zone then
      begin
        Inc(m_nFightZoneDieCount);
        if m_MyGuild <> nil then
        begin
          TGuild(m_MyGuild).TeamFightWhoDead(m_sCharName);
        end;

        if (m_LastHiter <> nil) then
        begin
          if (m_LastHiter.m_MyGuild <> nil) and (m_MyGuild <> nil) then
          begin
            TGuild(m_LastHiter.m_MyGuild).TeamFightWhoWinPoint(m_LastHiter.m_sCharName, 100); //matchpoint 刘啊, 俺牢己利 扁废
            tStr := TGuild(m_LastHiter.m_MyGuild).sGuildName + ':' +
              IntToStr(TGuild(m_LastHiter.m_MyGuild).nContestPoint) + '  ' +
              TGuild(m_MyGuild).sGuildName + ':' +
              IntToStr(TGuild(m_MyGuild).nContestPoint);
            UserEngine.CryCry(RM_CRY, m_PEnvir, m_nCurrX, m_nCurrY, 1000,
              g_Config.btCryMsgFColor, g_Config.btCryMsgBColor, '- ' + tStr);
          end;
        end;
      end;

      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        //Jacky 2004/09/05
        //人物死亡立即退组，以防止组队刷经验
        if m_GroupOwner <> nil then
          m_GroupOwner.DelMember(Self);

        if m_LastHiter <> nil then
        begin
          if m_LastHiter.m_btRaceServer = RC_PLAYOBJECT then
            tStr := m_LastHiter.m_sCharName
          else
            tStr := '#' + m_LastHiter.m_sCharName;
        end
        else
          tStr := '####';
        //004BC523
        if g_boGameLogHumanDie then
          AddGameDataLog('19' + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            'FZ-' + BoolToIntStr(m_PEnvir.Flag.boFightZone) +
            '_F3-' + BoolToIntStr(m_PEnvir.Flag.boFight3Zone) + #9 +
            '0' + #9 +
            '1' + #9 +
            tStr);
      end;
      //减少地图上怪物计数
      //if ((m_Master2 = nil) and (not m_boHero)) and (not m_boDelFormMaped) then begin

       // m_boDelFormMaped:=True;
      //end;
     // if not m_boDelFormMaped2 then begin
      //MainOutMessage('到');
    //    m_boDelFormMaped:=True;
    //  end;

      SendRefMsg(RM_DEATH, m_btDirection, m_nCurrX, m_nCurrY, 1, '');
    except
      MainOutMessage(sExceptionMsg3);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.Die');
  end;
end;

procedure TPlayObject.PKDie(PlayObject: TPlayObject);
var
  nWinLevel, nLostLevel, nWinExp, nLostExp: Integer;
  boWinLEvel, boLostLevel, boWinExp, boLostExp: Boolean;
begin
  try
    nWinLevel := g_Config.nKillHumanWinLevel;
    nLostLevel := g_Config.nKilledLostLevel;
    nWinExp := g_Config.nKillHumanWinExp;
    nLostExp := g_Config.nKillHumanLostExp;

    boWinLEvel := g_Config.boKillHumanWinLevel;
    boLostLevel := g_Config.boKilledLostLevel;
    boWinExp := g_Config.boKillHumanWinExp;
    boLostExp := g_Config.boKilledLostExp;

    if m_PEnvir.Flag.boPKWINLEVEL then
    begin
      boWinLEvel := True;
      nWinLevel := m_PEnvir.Flag.nPKWINLEVEL;
    end;
    if m_PEnvir.Flag.boPKLOSTLEVEL then
    begin
      boLostLevel := True;
      nLostLevel := m_PEnvir.Flag.nPKLOSTLEVEL;
    end;
    if m_PEnvir.Flag.boPKWINEXP then
    begin
      boWinExp := True;
      nWinExp := m_PEnvir.Flag.nPKWINEXP;
    end;
    if m_PEnvir.Flag.boPKLOSTEXP then
    begin
      boLostExp := True;
      nLostExp := m_PEnvir.Flag.nPKLOSTEXP;
    end;

    if PlayObject.m_Abil.Level - m_Abil.Level > g_Config.nHumanLevelDiffer then
    begin
      if not PlayObject.IsGoodKilling(self) then
      begin
        if PlayObject.m_boHero and (not g_Config.bHeroKillManAddPK) then
        begin
          PlayObject.m_HeroHuman.IncPkPoint(g_Config.nKillHumanAddPKPoint
            {100});
          PlayObject.m_HeroHuman.SysMsg(g_sYouMurderedMsg
            {'你犯了谋杀罪！！！'}, c_Red, t_Hint);
        end
        else
        begin
          PlayObject.IncPkPoint(g_Config.nKillHumanAddPKPoint {100});
          PlayObject.SysMsg(g_sYouMurderedMsg {'你犯了谋杀罪！！！'},
            c_Red, t_Hint);
        end;
        SysMsg(format(g_sYouKilledByMsg, [m_LastHiter.m_sCharName]), c_Red,
          t_Hint);
        PlayObject.AddBodyLuck(-g_Config.nKillHumanDecLuckPoint {500});
        if (PkLevel < 1) and (Random(5) = 0) then
        begin
          if PlayObject.m_boHero and (not g_Config.bHeroKillManAddPK) then
            PlayObject.m_HeroHuman.MakeWeaponUnlock
          else
            PlayObject.MakeWeaponUnlock;
        end;
      end
      else
      begin
        PlayObject.SysMsg(g_sYouProtectedByLawOfDefense
          {'[你受到正当规则保护。]'}, c_Green, t_Hint);
      end;
      exit;
    end;
    if boWinLEvel then
    begin
      //Inc(PlayObject.m_Abil.Level,nWinLevel);
      if PlayObject.m_Abil.Level + nWinLevel <= MAXUPLEVEL then
      begin
        Inc(PlayObject.m_Abil.Level, nWinLevel);
      end
      else
      begin
        PlayObject.m_Abil.Level := MAXUPLEVEL;
      end;
      PlayObject.HasLevelUp(PlayObject.m_Abil.Level - nWinLevel);

      if boLostLevel then
      begin
        if PKLevel >= 2 then
        begin
          if m_Abil.Level >= nLostLevel * 2 then
            Dec(m_Abil.Level, nLostLevel * 2);
        end
        else
        begin
          if m_Abil.Level >= nLostLevel then
            Dec(m_Abil.Level, nLostLevel);
        end;
      end;

    end;

    if boWinExp then
    begin
      PlayObject.WinExp(nWinExp);
      if boLostExp then
      begin
        if m_Abil.Exp >= LongWord(nLostExp) then
        begin
          if m_Abil.Exp >= LongWord(nLostExp) then
          begin
            Dec(m_Abil.Exp, LongWord(nLostExp));
          end
          else
          begin
            m_Abil.Exp := 0;
          end;
        end
        else
        begin
          if m_Abil.Level >= 1 then
          begin
            Dec(m_Abil.Level);
            Inc(m_Abil.Exp, GetLevelExp(m_Abil.Level));
            if m_Abil.Exp >= LongWord(nLostExp) then
            begin
              Dec(m_Abil.Exp, LongWord(nLostExp));
            end
            else
            begin
              m_Abil.Exp := 0;
            end;
          end
          else
          begin
            m_Abil.Level := 0;
            m_Abil.Exp := 0;
          end;
          //HasLevelUp(m_Abil.Level + 1);
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.PKDie');
  end;
end;

procedure TBaseObject.ReAlive; //004BC710
begin
  try
    m_boDeath := False;
    SendRefMsg(RM_ALIVE, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.ReAlive');
  end;
end;

procedure TBaseObject.SetLastHiter(BaseObject: TBaseObject); //004BC74C
begin
  try
    m_LastHiter := BaseObject;
    m_LastHiterTick := GetTickCount();
    if m_ExpHitter = nil then
    begin
      m_ExpHitter := BaseObject;
      m_ExpHitterTick := GetTickCount();
    end
    else
    begin
      if m_ExpHitter = BaseObject then
        m_ExpHitterTick := GetTickCount();
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SetLastHiter');
  end;
end;

procedure TBaseObject.SetPKFlag(BaseObject: TBaseObject); //004BC7BC
begin
  try
    if (PKLevel < 2) and
      (BaseObject.PKLevel < 2) and
      (not m_PEnvir.Flag.boFightZone) and
      (not m_PEnvir.Flag.boFight2Zone) and
      (not m_PEnvir.Flag.boFight3Zone) and
      (not m_boPKFlag) and
      (Self <> BaseObject.m_Hero) then
    begin

      BaseObject.m_dwPKTick := GetTickCount();
      if not BaseObject.m_boPKFlag then
      begin
        BaseObject.m_boPKFlag := True;
        BaseObject.RefNameColor();
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.SetPKFlag');
  end;
end;

procedure TBaseObject.sub_4BC87C; //004BC87C
//var
  //I: Integer;
begin
  try
    {for I := 0 to LIst_3EC.Count - 1 do begin

    end;
    LIst_3EC.Clear; }
  except
    MainOutMessage('[Exception] TBaseObject.sub_4BC87C');
  end;
end;

function TBaseObject.IsGoodKilling(cert: TBaseObject): Boolean; //004BC8D8
begin
  try
    Result := False;
    if cert.m_boPKFlag then
      Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.IsGoodKilling');
  end;
end;

//004C880C 0FFFF6

function TBaseObject.IsProtectTarget(BaseObject: TBaseObject): boolean;
begin
  try
    Result := True;
    if BaseObject = nil then
      exit;
    if (InSafeZone) or (BaseObject.InSafeZone) then
      Result := False;
    if not BaseObject.m_boInFreePKArea then
    begin
      //新人保护
      if g_Config.boPKLevelProtect then
      begin
        if (m_Abil.Level > g_Config.nPKProtectLevel) then
        begin //如果大于指定等级
          if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level <=
            g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then
          begin
            //被攻击的人物小指定等级没有红名，则不可以攻击。
            Result := False;
            exit;
          end;
        end;
        if (m_Abil.Level <= g_Config.nPKProtectLevel) then
        begin //如果小于指定等级
          if not BaseObject.m_boPKFlag and (BaseObject.m_Abil.Level >
            g_Config.nPKProtectLevel) and (BaseObject.PKLevel < 2) then
          begin
            Result := False;
            exit;
          end;
        end;

      end;

      {
      //大于指定级别的红名人物不可以杀指定级别未红名的人物。
      if (PKLevel >= 2) and (m_Abil.Level > 10) then begin
        if (BaseObject.m_Abil.Level <= 10) and (BaseObject.PKLevel < 2) then begin
          Result:=False;
          exit;
        end;
      end;

      //小于指定级别的非红名人物不可以杀指定级别红名人物。
      if (m_Abil.Level <= 10) and (PKLevel < 2) then begin
        if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level > 10) then begin
          Result:=False;
          exit;
        end;
      end;
      }
      //大于指定级别的红名人物不可以杀指定级别未红名的人物。
      if (PKLevel >= 2) and (m_Abil.Level > g_Config.nRedPKProtectLevel) then
      begin
        if (BaseObject.m_Abil.Level <= g_Config.nRedPKProtectLevel) and
          (BaseObject.PKLevel < 2) then
        begin
          Result := False;
          exit;
        end;
      end;

      //小于指定级别的非红名人物不可以杀指定级别红名人物。
      if (m_Abil.Level <= g_Config.nRedPKProtectLevel) and (PKLevel < 2) then
      begin
        if (BaseObject.PKLevel >= 2) and (BaseObject.m_Abil.Level >
          g_Config.nRedPKProtectLevel) then
        begin
          Result := False;
          exit;
        end;
      end;

      if (GetTickCount - m_dwMapMoveTick < 3000) or (GetTickCount -
        BaseObject.m_dwMapMoveTick < 3000) then
        Result := False;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsProtectTarget');
  end;
end;

//是否允许攻击，以攻击模式为准

function TBaseObject.IsAttackTarget(BaseObject: TBaseObject): boolean;
//004C89D0 0FFFF5
  function sub_4C88E4(): Boolean;
  begin
    Result := True;
  end;
var
  I: Integer;
begin
  try
    Result := False;
    if (BaseObject = nil) or (BaseObject = Self) then
      exit;
    if m_boHero then
    begin
      if (m_HeroHuman <> nil) and (m_AllMaster <> nil) then
      begin
        if BaseObject = m_HeroHuman then
          exit;
        if (m_HeroHuman.m_LastHiter = BaseObject) or
          (m_HeroHuman.m_ExpHitter = BaseObject) or
          (m_HeroHuman.m_TargetCret = BaseObject) then
          Result := True;
        if (not Result) and (BaseObject.m_TargetCret <> nil) then
        begin
          if (BaseObject.m_TargetCret = m_AllMaster) or
            (BaseObject.m_TargetCret = self) or
            (BaseObject.m_TargetCret.m_AllMaster = m_AllMaster) then
          begin
            {(BaseObject.m_btRaceServer <> RC_PLAYOBJECT) }
            Result := True;
          end;
        end;
        if (not Result) and (BaseObject.m_AllMaster <> nil) then
        begin
          if (BaseObject.m_AllMaster = m_HeroHuman.m_LastHiter) or
            (BaseObject.m_AllMaster = m_HeroHuman.m_TargetCret) then
            Result := True;
          //end else begin
            //if BaseObject.m_btRaceServer >= RC_ANIMAL then Result:=True;
        end;
        if BaseObject.m_AllMaster = m_AllMaster then
          Result := False;
        if BaseObject = m_AllMaster then
          Result := False;
        if BaseObject.m_boHolySeize then
          Result := False;
        if BaseObject = m_HeroLocked then
          Result := True;
        if Baseobject.m_btRaceServer = RC_NPC then
          Result := False;
        if Result then
        begin
          if ((BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
            (m_AllMaster.m_btRaceServer = RC_PLAYOBJECT)) or
            ((BaseObject.m_AllMaster <> nil) and
            (BaseObject.m_AllMaster.m_btRaceServer = RC_PLAYOBJECT) and
            (m_AllMaster.m_btRaceServer = RC_PLAYOBJECT)) then
          begin
            if BaseObject.InSafeZone or InSafeZone then
              Result := False;
          end;
        end;
        {if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_AllMaster2<>nil) then begin
          if Result and (BaseObject.InSafeZone or InSafeZone) then Result:=False;  //004C8B6B
        end; }
      end;
    end
    else if m_btRaceServer >= RC_ANIMAL {50} then
    begin
      if (m_Master2 <> nil) and (m_AllMaster <> nil) then
      begin
        if (m_Master2.m_LastHiter = BaseObject) or
          (m_Master2.m_ExpHitter = BaseObject) or
          (m_Master2.m_TargetCret = BaseObject) then
          Result := True;
        if (BaseObject.m_TargetCret <> nil) then
        begin
          if (BaseObject.m_TargetCret = m_AllMaster) or
            (BaseObject.m_TargetCret = self) or
            (BaseObject.m_TargetCret.m_AllMaster = m_AllMaster) then
          begin
            {(BaseObject.m_btRaceServer <> RC_PLAYOBJECT) }
            Result := True;
          end;
        end;
        {if BaseObject.m_TargetCret <> nil then begin
          if (BaseObject.m_TargetCret = m_Master) or
             (BaseObject.m_TargetCret.m_Master = m_Master) and
             (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then
            Result:=True;
        end; //004C8AB3  }
        {if (BaseObject.m_TargetCret = Self) and (BaseObject.m_btRaceServer >= RC_ANIMAL) then
          Result:=True; }
        //004C8AD1
        if BaseObject.m_Master2 <> nil then
        begin
          if (BaseObject.m_Master2 = m_Master2.m_LastHiter) or
            (BaseObject.m_Master2 = m_Master2.m_TargetCret) then
            Result := True;
          //end else begin
            //if BaseObject.m_btRaceServer >= RC_ANIMAL then Result:=True;
        end; //004C8B15
        if BaseObject.m_AllMaster = m_AllMaster then
          Result := False;
        if BaseObject = m_AllMaster then
          Result := False;
        if BaseObject.m_boHolySeize then
          Result := False;
        if m_Master2.m_boSlaveRelax then
          Result := False;
        if Baseobject.m_btRaceServer = RC_NPC then
          Result := False;
        if Result then
        begin
          if ((BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
            (m_AllMaster.m_btRaceServer = RC_PLAYOBJECT)) or
            ((BaseObject.m_AllMaster <> nil) and
            (BaseObject.m_AllMaster.m_btRaceServer = RC_PLAYOBJECT) and
            (m_AllMaster.m_btRaceServer = RC_PLAYOBJECT)) then
          begin
            if BaseObject.InSafeZone or InSafeZone then
              Result := False;
          end;
        end;
        {if Result and
           (
            (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
            ((BaseObject.m_AllMaster2<>nil) and (BaseObject.m_AllMaster2.m_btRaceServer = RC_PLAYOBJECT))
           ) and
           (BaseObject.InSafeZone or InSafeZone)  then begin
          Result:=False;
        end;

        if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or (BaseObject.m_AllMaster2<>nil) then begin
          if Result and (BaseObject.InSafeZone or InSafeZone) then Result:=False;  //004C8B6B
        end; }
        {if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
           ((BaseObject.m_AllMaster2<>nil) and (BaseObject.m_AllMaster2.m_btRaceServer = RC_PLAYOBJECT)) then begin
          if Result and (BaseObject.InSafeZone or InSafeZone) then Result:=False;  //004C8B6B
        end;  }
        if (m_btRaceServer = RC_PLAYCLONE) and
          //英雄分身，主人休息分身不攻击
        (m_Master2.m_boHero) and
          (m_Master2.m_btAttatckMode <> 0) then
          Result := False;
        BreakCrazyMode();
      end
      else
      begin //004C8B79
        if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
          Result := True;
        if (m_btRaceServer > RC_PEACENPC {15}) and (m_btRaceServer < RC_ANIMAL
          {50}) then
          Result := True;
        if (BaseObject.m_Master2 <> nil) then
        begin
          Result := True;
          if (BaseObject.m_AllMaster <> nil) and
            (BaseObject.m_AllMaster.m_btRaceServer <> RC_PLAYOBJECT) then
            Result := False;
        end;
      end; //004C8BB5
      if m_boCrazyMode and ((BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
        (BaseObject.m_btRaceServer > RC_PEACENPC)) then
        Result := True;
      if m_boNastyMode and ((BaseObject.m_btRaceServer < RC_NPC) or
        (BaseObject.m_btRaceServer > RC_PEACENPC)) then
        Result := True;
    end
    else
    begin //004C8BCE
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        case m_btAttatckMode of //
          HAM_ALL {0}:
            begin
              if (BaseObject.m_btRaceServer < RC_NPC {10}) or
                (BaseObject.m_btRaceServer > RC_PEACENPC {15}) then
                Result := True;
              if g_Config.boNonPKServer then
                Result := sub_4C88E4();
            end;
          HAM_PEACE {1}:
            begin
              if BaseObject.m_btRaceServer >= RC_ANIMAL then
                Result := True;
            end;
          HAM_DEAR:
            begin
              if BaseObject <> TPlayObject(Self).m_DearHuman then
              begin
                Result := True;
              end;
            end;
          HAM_MASTER:
            begin
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
              begin
                Result := True;
                if TPlayObject(Self).m_boMaster then
                begin
                  for I := 0 to TPlayObject(Self).m_MasterList.Count - 1 do
                  begin
                    if TPlayObject(Self).m_MasterList.Items[I] = BaseObject then
                    begin
                      Result := False;
                      break;
                    end;
                  end;
                end;
                if TPlayObject(BaseObject).m_boMaster then
                begin
                  for I := 0 to TPlayObject(BaseObject).m_MasterList.Count - 1
                    do
                  begin
                    if TPlayObject(BaseObject).m_MasterList.Items[I] = Self then
                    begin
                      Result := False;
                      break;
                    end;
                  end;
                end;
              end
              else
                Result := True;
            end;
          HAM_GROUP {2}:
            begin
              if (BaseObject.m_btRaceServer < RC_NPC) or
                (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if IsGroupMember(BaseObject) then
                  Result := False;
              if g_Config.boNonPKServer then
                Result := sub_4C88E4();
            end;
          HAM_GUILD {3}:
            begin
              if (BaseObject.m_btRaceServer < RC_NPC) or
                (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if m_MyGuild <> nil then
                begin
                  if TGuild(m_MyGuild).IsMember(BaseObject.m_sCharName) then
                    Result := False;
                  if m_boGuildWarArea and (BaseObject.m_MyGuild <> nil) then
                  begin
                    if
                      TGuild(m_MyGuild).IsAllyGuild(TGuild(BaseObject.m_MyGuild))
                        then
                      Result := False;
                  end;
                end;
              if g_Config.boNonPKServer then
                Result := sub_4C88E4();
            end;
          HAM_PKATTACK {4}:
            begin
              if (BaseObject.m_btRaceServer < RC_NPC) or
                (BaseObject.m_btRaceServer > RC_PEACENPC) then
                Result := True;
              if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
                if PKLevel >= 2 then
                begin
                  if BaseObject.PKLevel < 2 then
                    Result := True
                  else
                    Result := False;
                end
                else
                begin
                  if BaseObject.PKLevel >= 2 then
                    Result := True
                  else
                    Result := False;
                end;
              if g_Config.boNonPKServer then
                Result := sub_4C88E4();
            end;
        end;
      end
      else
        Result := True;
    end; //004C8DF0
    if BaseObject.m_boAdminMode or BaseObject.m_boStoneMode then
      Result := False;
  except
    MainOutMessage('[Exception] TBaseObject.IsAttackTarget');
  end;
end;

function TBaseObject.IsProperTarget(BaseObject: TBaseObject): Boolean;
//004C8E30 0FFFF4
begin
  try
    Result := False;
    if m_PEnvir.Flag.boMission then
      exit;
    if (BaseObject = nil) or (BaseObject = Self) then
      exit;

    {Result:=IsAttackTarget(BaseObject);
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_AllMaster<>nil) or  (BaseObject.m_AllMaster <> nil) then begin
      if Result then begin
        if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not m_boHero) and (not BaseObject.m_boHero)  then begin
          Result:=IsProtectTarget(BaseObject); //0FFFF6
        end;
      end;
      if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) or (BaseObject.m_boHero) then begin
        if BaseObject.m_AllMaster = Self then begin
          if m_btAttatckMode <> HAM_ALL then Result:=False;
        end else begin
          Result:=IsAttackTarget(BaseObject.m_AllMaster);
          if Result and (InSafeZone or BaseObject.InSafeZone) then Result:=False;
        end;
      end;
    end;   }

    Result := IsAttackTarget(BaseObject); //0FFFF5
    if Result then
    begin
      if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer =
        RC_PLAYOBJECT) and (not m_boHero) and (not BaseObject.m_boHero) then
      begin
        Result := IsProtectTarget(BaseObject); //0FFFF6
      end;
    end;
    if (m_btRaceServer = RC_PLAYOBJECT) and
      (BaseObject.m_AllMaster <> nil) then
    begin
      if BaseObject.m_AllMaster = Self then
      begin
        if m_btAttatckMode <> HAM_ALL then
          Result := False;
      end
      else
      begin
        Result := IsAttackTarget(BaseObject.m_AllMaster);
        if m_HeroLocked = BaseObject then
          Result := True;
        if Result then
        begin
          if (BaseObject.m_AllMaster.m_btRaceServer = RC_PLAYOBJECT) then
          begin
            if BaseObject.InSafeZone or InSafeZone then
              Result := False;
          end;
        end;
        //if Result and (InSafeZone or BaseObject.InSafeZone) then Result:=False;
      end;
    end;
    {if (m_btRaceServer = RC_PLAYOBJECT) or (m_AllMaster <> nil) then begin
      //if not (InSafeZone or BaseObject.InSafeZone) then begin
      if BaseObject.m_AllMaster <> nil then begin
        if BaseObject.m_AllMaster = Self then begin
          if m_btAttatckMode = HAM_ALL then Result:=True;
        end else Result:=IsAttackTarget(BaseObject.m_AllMaster);
      end else Result:=IsAttackTarget(BaseObject);
      if Result and (BaseObject.m_AllMaster <> Self) and (InSafeZone or BaseObject.InSafeZone) then
        Result:=False;
    end else Result:=IsAttackTarget(BaseObject);}

    {if (BaseObject <> nil) and
       (BaseObject.m_AllMaster <> nil) then begin
      if BaseObject.m_AllMaster = Self then begin
        if m_btAttatckMode = HAM_ALL then Result:=True;
      end else begin
        Result:=IsAttackTarget(BaseObject.m_AllMaster);
        if Result and (InSafeZone or BaseObject.InSafeZone) then Result:=False;
      end;
    end else begin
      Result:=IsAttackTarget(BaseObject); //0FFFF5
      if Result then begin
        if (m_btRaceServer = RC_PLAYOBJECT) and
           (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and
           (not m_boHero) and
           (not BaseObject.m_boHero)then begin
          Result:=IsProtectTarget(BaseObject); //0FFFF6
        end;
      end;
    end;}
    {Result:=IsAttackTarget(BaseObject);
    if (m_btRaceServer = RC_PLAYOBJECT) or (m_AllMaster <> nil) then begin
      if Result then begin
        if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not m_boHero) and (not BaseObject.m_boHero)  then begin
          Result:=IsProtectTarget(BaseObject); //0FFFF6
        end;
      end;
      if (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) or (BaseObject.m_boHero) then begin
        if BaseObject.m_AllMaster = Self then begin
          if m_btAttatckMode <> HAM_ALL then Result:=False;
        end else begin
          Result:=IsAttackTarget(BaseObject.m_AllMaster);
          if Result and (InSafeZone or BaseObject.InSafeZone) then Result:=False;
        end;
      end;
    end;}
    {Result:=IsAttackTarget(BaseObject); //0FFFF5
    if Result then begin
      if (m_btRaceServer = RC_PLAYOBJECT) and (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not m_boHero) then begin
        Result:=IsProtectTarget(BaseObject); //0FFFF6
      end;
    end;
    if (BaseObject <> nil) and
       (m_btRaceServer = RC_PLAYOBJECT) and
       (BaseObject.m_AllMaster <> nil) and
       (BaseObject.m_btRaceServer <> RC_PLAYOBJECT) then begin
      if BaseObject.m_AllMaster = Self then begin
        if m_btAttatckMode <> HAM_ALL then Result:=False;
      end else begin
        Result:=IsAttackTarget(BaseObject.m_AllMaster);
        if InSafeZone or BaseObject.InSafeZone then Result:=False;
      end;
    end;}
  except
    MainOutMessage('[Exception] TBaseObject.IsProperTarget');
  end;
end;

procedure TBaseObject.WeightChanged; //004C49BC
begin
  try
    m_WAbil.Weight := RecalcBagWeight();
    SendUpdateMsg(Self, RM_WEIGHTCHANGED, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.WeightChanged');
  end;
end;

function TBaseObject.InSafeZone: Boolean; //004BEE20
var
  I: Integer;
  //  sMapName:String;
  StartPoint: pTStartPoint;
begin
  try
    if m_PEnvir = nil then
    begin //修正机器人刷火墙的错误
      Result := True;
      Exit;
    end;
    Result := m_PEnvir.Flag.boSAFE;
    if Result then
      exit;
    if (m_PEnvir.sMapName <> g_Config.sRedHomeMap) or
      (abs(m_nCurrX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
      (abs(m_nCurrY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
    begin
      Result := False;
    end
    else
    begin //004BEE98
      Result := True;
    end;
    if Result then
      exit;

    g_StartPoint.Lock;
    try
      for I := 0 to g_StartPoint.Count - 1 do
      begin
        StartPoint := g_StartPoint.Items[I];
        if StartPoint.Envir = m_PEnvir then
        begin
          if (abs(m_nCurrX - StartPoint.nX) <= g_Config.nSafeZoneSize) and
            (abs(m_nCurrY - StartPoint.nY) <= g_Config.nSafeZoneSize) then
          begin
            Result := True;
            break;
          end;
        end;
      end;
    finally
      g_StartPoint.UnLock;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.InSafeZone:');
  end;
end;

function TBaseObject.InSafeZone(Envir: TEnvirnoment; nX,
  nY: Integer): Boolean;
var
  I: Integer;
  //  sMapName:String;
  StartPoint: pTStartPoint;
begin
  try
    if m_PEnvir = nil then
    begin //修正机器人刷火墙的错误
      Result := True;
      Exit;
    end;
    Result := Envir.Flag.boSAFE;
    if Result then
      exit;
    if (Envir.sMapName <> g_Config.sRedHomeMap) or
      (abs(nX - g_Config.nRedHomeX) > g_Config.nSafeZoneSize) or
      (abs(nY - g_Config.nRedHomeY) > g_Config.nSafeZoneSize) then
    begin
      Result := False;
    end
    else
    begin //004BEE98
      Result := True;
    end;
    if Result then
      exit;

    try
      g_StartPoint.Lock;
      for I := 0 to g_StartPoint.Count - 1 do
      begin
        StartPoint := g_StartPoint.Items[I];
        if StartPoint.Envir = m_PEnvir then
        begin
          if (abs(nX - StartPoint.nX) <= g_Config.nSafeZoneSize) and (abs(nY -
            StartPoint.nY) <= g_Config.nSafeZoneSize) then
          begin
            Result := True;
            break;
          end;
        end;
      end;
    finally
      g_StartPoint.UnLock;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.InSafeZone');
  end;
end;

//004BDBBC

procedure TBaseObject.OpenHolySeizeMode(dwInterval: LongWord);
begin
  try
    m_boHolySeize := True;
    m_dwHolySeizeTick := GetTickCount();
    m_dwHolySeizeInterval := dwInterval;
    RefNameColor();
  except
    MainOutMessage('[Exception] TBaseObject.OpenHolySeizeMode');
  end;
end;
//004BDBF8

procedure TBaseObject.BreakHolySeizeMode;
begin
  try
    if m_boHolySeize then
    begin
      m_boHolySeize := False;
      RefNameColor();
    end;
  except
    MainOutMessage('[Exception] TBaseObject.BreakHolySeizeMode');
  end;
end;

procedure TBaseObject.OpenCrazyMode(nTime: Integer); //004BDC14
begin
  try
    m_boCrazyMode := True;
    m_dwCrazyModeTick := GetTickCount();
    m_dwCrazyModeInterval := nTime * 1000;
    RefNameColor();
  except
    MainOutMessage('[Exception] TBaseObject.OpenCrazyMode');
  end;
end;

procedure TBaseObject.BreakCrazyMode; //004BDC54
begin
  try
    if m_boCrazyMode then
    begin
      m_boCrazyMode := False;
      RefNameColor();
    end;
  except
    MainOutMessage('[Exception] TBaseObject.BreakCrazyMode');
  end;
end;

procedure TBaseObject.LeaveGroup; //004C3B70
resourcestring
  sExitGropMsg = '%s 退出小组.';
begin
  try
    SendGroupText(format(sExitGropMsg, [m_sCharName]));
    m_GroupOwner := nil;
    SendMsg(Self, RM_GROUPCANCEL, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.LeaveGroup');
  end;
end;

function TPlayObject.CancelGroup: Boolean; //004C397C
resourcestring
  sCanceGrop = '你的组队已被解散了.';
begin
  try
    Result := True;
    if m_GroupMembers.Count <= 1 then
    begin
      SendGroupText(sCanceGrop);
      m_GroupMembers.Clear;
      m_GroupOwner := nil;
      if m_boAllowAddGroup then
      begin
        m_boAllowAddGroup := False;
        RefShowName;
      end;
      Result := False;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CancelGroup:');
  end;
end;

procedure TPlayObject.SendGroupMembers; //004DCBA4
var
  I: Integer;
  PlayObject: TPlayObject;
  sSendMsg: string;
begin
  try
    sSendMsg := '';
    for I := 0 to m_GroupMembers.Count - 1 do
    begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
      sSendMsg := sSendMsg + PlayObject.m_sCharName + '/';
    end;
    for I := 0 to m_GroupMembers.Count - 1 do
    begin
      PlayObject := TPlayObject(m_GroupMembers.Objects[i]);
      PlayObject.SendDefMessage(SM_GROUPMEMBERS, 0, 0, 0, 0, sSendMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendGroupMembers');
  end;
end;

//乾坤大挪移
procedure TBaseObject.SKILL_82(sMap: string; nX, nY: Integer);
begin
 if (GetTickCount - m_dwSkill82Tick) > LongWord(g_Config.nSkill82Time* 1000) then
 begin
   m_dwSkill82Tick := GetTickCount();
   if m_PEnvir.CanWalk(nX, nY, False) then
     SpaceMove(sMap,nX, nY, 1)
   else
     SysMsg('目标不能到达！', c_Red, t_Hint);
 end else
  SysMsg(IntToStr(LongWord(g_Config.nSkill82Time)-(GetTickCount-LongWord(m_dwSkill82Tick))
     div 1000)+'秒之后才可以再使用此功能！', c_Red, t_Hint);
end;

//替换技能
procedure TBaseObject.ChangeSKILL(nSour,nNew:Integer);
var
  UserMagic: pTUserMagic;
  Magic: pTMagic;
  cm: TClientMagic;
  m_DefMsg:TDefaultMessage;
begin
  try
     Magic:=nil;
     Magic:=UserEngine.FindMagic(nNew,m_boHero);
     if Magic<>nil then
     begin
     UserMagic:=nil;
       if m_boHero then
         UserMagic:=GetMagicInfoEx(nSour)
       else
         UserMagic:=GetMagicInfo(nSour);
     if UserMagic<>nil then
     begin
       UserMagic.MagicInfo:=Magic;
       UserMagic.btLevel:=3;
       UserMagic.wMagIdx:=nNew;
       FillChar(cm,SizeOf(cm),#0);
       cm.Key:=Char(UserMagic.btKey);
       cm.Level:=3;
       cm.CurTrain:=UserMagic.nTranPoint;
       cm.Def:=Magic^;
       if m_boHero then
         begin
           m_DefMsg := MakeDefaultMsg(SM_HeroChangeSKILL,nSour, 0, 0, 0);
           TPlayObject(Self).SendSocket(@m_DefMsg, EncodeBuffer(@cm,SizeOf(cm)));
         end
       else
          begin
            m_DefMsg := MakeDefaultMsg(SM_ChangeSKILL,nSour, 0, 0, 0);
            TPlayObject(Self).SendSocket(@m_DefMsg, EncodeBuffer(@cm,SizeOf(cm)));
         end;
     end;
     end;
  except
    MainOutMessage('[Exception] TBaseObject.ChangeSKILL');
  end;
end;

function TBaseObject.GetMagicInfoEx(nMagic: Integer): pTUserMagic;
begin
  try
    Result := nil;
    if (nMagic > 0) and (nMagic < 99) then
      Result := m_HeroMagic[nMagic];
  except
    MainOutMessage('[Exception] TBaseObject.GetMagicInfoEx');
  end;
end;

function TBaseObject.GetMagicInfo(nMagicID: Integer): pTUserMagic; //004CBC7C
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  try
    Result := nil;
    for I := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[i];
      if UserMagic.MagicInfo.wMagicId = nMagicID then
      begin
        Result := UserMagic;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.GetMagicInfo');
  end;
end;

function TPlayObject.GetSpellPoint(UserMagic: pTUserMagic): Integer; //004C6910
begin
  try
    Result := 0;
    if UserMagic = nil then
      exit;
    Result := ROUND(UserMagic.MagicInfo.wSpell / (UserMagic.MagicInfo.btTrainLv
      + 1) * (UserMagic.btLevel + 1)) + UserMagic.MagicInfo.btDefSpell;
  except
    on E: Exception do
    begin
      MainOutMessage('[Exception] TPlayObject.GetSpellPoint');
      MainOutMessage(E.Message);
    end;
  end;
end;

function TPlayObject.CanMotaebo(BaseObject: TBaseObject; nMagicLevel: Integer):
  Boolean; //0x004C30B0
var
  nC: Integer;
begin
  Result := False;
  if (m_Abil.Level > BaseObject.m_Abil.Level) and (not BaseObject.m_boStickMode)
    then
  begin
    nC := m_Abil.Level - BaseObject.m_Abil.Level;
    if Random(20) < ((nMagicLevel * 4) + 6 + nC) then
    begin
      if IsProperTarget(BaseObject) then
        Result := True;
    end;
  end;
end;

function TPlayObject.DoMotaebo(nDir: Byte; nMagicLevel: Integer): Boolean;
////004C3130
var
  bo35: Boolean;
  I, nDmg, n24, n28: Integer;
  PoseCreate: TBaseObject;
  BaseObject_30: TBaseObject;
  BaseObject_34: TBaseObject;
  nX, nY: integer;
begin
  try
    Result := False;
    bo35 := True;
    m_btDirection := nDir;
    BaseObject_34 := nil;
    n24 := nMagicLevel + 1;
    n28 := n24;
    PoseCreate := GetPoseCreate();
    if PoseCreate <> nil then
    begin
      for I := 0 to _MAX(2, nMagicLevel + 1) do
      begin
        PoseCreate := GetPoseCreate();
        if PoseCreate <> nil then
        begin
          n28 := 0;
          if not CanMotaebo(PoseCreate, nMagicLevel) then
            break;
          if nMagicLevel >= 3 then
          begin
            if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2,
              nX, nY) then
            begin
              BaseObject_30 := m_PEnvir.GetMovingObject(nX, nY, True);
              if (BaseObject_30 <> nil) and CanMotaebo(BaseObject_30,
                nMagicLevel) then
                BaseObject_30.CharPushed(m_btDirection, 1); //004C3237
            end; //004C323C
          end; //004C323C if nMagicLevel >= 3 then begin
          BaseObject_34 := PoseCreate;
          if PoseCreate.CharPushed(m_btDirection, 1) <> 1 then
            break;
          GetFrontPosition(nX, nY); //sub_004B2790
          if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False)
            > 0 then
          begin
            m_nCurrX := nX;
            m_nCurrY := nY;
            SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
            bo35 := False;
            Result := True;
          end;
          Dec(n24);
        end; //004C32D7  if PoseCreate <> nil  then begin
      end; //004C32DD for i:=0 to _MAX(2,nMagicLevel + 1) do begin
    end
    else
    begin //004C32E8 if PoseCreate <> nil  then begin
      bo35 := False;
      for i := 0 to _MAX(2, nMagicLevel + 1) do
      begin
        GetFrontPosition(nX, nY); //sub_004B2790
        if m_PEnvir.MoveToMovingObject(m_nCurrX, m_nCurrY, Self, nX, nY, False)
          > 0 then
        begin
          m_nCurrX := nX;
          m_nCurrY := nY;
          SendRefMsg(RM_RUSH, nDir, m_nCurrX, m_nCurrY, 0, '');
          Dec(n28);
        end
        else
        begin
          if m_PEnvir.CanWalk(nX, nY, True) then
            n28 := 0
          else
          begin
            bo35 := True;
            break;
          end;
        end;
      end; //004C33AD
    end; //004C33B3
    if (BaseObject_34 <> nil) then
    begin //004C33B3
      if n24 < 0 then
        n24 := 0;
      nDmg := Random((n24 + 1) * 10) + ((n24 + 1) * 10);
      nDmg := BaseObject_34.GetHitStruckDamage(Self, nDmg);
      BaseObject_34.StruckDamage(nDmg, self);
      BaseObject_34.SendRefMsg(RM_STRUCK, nDmg, BaseObject_34.m_WAbil.HP,
        BaseObject_34.m_WAbil.MaxHP, Integer(Self), '');
      if BaseObject_34.m_btRaceServer <> RC_PLAYOBJECT then
      begin
        BaseObject_34.SendMsg(BaseObject_34, RM_STRUCK, nDmg,
          BaseObject_34.m_WAbil.HP, BaseObject_34.m_WAbil.MaxHP, Integer(Self),
          '');
      end;
    end; //004C3464
    if bo35 then
    begin
      GetFrontPosition(nX, nY); //sub_004B2790
      SendRefMsg(RM_RUSHKUNG, m_btDirection, nX, nY, 0, '');
      if not m_boHero then
        SysMsg(sMateDoTooweak {冲撞力不够！！！}, c_Red, t_Hint);
    end;
    if n28 > 0 then
    begin
      if n24 < 0 then
        n24 := 0;
      nDmg := Random(n24 * 10) + ((n24 + 1) * 3);
      nDmg := GetHitStruckDamage(Self, nDmg);
      StruckDamage(nDmg, self);
      SendRefMsg(RM_STRUCK, nDmg, m_WAbil.HP, m_WAbil.MaxHP, 0, '');
    end;

  except
    MainOutMessage('[Exception] TPlayObject.DoMotaebo');
  end;
end;
//004C1268

procedure TBaseObject.TrainSkill(UserMagic: pTUserMagic;
  nTranPoint: Integer);
begin
  try
    if m_boFastTrain then
      nTranPoint := nTranPoint * 3;
    Inc(UserMagic.nTranPoint, nTranPoint);
  except
    MainOutMessage('[Exception] TBaseObject.TrainSkill');
  end;
end;

function TBaseObject.CheckMagicLevelup(UserMagic: pTUserMagic): Boolean;
//004C7054
var
  n10: Integer;
begin
  try
    Result := False;
    if (UserMagic.btLevel < 4) and (UserMagic.MagicInfo.btTrainLv >=
      UserMagic.btLevel) then
      n10 := UserMagic.btLevel
    else
      n10 := 0;

    if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) and
      (UserMagic.MagicInfo.MaxTrain[n10] <= UserMagic.nTranPoint) then
    begin

      if (UserMagic.MagicInfo.btTrainLv > UserMagic.btLevel) then
      begin
        Dec(UserMagic.nTranPoint, UserMagic.MagicInfo.MaxTrain[n10]);
        Inc(UserMagic.btLevel);
        SendUpdateDelayMsg(Self, RM_MAGIC_LVEXP, 0,
          UserMagic.MagicInfo.wMagicId, UserMagic.btLevel, UserMagic.nTranPoint,
          '', 800);
        sub_4C713C(UserMagic);
        if UserMagic.MagicInfo.wMagicID in [SKILL_ONESWORD, SKILL_YEDO,
          SKILL_ILKWANG, SKILL_FIRECHARM, SKILL_FIRESWORD, SKILL_45] then
        begin
          RecalcAbilitys;
          SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
        end;
      end
      else
      begin
        UserMagic.nTranPoint := UserMagic.MagicInfo.MaxTrain[n10];
      end;
      Result := True;
    end; //004C7132
  except
    MainOutMessage('[Exception] TBaseObject.CheckMagicLevelup');
  end;
end;

function TPlayObject.DoSpell(UserMagic: pTUserMagic; nTargetX,
  nTargetY: Integer; BaseObject: TBaseObject): boolean; //004C6968
var
  nSpellPoint: integer;
begin
  try
    Result := False;
    try
      if not MagicManager.IsWarrSkill(UserMagic.wMagIdx) then
      begin
        nSpellPoint := GetSpellPoint(UserMagic);
        if nSpellPoint > 0 then
        begin
          if m_WAbil.MP < nSpellPoint then
            exit;
          DamageSpell(nSpellPoint);
          HealthSpellChanged();
        end;
        Result := MagicManager.DoSpell(Self, UserMagic, nTargetX, nTargetY,
          BaseObject);
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(format('[Exception] TPlayObject.DoSpell MagID:%d X:%d Y:%d', [UserMagic.wMagIdx, nTargetX, nTargetY]));
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.DoSpell');
  end;
end;

function TPlayObject.PileStones2(nX, nY: Integer): Boolean; //004CB64C
var
  //  Event     :TEvent;
  PileEvent: TEvent;
  s1C: string;
begin
  try
    Result := False;
    s1C := '';
    //Event:=TEvent(m_PEnvir.GetEvent(nX,nY));
    //if (Event <> nil) and (Event.m_nEventType = ET_MINE) then begin
    //if TStoneMineEvent(Event).m_nMineCount > 0 then begin
      //Dec(TStoneMineEvent(Event).m_nMineCount);
    if Random(g_Config.nMakeMineHitRate {4}) = 0 then
    begin
      PileEvent := TEvent(m_PEnvir.GetEvent(m_nCurrX, m_nCurrY));
      if PileEvent = nil then
      begin //004CB71D
        PileEvent := TPileStones.Create(m_PEnvir, m_nCurrX, m_nCurrY,
          ET_PILESTONES, 5 * 60 * 1000);
        g_EventManager.AddEvent(PileEvent);
      end
      else
      begin
        if PileEvent.m_nEventType = ET_PILESTONES then
          TPileStones(PileEvent).AddEventParam;
      end;
      if Random(g_Config.nMakeMineRate {12}) = 0 then
      begin
        if m_PEnvir.Flag.boMINE then
          MakeMine()
        else if m_PEnvir.Flag.boMINE2 then
          MakeMine2();
      end;
      s1C := '1';
      DoDamageWeapon(Random(15) + 5);
      Result := True;
    end; //004CB79C
    //end else begin  //004CB782
    //  if (GetTickCount - TStoneMineEvent(Event).m_dwAddStoneMineTick) >10 * 60 * 1000 then
    //    TStoneMineEvent(Event).AddStoneMine();
    //end;
    //end; //004CB79C
    SendRefMsg(RM_HEAVYHIT, m_btDirection, m_nCurrX, m_nCurrY, 0, s1C);
  except
    MainOutMessage('[Exception] TPlayObject.PileStones');
  end;
end;

//004C914C

procedure TBaseObject.SetTargetCreat(BaseObject: TBaseObject);
begin
  try
    m_TargetCret := BaseObject;
    m_dwTargetFocusTick := GetTickCount();
  except
    MainOutMessage('[Exception] TBaseObject.SetTargetCreat');
  end;
end;

procedure TBaseObject.DelTargetCreat(); //004C9178
begin
  try
    m_TargetCret := nil;
  except
    MainOutMessage('[Exception] TBaseObject.DelTargetCreat');
  end;
end;

procedure TBaseObject.RecallSlave(sSlaveName: string); //召唤宝宝
var
  i, nX, nY, nFlag: Integer;
begin
  try
    nFlag := -1;
    GetFrontPosition(nX, nY);

    if sSlaveName = g_Config.sDragon then
      nFlag := 1;

    for i := m_SlaveList.Count - 1 downto 0 do
    begin
      if nFlag = 1 then
      begin
        if ((TBaseObject(m_SlaveList.Items[i]).m_sCharName = g_Config.sDragon)
          or
          (TBaseObject(m_SlaveList.Items[i]).m_sCharName = g_Config.sDragon1))
            then
        begin
          TBaseObject(m_SlaveList.Items[i]).SpaceMove(m_PEnvir.sMapName, nX, nY,
            1);
          Break;
        end;
      end
      else if (TBaseObject(m_SlaveList.Items[i]).m_sCharName = sSlaveName) then
      begin
        TBaseObject(m_SlaveList.Items[i]).SpaceMove(m_PEnvir.sMapName, nX, nY,
          1);
        Break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.RecallSlave');
  end;
end;

function TBaseObject._Attack(var wHitMode: Word; AttackTarget: TBaseObject):
  Boolean; //004C1EF4
var
  nPower, nSecPwr, nWeaponDamage: Integer;
  bo21: Boolean;
  n20: Integer;
  nCheckCode: Integer;
  m_db3B0: Double; //0x3B0
  boAttact: Boolean;
  //攻击角色
  function DirectAttack(BaseObject: TBaseObject; nSecPwr: Integer): Boolean;
    //004C1B04
  begin
    Result := False;
    if (m_btRaceServer = RC_PLAYOBJECT) or
      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
      not (InSafeZone and BaseObject.InSafeZone) then
    begin
      if IsProperTarget(BaseObject) then
      begin
        if Random(BaseObject.m_btSpeedPoint) < m_btHitPoint then
        begin
          BaseObject.StruckDamage(nSecPwr, self);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK),
            RM_10101,
            nSecPwr,
            BaseObject.m_WAbil.HP,
            BaseObject.m_WAbil.MaxHP,
            Integer(Self),
            '', 500);
          if BaseObject.m_btRaceServer <> RC_PLAYOBJECT then
          begin
            BaseObject.SendMsg(BaseObject,
              RM_STRUCK,
              nSecPwr,
              BaseObject.m_WAbil.HP,
              BaseObject.m_WAbil.MaxHP,
              Integer(Self),
              '');
          end;
          Result := True;
        end;
      end;
    end;

  end;
  //刺杀前面一个位置的攻击
  function SwordLongAttack(nSecPwr: Integer): Boolean; //004C1C24
  var
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    //Result:=g_boNotLimitSwordLong;
    nSecPwr := ROUND(nSecPwr * g_Config.nSwordLongPowerRate / 100);
    if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, 2, nX, nY)
      then
    begin
      BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
      if BaseObject <> nil then
      begin
        if (nSecPwr > 0) and IsProperTarget(BaseObject) then
        begin
          if g_Config.boShieldErgum then
            BaseObject.ChangeShieldMode(True);
          DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
          boAttact := True;
          //Result:=True;
          //AttackTarget:=BaseObject;
        end;
        Result := True;
      end;
    end;
  end;

  function LongSwordAttack(nSecPwr: Integer): Boolean; //004C1C24
  var
    nX, nY: Integer;
    BaseObject: TBaseObject;
    n10: integer;
  begin
    Result := False;
    n10 := 2;
    while (True) do
    begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, n10, nX, nY)
        then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if BaseObject <> nil then
        begin
          if (nSecPwr > 0) and IsProperTarget(BaseObject) then
          begin
            if g_Config.boShieldLong then
              BaseObject.ChangeShieldMode(True);
            DirectAttack(BaseObject, nSecPwr);
            SetTargetCreat(BaseObject);
            boAttact := True;
            //AttackTarget:=BaseObject;
          end;
          Result := True;
        end;
      end;
      Inc(n10);
      if n10 > 4 then
        break;
      if (n10 > 2) and (not m_boLongSwordSkillCls) then
        break;
    end;
  end;

  function TwinSkillAttack(nSecPwr: Integer): Boolean; //狂风斩
  var
    I, nC, n10, nX, nY, AttackX, AttackY: integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    for I := 1 to g_Config.nTwinHitSkillRange do
    begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, m_btDirection, I, AttackX,
        AttackY) then
      begin
        nC := 0;
        while (True) do
        begin
          //if (i<>1) and (nc<>1) then begin
          n10 := (m_btDirection + g_Config.TwinAttack[nC]) mod 8;
          if m_PEnvir.GetNextPosition(AttackX, AttackY, n10, 1, nX, nY) then
          begin
            BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
            if (nSecPwr > 0) and (BaseObject <> nil) and
              IsProperTarget(BaseObject) then
            begin
              Result := DirectAttack(BaseObject, nSecPwr);
              SetTargetCreat(BaseObject);
            end;
          end;
          //end;
          Inc(nC);
          if nC >= 3 then
            break;
        end;
      end;
    end;
  end;
  //半月攻击
  function SwordWideAttack(nSecPwr: Integer): Boolean; //004C1CDC
  var
    nC, n10: Integer;
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    nC := 0;
    while (True) do
    begin
      n10 := (m_btDirection + g_Config.WideAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject)
          then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
      Inc(nC);
      if nC >= 3 then
        break;
    end;
  end;

  function CrsWideAttack(nSecPwr: Integer): Boolean;
  var
    nC, n10: Integer;
    nX, nY: Integer;
    BaseObject: TBaseObject;
  begin
    Result := False;
    nC := 0;
    while (True) do
    begin
      n10 := (m_btDirection + g_Config.CrsAttack[nC]) mod 8;
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, n10, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) and IsProperTarget(BaseObject)
          then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
          SetTargetCreat(BaseObject);
        end;
      end;
      Inc(nC);
      if nC >= 6 then
        break;
    end;
  end;

  procedure sub_4C1E5C(nSecPwr: Integer); //004C1E5C
  var
    btDir: Byte;
    nX, nY: Integer;
    BaseObject: TBaseObject;
    procedure sub_4C1DC0();
    begin
      if m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY) then
      begin
        BaseObject := m_PEnvir.GetMovingObject(nX, nY, True);
        if (nSecPwr > 0) and (BaseObject <> nil) then
        begin
          Result := DirectAttack(BaseObject, nSecPwr);
        end;
      end;
    end;
  begin
    Result := False;
    btDir := m_btDirection;
    m_PEnvir.GetNextPosition(m_nCurrX, m_nCurrY, btDir, 1, nX, nY);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 2);
    sub_4C1DC0();
    btDir := sub_4B2F80(m_btDirection, 6);
    sub_4C1DC0();
  end;

resourcestring
  sExceptionMsg = '[Exception] TBaseObject::_Attack Name:= %s Code:=%d';
begin
  try
    Result := False;
    nCheckCode := 0;
    try
      bo21 := False;
      nWeaponDamage := 0;
      boAttact := False;
      //  nPower:=0;
      //  nSecPwr:=0;
      if AttackTarget <> nil then
      begin
        nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC)
          - LoWord(m_WAbil.DC))));
        if (wHitMode = 3) and m_boPowerHit then
        begin
          m_boPowerHit := False;
          Inc(nPower, m_nHitPlus);
          bo21 := True;
        end;
        if (wHitMode = 7) and m_boFireHitSkill then
        begin //烈火剑法
          m_boFireHitSkill := False;
          m_dwLatestFireHitTick := GetTickCount(); //Jacky 禁止双烈火
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          bo21 := True;
        end;
        if (wHitMode = 13) and m_boLongFireHitSkill then
        begin //烈火剑法
          m_boLongFireHitSkill := False;
          m_dwLatestLongFireHitTick := GetTickCount(); //Jacky 禁止双烈火
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          m_boLongSwordSkillCls := True;
          if nPower > 0 then
            LongSwordAttack(Trunc(nPower * (g_Config.nLongFireHitPower / 100)));
          bo21 := True;
        end;
        if (wHitMode = 9) and m_boTwinHitSkill then
        begin //烈火剑法
          m_boTwinHitSkill := False;
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            TPlayObject(self).nTwinHitSkillCount := 0;
            TPlayObject(self).SendDefMessage(SM_CHANGEDRAGON,
              g_Config.nTwinHitMaxCount,
              0,
              0,
              0,
              '');
          end;
          m_dwLatestTwinHitTick := GetTickCount(); //Jacky 禁止双烈火
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          if nPower > 0 then
            TwinSkillAttack(nPower);
        end;
        if (wHitMode in [10, 11]) and m_boLongSwordSkill then
        begin //烈火开天斩
          m_boLongSwordSkill := False;
          m_dwLatestLongSwordTick := GetTickCount(); //Jacky 禁止双开天斩
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          if nPower > 0 then
            LongSwordAttack(nPower);
        end;
      end
      else
      begin
        nPower := GetAttackPower(LoWord(m_WAbil.DC), SmallInt((HiWord(m_WAbil.DC)
          - LoWord(m_WAbil.DC))));
        if (wHitMode = 3) and m_boPowerHit then
        begin
          m_boPowerHit := False;
          Inc(nPower, m_nHitPlus);
          bo21 := True;
        end;
        //Jacky 防止砍空刀刀烈火
        if (wHitMode = 7) and m_boFireHitSkill then
        begin
          m_boFireHitSkill := False;
          m_dwLatestFireHitTick := GetTickCount(); //Jacky 禁止双烈火
        end;
        if (wHitMode = 13) and m_boLongFireHitSkill then
        begin //逐日剑法
          m_boLongFireHitSkill := False;
          m_dwLatestLongFireHitTick := GetTickCount(); //Jacky 逐日剑法
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          m_boLongSwordSkillCls := True;
          if nPower > 0 then
            LongSwordAttack(Trunc(nPower * (g_Config.nLongFireHitPower / 100)));
          bo21 := True;
        end;
        if (wHitMode = 9) and m_boTwinHitSkill then
        begin
          m_boTwinHitSkill := False;
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            TPlayObject(self).nTwinHitSkillCount := 0;
            TPlayObject(self).SendDefMessage(SM_CHANGEDRAGON,
              g_Config.nTwinHitMaxCount,
              0,
              0,
              0,
              '');
          end;
          m_dwLatestTwinHitTick := GetTickCount(); //Jacky 禁止双烈火
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          if nPower > 0 then
            TwinSkillAttack(nPower);
        end;
        if (wHitMode in [10, 11]) and m_boLongSwordSkill then
        begin //开天斩
          m_boLongSwordSkill := False;
          m_dwLatestLongSwordTick := GetTickCount(); //Jacky 禁止双开天斩
          nPower := nPower + ROUND(nPower / 100 * (m_nHitDouble * 10));
          if nPower > 0 then
            LongSwordAttack(nPower);
        end;
        //
      end;
      nCheckCode := 1;
      if (wHitMode = 4) then
      begin //004C205A 刺杀
        nSecPwr := 0;
        if m_btRaceServer in [RC_PLAYOBJECT,RC_PLAYCLONE] then
        begin
          nCheckCode := 11;
          if m_MagicErgumSkill <> nil then
          begin
            nCheckCode := 12;
            nSecPwr := ROUND(nPower / (m_MagicErgumSkill.MagicInfo.btTrainLv + 2)
              * (m_MagicErgumSkill.btLevel + 2));
            nCheckCode := 13;
          end;
        end
        else
          nSecPwr := nSecPwr;
        if nSecPwr > 0 then
        begin
          nCheckCode := 110;
          if not SwordLongAttack(nSecPwr) and g_Config.boLimitSwordLong then
            wHitMode := 0;
          nCheckCode := 111;
        end;
      end;
      nCheckCode := 2;
      if (wHitMode = 5) then
      begin
        nSecPwr := 0;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if m_MagicBanwolSkill <> nil then
          begin
            nSecPwr := ROUND(nPower / (m_MagicBanwolSkill.MagicInfo.btTrainLv +
              10) * (m_MagicBanwolSkill.btLevel + 2));
          end;
        end
        else
          nSecPwr := nSecPwr;
        if nSecPwr > 0 then
          SwordWideAttack(nSecPwr);
      end;
      if (wHitMode = 12) then
      begin
        nSecPwr := 0;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if m_MagicRedBanwolSkill <> nil then
          begin
            nSecPwr := ROUND(nPower / (m_MagicRedBanwolSkill.MagicInfo.btTrainLv
              + 10) * (m_MagicRedBanwolSkill.btLevel + 2));
          end;
        end
        else
          nSecPwr := nSecPwr;
        if nSecPwr > 0 then
          SwordWideAttack(nSecPwr);
      end;
      nCheckCode := 3;
      if (wHitMode = 6) then
      begin
        nSecPwr := 0;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
        end
        else
          nSecPwr := nSecPwr;
        if nSecPwr > 0 then
          sub_4C1E5C(nSecPwr);
      end;
      if (wHitMode = 8) then
      begin
        nSecPwr := 0;
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          if m_MagicCrsSkill <> nil then
          begin
            nSecPwr := ROUND(nPower / (m_MagicCrsSkill.MagicInfo.btTrainLv + 10)
              * (m_MagicCrsSkill.btLevel + 2));
          end;
        end
        else
          nSecPwr := nSecPwr;
        if nSecPwr > 0 then
          CrsWideAttack(nSecPwr);
      end;

      if (AttackTarget = nil) and (not boAttact) then
        exit; //004C218D

      nCheckCode := 4;
      if (AttackTarget <> nil) and IsProperTarget {0FFF4}(AttackTarget) then
      begin
        nCheckCode := 41;
        if AttackTarget.m_btHitPoint > 0 then
        begin
          if (m_btHitPoint < Random(AttackTarget.m_btSpeedPoint)) then
          begin
            nCheckCode := 42;
            nPower := 0;
          end;
        end;
        nCheckCode := 43;
      end
      else
        nPower := 0;
      nCheckCode := 5;
      if nPower > 0 then
      begin
        nPower := AttackTarget.GetHitStruckDamage(Self, nPower);
        nWeaponDamage := (Random(5) + 2) - m_AddAbil.btWeaponStrong;
      end;
      nCheckCode := 600;
      if (nPower > 0) or boAttact then
      begin //004C21FC
        if (nPower > 0) then
        begin
          if (wHitMode = 7) and g_Config.boShieldFire then
            AttackTarget.ChangeShieldMode(True);
          if (wHitMode = 3) and g_Config.boShieldYEDO then
            AttackTarget.ChangeShieldMode(True);
          nCheckCode := 601;
          AttackTarget.StruckDamage(nPower, self);
          nCheckCode := 602;
          AttackTarget.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nPower,
            AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self),
            '', 200);
          nCheckCode := 603;
          if not AttackTarget.m_boUnParalysis and m_boParalysis and
            (Random(AttackTarget.m_btAntiPoison + g_Config.nAttackPosionRate {5})
            = 0) then
          begin
            nCheckCode := 604;
            AttackTarget.MakePosion(POISON_STONE, g_Config.nAttackPosionTime
              {5}, 0);
          end;
          nCheckCode := 605;
          //虹魔，吸血
          if m_nHongMoSuite > 0 then
          begin
            m_db3B0 := nPower / 100 * m_nHongMoSuite;
            if m_db3B0 >= 2.0 then
            begin
              n20 := TRUNC(m_db3B0);
              //        m_db3B0:=n20;
              DamageHealth(-n20);
            end;
          end;
        end;
        nCheckCode := 606;
        if (m_MagicOneSwordSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicOneSwordSkill.btLevel < 3) and
          (m_MagicOneSwordSkill.MagicInfo.TrainLevel[m_MagicOneSwordSkill.btLevel] <= m_Abil.Level) then
        begin
          nCheckCode := 607;
          TPlayObject(Self).TrainSkill(m_MagicOneSwordSkill, Random(3) + 1);
          nCheckCode := 608;
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicOneSwordSkill) then
          begin
            nCheckCode := 609;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicOneSwordSkill.MagicInfo.wMagicId,
              m_MagicOneSwordSkill.btLevel, m_MagicOneSwordSkill.nTranPoint, '',
              3000);
          end;
          nCheckCode := 610;
        end;
        if bo21 and (m_MagicPowerHitSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicPowerHitSkill.btLevel < 3) and
          (m_MagicPowerHitSkill.MagicInfo.TrainLevel[m_MagicPowerHitSkill.btLevel] <= m_Abil.Level) then
        begin
          nCheckCode := 611;
          TPlayObject(Self).TrainSkill(m_MagicPowerHitSkill, Random(3) + 1);
          nCheckCode := 612;
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicPowerHitSkill) then
          begin
            nCheckCode := 613;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicPowerHitSkill.MagicInfo.wMagicId,
              m_MagicPowerHitSkill.btLevel, m_MagicPowerHitSkill.nTranPoint, '',
              3000);
          end;
          nCheckCode := 614;
        end;
        nCheckCode := 6;
        if (wHitMode = 4) and (m_MagicErgumSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicErgumSkill.btLevel < 3) and
          (m_MagicErgumSkill.MagicInfo.TrainLevel[m_MagicErgumSkill.btLevel] <=
          m_Abil.Level) then
        begin
          nCheckCode := 61;
          TPlayObject(Self).TrainSkill(m_MagicErgumSkill, 1);
          nCheckCode := 62;
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicErgumSkill) then
          begin
            nCheckCode := 63;
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicErgumSkill.MagicInfo.wMagicId, m_MagicErgumSkill.btLevel,
              m_MagicErgumSkill.nTranPoint, '', 3000);
          end;
        end;
        nCheckCode := 7;
        if (wHitMode = 5) and (m_MagicBanwolSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicBanwolSkill.btLevel < 3) and
          (m_MagicBanwolSkill.MagicInfo.TrainLevel[m_MagicBanwolSkill.btLevel]
          <= m_Abil.Level) then
        begin

          TPlayObject(Self).TrainSkill(m_MagicBanwolSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicBanwolSkill) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicBanwolSkill.MagicInfo.wMagicId, m_MagicBanwolSkill.btLevel,
              m_MagicBanwolSkill.nTranPoint, '', 3000);
          end;
        end;
        if (wHitMode = 12) and (m_MagicRedBanwolSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicRedBanwolSkill.btLevel < 3) and
          (m_MagicRedBanwolSkill.MagicInfo.TrainLevel[m_MagicRedBanwolSkill.btLevel] <= m_Abil.Level) then
        begin

          TPlayObject(Self).TrainSkill(m_MagicRedBanwolSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicRedBanwolSkill) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicRedBanwolSkill.MagicInfo.wMagicId,
              m_MagicRedBanwolSkill.btLevel, m_MagicRedBanwolSkill.nTranPoint,
              '',
              3000);
          end;
        end;
        nCheckCode := 8;
        if (wHitMode = 7) and (m_MagicFireSwordSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicFireSwordSkill.btLevel < 3) and
          (m_MagicFireSwordSkill.MagicInfo.TrainLevel[m_MagicFireSwordSkill.btLevel] <= m_Abil.Level) then
        begin

          TPlayObject(Self).TrainSkill(m_MagicFireSwordSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicFireSwordSkill) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicFireSwordSkill.MagicInfo.wMagicId,
              m_MagicFireSwordSkill.btLevel, m_MagicFireSwordSkill.nTranPoint,
              '',
              3000);
          end;
        end;

        if (wHitMode = 8) and (m_MagicCrsSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicCrsSkill.btLevel < 3) and
          (m_MagicCrsSkill.MagicInfo.TrainLevel[m_MagicCrsSkill.btLevel] <=
          m_Abil.Level) then
        begin

          TPlayObject(Self).TrainSkill(m_MagicCrsSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicCrsSkill) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicCrsSkill.MagicInfo.wMagicId, m_MagicCrsSkill.btLevel,
              m_MagicCrsSkill.nTranPoint, '', 3000);
          end;
        end;

        if (wHitMode = 9) and (m_MagicTwnHitSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicTwnHitSkill.btLevel < 3) and
          (m_MagicTwnHitSkill.MagicInfo.TrainLevel[m_MagicTwnHitSkill.btLevel]
          <= m_Abil.Level) then
        begin

          TPlayObject(Self).TrainSkill(m_MagicTwnHitSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicTwnHitSkill) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicTwnHitSkill.MagicInfo.wMagicId, m_MagicTwnHitSkill.btLevel,
              m_MagicTwnHitSkill.nTranPoint, '', 3000);
          end;
        end;

        if (wHitMode in [10, 11]) and (m_MagicLongSwordSkill <> nil) and
          (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicLongSwordSkill.btLevel < 3) and
          (m_MagicLongSwordSkill.MagicInfo.TrainLevel[m_MagicLongSwordSkill.btLevel] <= m_Abil.Level) then
        begin

          TPlayObject(Self).TrainSkill(m_MagicLongSwordSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicLongSwordSkill) then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicLongSwordSkill.MagicInfo.wMagicId,
              m_MagicLongSwordSkill.btLevel, m_MagicLongSwordSkill.nTranPoint,
              '',
              3000);
          end;
        end;

        if (wHitMode = 13) and (m_MagicLongFireSwordSkill <> nil) and
          //烈火剑法
        (m_btRaceServer = RC_PLAYOBJECT) and
          (m_MagicLongFireSwordSkill.btLevel < 3) and
          (m_MagicLongFireSwordSkill.MagicInfo.TrainLevel[m_MagicLongFireSwordSkill.btLevel] <= m_Abil.Level) then
        begin
          TPlayObject(Self).TrainSkill(m_MagicLongFireSwordSkill, 1);
          if not TPlayObject(Self).CheckMagicLevelup(m_MagicLongFireSwordSkill)
            then
          begin
            SendDelayMsg(Self, RM_MAGIC_LVEXP, 0,
              m_MagicLongFireSwordSkill.MagicInfo.wMagicId,
              m_MagicLongFireSwordSkill.btLevel,
              m_MagicLongFireSwordSkill.nTranPoint, '', 3000);
          end;
        end;

        Result := True;
      end; //004C270C
      nCheckCode := 9;
      if (nWeaponDamage > 0) and (m_UseItems[U_WEAPON].wIndex > 0) then
        DoDamageWeapon(nWeaponDamage);
      if (AttackTarget <> nil) and (AttackTarget.m_btRaceServer <> RC_PLAYOBJECT)
        then
        AttackTarget.SendMsg(AttackTarget, RM_STRUCK, nPower,
          AttackTarget.m_WAbil.HP, AttackTarget.m_WAbil.MaxHP, Integer(Self),
          '');
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg, [m_sCharName, nCheckCode]));
        MainOutMessage(E.Message);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject._Attack');
  end;
end;

procedure TBaseObject.SendAttackMsg(wIdent: Word; btDir: Byte; nX, nY: Integer);
//004C2E0C
begin
  try
    SendRefMsg(wIdent, btDir, nX, nY, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.SendAttackMsg');
  end;
end;

function TBaseObject.GetHitStruckDamage(Target: TBaseObject; nDamage: integer):
  Integer; //004BDD20
var
  nArmor, nRnd: Integer;
begin
  try
    nRnd := ((HiWord(m_WAbil.AC) - LoWord(m_WAbil.AC)) + 1);
    if (nRnd > 0) then
      nArmor := LoWord(m_WAbil.AC) + (Random(nRnd))
    else
      nArmor := LoWord(m_WAbil.AC);

    nDamage := _MAX(0, nDamage - nArmor);

    if (nDamage > 0) then
    begin
      if (m_btLifeAttrib = LA_UNDEAD) and (Target <> nil) then
      begin
        Inc(nDamage, Target.m_AddAbil.btUndead);
      end;
      if m_boAbilMagBubbleDefence then
      begin
        nDamage := ROUND((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) *
          8.0);
        DamageBubbleDefence(nDamage);
      end;
    end;
    Result := nDamage;
  except
    MainOutMessage('[Exception] TBaseObject.GetHitStruckDamage');
  end;
end;

function TBaseObject.GetMagStruckDamage(BaseObject: TBaseObject; nDamage:
  Integer): Integer; //004BDDEC
var
  nRnd,nArmor: Integer;
begin
  try
 ////////////////////////////////////////////////////////////////
    nRnd := ((HiWord(m_WAbil.MAC)-LoWord(m_WAbil.MAC)) + 1);
    if (nRnd > 0) then
      nArmor := LoWord(m_WAbil.MAC) + (Random(nRnd))
    else
      nArmor := LoWord(m_WAbil.MAC);

    nDamage := _MAX(0, nDamage - nArmor);
  // zmfu 0809 修复魔御上限超过下限出现秒杀

    if (m_btLifeAttrib = LA_UNDEAD) and (BaseObject <> nil) then
    begin
      Inc(nDamage, m_AddAbil.btUndead);
    end;
    if (nDamage > 0) and m_boAbilMagBubbleDefence then
    begin
      nDamage := ROUND((nDamage / 1.0E2) * (m_btMagBubbleDefenceLevel + 2) *8.0);
      DamageBubbleDefence(nDamage);
    end;

    Result := nDamage;
  except
    MainOutMessage('[Exception] TBaseObject.GetMagStruckDamage');
  end;
end;

//004BDEB8
//伤害
procedure TBaseObject.StruckDamage(var nDamage: integer; AttackBase:
  TBaseObject);
var
  I: Integer;
  nDam,nTdamage: Integer;
  nDura, nOldDura: integer;
  PlayObject: TPlayObject;
  StdItem: TItem;
  bo19: Boolean;
begin
  try
    nTdamage:=0;
    if nDamage <= 0 then
      exit;
    m_boDiploid := False;
    if (AttackBase <> nil) and
      (AttackBase.m_btRaceServer = RC_PLAYOBJECT) and
      (not AttackBase.m_boHero) and
      (AttackBase.m_btDiploidRate3 > 0) and
      ((Random(200) - AttackBase.m_btDiploidRate3) < 0) then
    begin
      nDamage := nDamage * 2;
      m_boDiploid := True;
    end;
    if (AttackBase <> nil) and
      (m_wStatusTimeArr[STATE_MAGIC57] > 0)and
      ((Self.m_HeroMagic[57]<>nil) or (Self.m_HeroMagic[81]<>nil)) then
    begin
      nTdamage:=Round(nDamage * (g_Config.nSkill57DecDamage/100));//四级魔法盾总伤害减少10%
      if nTdamage<1 then nTdamage:=1;
      nDamage := nDamage-nTdamage;
    end;

    if (AttackBase <> nil) and
      (AttackBase.m_btRaceServer = RC_PLAYOBJECT) then
    begin
      PlayObject := TPlayObject(AttackBase);
      if PlayObject.m_nAttact < 100 then
        Inc(PlayObject.m_nAttact);
    end;
    if m_boOpenShield and
      (m_MagicShieldSkill <> nil) then
    begin
      if Random(m_MagicShieldSkill.btLevel + g_Config.nShieldSmashRate) <> 0
        then
      begin
        nDamage := ROUND((Random(g_Config.nShieldAttackRate) +
          g_Config.nShieldAttackRate) / 100 * nDamage);
        if (GetTickCount - m_dwOpenShieldShowTime) > 1000 then
        begin
          m_dwOpenShieldShowTime := GetTickCount;
          if g_Config.boShieldAttackEff > 0 then
            SendRefMsg(RM_SHOWEFFECT, Effect_86 + g_Config.boShieldAttackEff,
              Integer(Self), m_nCurrX, m_nCurrY, '');
        end;
      end
      else
        ChangeShieldMode(True);
    end;
    nDam := Random(10) + 5;
    if m_wStatusTimeArr[POISON_DAMAGEARMOR {1 0x62}] > 0 then
    begin
      nDam := ROUND(nDam * (g_Config.nPosionDamagarmor / 10) {1.2});
      nDamage := ROUND(nDamage * (g_Config.nPosionDamagarmor / 10) {1.2});
    end;

    bo19 := False;
    if m_UseItems[U_DRESS].wIndex > 0 then
    begin
      nDura := m_UseItems[U_DRESS].Dura;
      nOldDura := ROUND(nDura / 1000);
      Dec(nDura, nDam);
      if nDura <= 0 then
      begin
        if m_btRaceServer = RC_PLAYOBJECT then
        begin
          PlayObject := TPlayObject(Self);
          PlayObject.SendDelItems(@m_UseItems[U_DRESS]);
          StdItem := UserEngine.GetStdItem(m_UseItems[U_DRESS].wIndex);
          //004BE088
          if StdItem.NeedIdentify = 1 then
            AddGameDataLog('3' + #9 +
              m_sMapName + #9 +
              IntToStr(m_nCurrX) + #9 +
              IntToStr(m_nCurrY) + #9 +
              m_sCharName + #9 +
              //UserEngine.GetStdItemName(m_UseItems[U_DRESS].wIndex) + #9 +
              StdItem.Name + #9 +
              IntToStr(m_UseItems[U_DRESS].MakeIndex) + #9 +
              BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
              '0');
          m_UseItems[U_DRESS].wIndex := 0;
          FeatureChanged();
        end;
        m_UseItems[U_DRESS].wIndex := 0;
        m_UseItems[U_DRESS].Dura := 0;
        bo19 := True;
      end
      else
      begin
        m_UseItems[U_DRESS].Dura := nDura;
      end;
      if nOldDura <> ROUND(nDura / 1000) then
      begin
        SendMsg(Self, RM_DURACHANGE, U_DRESS, nDura,
          m_UseItems[U_DRESS].DuraMax, 0, '');
      end;
    end;
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if (m_UseItems[i].wIndex > 0) and (Random(8) = 0) then
      begin
        nDura := m_UseItems[i].Dura;
        nOldDura := ROUND(nDura / 1000);
        Dec(nDura, nDam);
        if nDura <= 0 then
        begin
          if m_btRaceServer = RC_PLAYOBJECT then
          begin
            PlayObject := TPlayObject(Self);
            PlayObject.SendDelItems(@m_UseItems[i]);
            StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
            //004BE2B8
            if StdItem.NeedIdentify = 1 then
              AddGameDataLog('3' + #9 +
                m_sMapName + #9 +
                IntToStr(m_nCurrX) + #9 +
                IntToStr(m_nCurrY) + #9 +
                m_sCharName + #9 +
                //UserEngine.GetStdItemName(m_UseItems[i].wIndex) + #9 +
                StdItem.Name + #9 +
                IntToStr(m_UseItems[i].MakeIndex) + #9 +
                BoolToIntStr(m_btRaceServer = RC_PLAYOBJECT) + #9 +
                '0');
            m_UseItems[i].wIndex := 0;
            FeatureChanged();
          end;
          m_UseItems[i].wIndex := 0;
          m_UseItems[i].Dura := 0;
          bo19 := True;
        end
        else
        begin
          m_UseItems[i].Dura := nDura;
        end;
        if nOldDura <> ROUND(nDura / 1000) then
        begin
          SendMsg(Self, RM_DURACHANGE, i, nDura, m_UseItems[i].DuraMax, 0, '');
        end;
      end;
    end;
 //处理吸取伤害装备
 if m_btRaceServer = RC_PLAYOBJECT then
  begin
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if (m_UseItems[i].wIndex > 0) then
      begin
         StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
         if StdItem.Shape=188 then
           nTdamage:=nTdamage+StdItem.Source;
      end;
    end;
  end;
  if nTdamage>100 then nTdamage:=100;
  if nTdamage>0 then
  begin
     nTdamage:=Round(nDamage * (nTdamage/100));//吸取伤害装备
     if nTdamage<1 then nTdamage:=1;
     nDamage :=nDamage-nTdamage;
  end;
 /////////////////////////////
    if bo19 then
      RecalcAbilitys();
    DamageHealth(nDamage);
  except
    MainOutMessage('[Exception] TBaseObject.StruckDamage');
  end;
end;

function TBaseObject.GeTBaseObjectInfo(): string; //004CF87C
begin
  try
    Result := m_sCharName + ' ' +
      '地图:' + m_sMapName + '(' + m_PEnvir.sMapDesc + ') ' +
      '座标:' + IntToStr(m_nCurrX) + '/' + IntToStr(m_nCurrY) + ' ' +
      '等级:' + IntToStr(m_Abil.Level) + ' ' +
      '经验:' + IntToStr(m_Abil.Exp) + ' ' +
      '生命值: ' + IntToStr(m_WAbil.HP) + '-' + IntToStr(m_WAbil.MaxHP) + ' '
      +
      '魔法值: ' + IntToStr(m_WAbil.MP) + '-' + IntToStr(m_WAbil.MaxMP) + ' '
      +
      '攻击力: ' + IntToStr(LoWord(m_WAbil.DC)) + '-' +
      IntToStr(HiWord(m_WAbil.DC)) + ' ' +
      '魔法力: ' + IntToStr(LoWord(m_WAbil.MC)) + '-' +
      IntToStr(HiWord(m_WAbil.MC)) + ' ' +
      '道术: ' + IntToStr(LoWord(m_WAbil.SC)) + '-' +
      IntToStr(HiWord(m_WAbil.SC)) + ' ' +
      '防御力: ' + IntToStr(LoWord(m_WAbil.AC)) + '-' +
      IntToStr(HiWord(m_WAbil.AC)) + ' ' +
      '魔防力: ' + IntToStr(LoWord(m_WAbil.MAC)) + '-' +
      IntToStr(HiWord(m_WAbil.MAC)) + ' ' +
      '准确:' + IntToStr(m_btHitPoint) + ' ' +
      '敏捷:' + IntToStr(m_btSpeedPoint);
  except
    MainOutMessage('[Exception] TBaseObject.GeTBaseObjectInfo');
  end;
end;

function TBaseObject.GetBackPosition(var nX, nY: Integer): Boolean; //004B2900
var
  Envir: TEnvirnoment;
begin
  try
    Envir := m_PEnvir;
    nX := m_nCurrX;
    nY := m_nCurrY;
    case m_btDirection of
      DR_UP: if nY < (Envir.Header.wHeight - 1) then
          Inc(nY);
      DR_DOWN: if nY > 0 then
          Dec(nY);
      DR_LEFT: if nX < (Envir.Header.wWidth - 1) then
          Inc(nX);
      DR_RIGHT: if nX > 0 then
          Dec(nX);
      DR_UPLEFT:
        begin
          if (nX < (Envir.Header.wWidth - 1)) and (nY < (Envir.Header.wHeight -
            1)) then
          begin
            Inc(nX);
            Inc(nY);
          end;
        end;
      DR_UPRIGHT:
        begin
          if (nX < (Envir.Header.wWidth - 1)) and (nY > 0) then
          begin
            Dec(nX);
            Inc(nY);
          end
        end;
      DR_DOWNLEFT:
        begin
          if (nX > 0) and (nY < (Envir.Header.wHeight - 1)) then
          begin
            Inc(nX);
            Dec(nY);
          end;
        end;
      DR_DOWNRIGHT:
        begin
          if (nX > 0) and (nY > 0) then
          begin
            Dec(nX);
            Dec(nY);
          end;
        end;
    end;
    Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.GetBackPosition');
  end;
end;

procedure TAnimalObject.HitMagAttackTarget(TargeTBaseObject: TBaseObject;
  nHitPower,
  nMagPower: integer; boFlag: Boolean); //004C2E40
var
  I: Integer;
  nDamage: Integer;
  BaseObjectList: TList;
  BaseObject: TBaseObject;
begin
  try
    m_btDirection := GetNextDirection(m_nCurrx, m_nCurrY,
      TargeTBaseObject.m_nCurrX, TargeTBaseObject.m_nCurrY);
    BaseObjectList := TList.Create;
    m_PEnvir.GeTBaseObjects(TargeTBaseObject.m_nCurrX,
      TargeTBaseObject.m_nCurrY, False, BaseObjectList);
    for I := 0 to BaseObjectList.Count - 1 do
    begin
      BaseObject := TBaseObject(BaseObjectList.Items[I]);
      if IsProperTarget(BaseObject) then
      begin
        nDamage := 0;
        Inc(nDamage, BaseObject.GetHitStruckDamage(Self, nHitPower));
        Inc(nDamage, BaseObject.GetMagStruckDamage(Self, nMagPower));
        if nDamage > 0 then
        begin
          BaseObject.StruckDamage(nDamage, self);
          BaseObject.SendDelayMsg(TBaseObject(RM_STRUCK), RM_10101, nDamage,
            BaseObject.m_WAbil.HP, BaseObject.m_WAbil.MaxHP, Integer(Self), '',
            200);
        end;
      end;
    end;
    BaseObjectList.Free;
    SendRefMsg(RM_HIT, m_btDirection, m_nCurrX, m_nCurrY, 0, '');
  except
    MainOutMessage('[Exception] TAnimalObject.HitMagAttackTarget');
  end;
end;

procedure TAnimalObject.DelTargetCreat;
begin
  try
    inherited;
    m_nTargetX := -1;
    m_nTargetY := -1;
  except
    MainOutMessage('[Exception] TAnimalObject.DelTargetCreat');
  end;
end;

//寻找攻击对像

procedure TAnimalObject.SearchTarget; //004C94B4
var
  BaseObject, BaseObject18: TBaseObject;
  i: integer;
  nCheck: Integer;
  nRage: Integer;
begin
  try
    BaseObject18 := nil;
    //  n10:=999;
    nCheck := 999;
    try
      for i := m_VisibleActors.Count - 1 downto 0 do
      begin
        BaseObject := pTVisibleBaseObject(m_VisibleActors.Items[i]).BaseObject;
        if ((not BaseObject.m_boHideMode) or m_boCoolEye) and
          //不是隐身的或者可以看见隐身的
        (not BaseObject.m_boDeath) and
          (m_PEnvir = BaseObject.m_PEnvir) and
          IsProperTarget(BaseObject) then
        begin
          nRage := (abs(m_nCurrX - BaseObject.m_nCurrX)) + (abs(m_nCurrY -
            BaseObject.m_nCurrY));
          if nRage < nCheck then
          begin
            BaseObject18 := BaseObject;
            nCheck := nRage;
          end;
          if nCheck = 1 then
            break;
          //break;
        end;
      end;
      if BaseObject18 <> nil then
        SetTargetCreat(BaseObject18);
    except
      MainOutMessage('[Exception] TAnimalObject.SearchTarget');
    end;
  except
    MainOutMessage('[Exception] TAnimalObject.SearchTarget');
  end;
end;

procedure TAnimalObject.sub_4C959C; //004C959C
var
  I, nC, n10: integer;
  Creat, BaseObject: TBaseObject;
begin
  try
    Creat := nil;
    n10 := 999;
    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      BaseObject := pTVisibleBaseObject(m_VisibleActors.Items[I]).BaseObject;
      if BaseObject.m_boDeath then
        Continue;
      if IsProperTarget(BaseObject) then
      begin
        nC := abs(m_nCurrX - BaseObject.m_nCurrX) + abs(m_nCurrY -
          BaseObject.m_nCurrY);
        if nC < n10 then
        begin
          n10 := nC;
          Creat := BaseObject;
        end;
      end;
    end; // for
    if Creat <> nil then
      SetTargetCreat(Creat);
  except
    MainOutMessage('[Exception] TAnimalObject.sub_4C959C');
  end;
end;

procedure TAnimalObject.SetTargetXY(nX, nY: Integer); //004C9668
begin
  try
    m_nTargetX := nX;
    m_nTargetY := nY;
  except
    MainOutMessage('[Exception] TAnimalObject.SetTargetXY');
  end;
end;

procedure TAnimalObject.Wondering; //004C9810
begin
  try
    if (Random(20) = 0) then
      if (Random(4) = 1) then
        TurnTo(Random(8))
      else
        WalkTo(m_btDirection, False);
  except
    MainOutMessage('[Exception] TAnimalObject.Wondering');
  end;
end;

function TBaseObject.MakePosion(nType, nTime, nPoint: Integer): Boolean;
//004C35A8
var
  nOldCharStatus: Integer;
begin
  try
    Result := False;
    if nType < MAX_STATUS_ATTRIBUTE then
    begin
      nOldCharStatus := m_nCharStatus;
      if m_wStatusTimeArr[nType] > 0 then
      begin
        if m_wStatusTimeArr[nType] < nTime then
        begin
          m_wStatusTimeArr[nType] := nTime;
        end;
      end
      else
      begin //004C35FF
        m_wStatusTimeArr[nType] := nTime;
      end;
      m_dwStatusArrTick[nType] := GetTickCount();
      m_nCharStatus := GetCharStatus();
      m_btGreenPoisoningPoint := nPoint;
      if nOldCharStatus <> m_nCharStatus then
        StatusChanged();
      if m_btRaceServer = RC_PLAYOBJECT then
        SysMsg(format(sYouPoisoned, [nTime, nPoint]), c_Red, t_Hint);

      Result := True;
    end; //004C366C

  except
    MainOutMessage('[Exception] TBaseObject.MakePosion');
  end;
end;

function TBaseObject.sub_4DD704: Boolean; //004DD704
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := False;
    EnterCriticalSection(ProcessMsgCriticalSection);
    try
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if SendMessage.wIdent = RM_10401 then
        begin
          Result := True;
          break;
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.sub_4DD704:');
  end;
end;

procedure TPlayObject.SendSaveItemList(nBaseObject: Integer); //004DC120
var
  i, X: Integer;
  sSendMsg: string;
  UserItem: PTUserItem;
begin
  try
    sSendMsg := '';
    for I := 0 to m_StorageItemList.Count - 1 do
    begin
      if i > 50 then
        Break;
      UserItem := m_StorageItemList.Items[i];
      sSendMsg := sSendMsg + MakeClientItem(UserItem) + '/';
    end;
    m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 0, 0,
      m_StorageItemList.Count);
    SendSocket(@m_DefMsg, sSendMsg);
    I := 51;
    if (m_StorageItemList.Count > I) and (m_dwClientTickEx > 20070927) then
    begin
      sSendMsg := '';
      X := 0;
      while (m_StorageItemList.Count > I) do
      begin
        Inc(X);
        UserItem := m_StorageItemList.Items[i];
        sSendMsg := sSendMsg + MakeClientItem(UserItem) + '/';
        if X > 50 then
        begin
          m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 1, 0, X);
          SendSocket(@m_DefMsg, sSendMsg);
          sSendMsg := '';
          X := 0;
        end;
        Inc(I);
      end;
      if sSendMsg <> '' then
      begin
        m_DefMsg := MakeDefaultMsg(SM_SAVEITEMLIST, nBaseObject, 1, 0, X);
        SendSocket(@m_DefMsg, sSendMsg);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendSaveItemList');
  end;
end;

procedure TPlayObject.SendChangeGuildName; //004DE5A4
begin
  try
    if m_MyGuild <> nil then
    begin
      SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, TGuild(m_MyGuild).sGuildName
        + '/' + m_sGuildRankName);
    end
    else
    begin
      SendDefMessage(SM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendChangeGuildName');
  end;
end;

procedure TPlayObject.SendDelItemList(ItemList: TStringList); //004D0DAC
var
  I: Integer;
  s10: string;
begin
  try
    s10 := '';
    for I := 0 to ItemList.Count - 1 do
    begin
      s10 := s10 + ItemList.Strings[i] + '/' +
        IntToStr(Integer(ItemList.Objects[i])) + '/';
    end;
    m_DefMsg := MakeDefaultMsg(SM_DELITEMS, 0, 0, 0, ItemList.Count);
    SendSocket(@m_DefMsg, EncodeString(s10));
  except
    MainOutMessage('[Exception] TPlayObject.SendDelItemList');
  end;
end;

procedure TPlayObject.SendDelItems(UserItem: pTUserItem); //004D0BDC
begin
  try
    if m_boHero then
    begin
      m_DefMsg := MakeDefaultMsg(SM_906, Integer(Self), 0, 0, 1);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, MakeClientItem(UserItem));
    end
    else
    begin
      m_DefMsg := MakeDefaultMsg(SM_DELITEM, Integer(Self), 0, 0, 1);
      SendSocket(@m_DefMsg, MakeClientItemex(UserItem));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendDelItems');
  end;
end;

procedure TPlayObject.SendUpdateItem(UserItem: pTUserItem); //004D0A10
begin
  try
    m_DefMsg := MakeDefaultMsg(SM_UPDATEITEM, Integer(Self), 0, 0, 1);
    SendSocket(@m_DefMsg, MakeClientItem(UserItem));
  except
    MainOutMessage('[Exception] TPlayObject.SendUpdateItem');
  end;
end;

function TPlayObject.CheckTakeOnItems(nWhere: Integer; var StdItem: TStdItem):
  Boolean; //004C5084
var
  Castle: TUserCastle;
begin
  try
    Result := False;
    if (StdItem.StdMode = 10) and (m_btGender <> gMan) then
    begin
      SysMsg(sWearNotOfWoMan, c_Red, t_Hint);
      exit;
    end;
    if (StdItem.StdMode = 11) and (m_btGender <> gWoMan) then
    begin
      SysMsg(sWearNotOfMan, c_Red, t_Hint);
      exit;
    end;
    if (nWhere = 1) or (nWhere = 2) then
    begin
      if StdItem.Weight > m_WAbil.MaxHandWeight then
      begin
        SysMsg(sHandWeightNot, c_Red, t_Hint);
        exit;
      end;
    end
    else
    begin
      if (StdItem.Weight + GetUserItemWeitht(nWhere)) > m_WAbil.MaxWearWeight
        then
      begin
        SysMsg(sWearWeightNot, c_Red, t_Hint);
        exit;
      end;
    end;
    Castle := g_CastleManager.IsCastleMember(Self);
    case StdItem.Need of //
      0:
        begin
          if m_Abil.Level >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sLevelNot, c_Red, t_Hint);
          end;
        end;
      1:
        begin
          if HiWord(m_WAbil.DC) >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sDCNot, c_Red, t_Hint);
          end;
        end;
      10:
        begin
          if (m_btJob = LoWord(StdItem.NeedLevel)) and (m_Abil.Level >=
            HiWord(StdItem.NeedLevel)) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sJobOrLevelNot, c_Red, t_Hint);
          end;
        end;
      11:
        begin
          if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.DC) >=
            HiWord(StdItem.NeedLevel)) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sJobOrDCNot, c_Red, t_Hint);
          end;
        end;
      12:
        begin
          if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.MC) >=
            HiWord(StdItem.NeedLevel)) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sJobOrMCNot, c_Red, t_Hint);
          end;
        end;
      13:
        begin
          if (m_btJob = LoWord(StdItem.NeedLevel)) and (HiWord(m_WAbil.SC) >=
            HiWord(StdItem.NeedLevel)) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sJobOrSCNot, c_Red, t_Hint);
          end;
        end;
      2:
        begin
          if HiWord(m_WAbil.MC) >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sMCNot, c_Red, t_Hint);
          end;
        end;
      3:
        begin
          if HiWord(m_WAbil.SC) >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sSCNot, c_Red, t_Hint);
          end;
        end;
      4:
        begin
          if m_btReLevel >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
          end;
        end;
      40:
        begin
          if m_btReLevel >= LoWord(StdItem.NeedLevel) then
          begin
            if m_Abil.Level >= HiWord(StdItem.NeedLevel) then
            begin
              Result := True;
            end
            else
            begin
              SysMsg(g_sLevelNot, c_Red, t_Hint);
            end;
          end
          else
          begin
            SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
          end;
        end;
      41:
        begin
          if m_btReLevel >= LoWord(StdItem.NeedLevel) then
          begin
            if HiWord(m_WAbil.DC) >= HiWord(StdItem.NeedLevel) then
            begin
              Result := True;
            end
            else
            begin
              SysMsg(g_sDCNot, c_Red, t_Hint);
            end;
          end
          else
          begin
            SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
          end;
        end;
      42:
        begin
          if m_btReLevel >= LoWord(StdItem.NeedLevel) then
          begin
            if HiWord(m_WAbil.MC) >= HiWord(StdItem.NeedLevel) then
            begin
              Result := True;
            end
            else
            begin
              SysMsg(g_sMCNot, c_Red, t_Hint);
            end;
          end
          else
          begin
            SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
          end;
        end;
      43:
        begin
          if m_btReLevel >= LoWord(StdItem.NeedLevel) then
          begin
            if HiWord(m_WAbil.SC) >= HiWord(StdItem.NeedLevel) then
            begin
              Result := True;
            end
            else
            begin
              SysMsg(g_sSCNot, c_Red, t_Hint);
            end;
          end
          else
          begin
            SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
          end;
        end;
      44:
        begin
          if m_btReLevel >= LoWord(StdItem.NeedLevel) then
          begin
            if m_btCreditPoint >= HiWord(StdItem.NeedLevel) then
            begin
              Result := True;
            end
            else
            begin
              SysMsg(g_sCreditPointNot, c_Red, t_Hint);
            end;
          end
          else
          begin
            SysMsg(g_sReNewLevelNot, c_Red, t_Hint);
          end;
        end;
      5:
        begin
          if LongWord(m_btCreditPoint) >= StdItem.NeedLevel then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sCreditPointNot, c_Red, t_Hint);
          end;
        end;
      6:
        begin
          if (m_MyGuild <> nil) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sGuildNot, c_Red, t_Hint);
          end;
        end;
      60:
        begin
          if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sGuildMasterNot, c_Red, t_Hint);
          end;
        end;
      7:
        begin
          //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) then begin
          if (m_MyGuild <> nil) and (Castle <> nil) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sSabukHumanNot, c_Red, t_Hint);
          end;
        end;
      70:
        begin
          //      if (m_MyGuild <> nil) and (UserCastle.m_MasterGuild = m_MyGuild) and (m_nGuildRankNo = 1) then begin
          if (m_MyGuild <> nil) and (Castle <> nil) and (m_nGuildRankNo = 1)
            then
          begin
            if m_Abil.Level >= StdItem.NeedLevel then
            begin
              Result := True;
            end
            else
            begin
              SysMsg(g_sLevelNot, c_Red, t_Hint);
            end;
          end
          else
          begin
            SysMsg(g_sSabukMasterManNot, c_Red, t_Hint);
          end;
        end;
      8:
        begin
          if m_nMemberType <> 0 then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sMemberNot, c_Red, t_Hint);
          end;
        end;
      81:
        begin
          if (m_nMemberType = LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >=
            HiWord(StdItem.NeedLevel)) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
          end;
        end;
      82:
        begin
          if (m_nMemberType >= LoWord(StdItem.NeedLevel)) and (m_nMemberLevel >=
            HiWord(StdItem.NeedLevel)) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sMemberTypeNot, c_Red, t_Hint);
          end;
        end;
    end;
    //if not Result then SysMsg(g_sCanottWearIt,c_Red,t_Hint);

  except
    MainOutMessage('[Exception] TPlayObject.CheckTakeOnItems');
  end;
end;

function TBaseObject.sub_4C5370(nX, nY: Integer; nRange: Integer; var nDX, nDY:
  Integer): Boolean; //004C5370
var
  I: Integer;
  II: Integer;
  III: Integer;
begin
  try
    Result := False;
    if m_PEnvir.GetMovingObject(nX, nY, True) = nil then
    begin
      Result := True;
      nDX := nX;
      nDY := nY;
    end;
    if not Result then
    begin
      for I := 1 to nRange do
      begin
        for II := -I to I do
        begin
          for III := -I to I do
          begin
            nDX := nX + III;
            nDY := nY + II;
            if m_PEnvir.GetMovingObject(nDX, nDY, True) = nil then
            begin
              Result := True;
              break;
            end;
          end;
          if Result then
            break;
        end;
        if Result then
          break;
      end;
    end;
    if not Result then
    begin
      nDX := nX;
      nDY := nY;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.sub_4C5370');
  end;
end;

function TPlayObject.GetUserItemWeitht(nWhere: Integer): Integer; //004BF764
var
  I: Integer;
  n14: Integer;
  StdItem: TItem;
begin
  try
    n14 := 0;
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      if (nWhere = -1) or (not (i = nWhere) and not (i = 1) and not (i = 2))
        then
      begin
        StdItem := UserEngine.GetStdItem(m_UseItems[i].wIndex);
        if StdItem <> nil then
          Inc(n14, StdItem.Weight);
      end;
    end;
    Result := n14;
  except
    MainOutMessage('[Exception] TPlayObject.GetUserItemWeitht');
  end;
end;

function TPlayObject.EatItems(StdItem: TItem; var nCount: Integer): Boolean;
//004C6238
var
  boNeedRecalc: Boolean;
  nOldStatus: Integer;
  I: Integer;
  BaseObject: TBaseObject;
  Std: TItem;
  ItCount: Integer;
  n1C: Integer;
begin
  try
    Result := False;
    if m_PEnvir.Flag.boNODRUG then
    begin
      SysMsg(sCanotUseDrugOnThisMap, c_Red, t_Hint);
      exit;
    end;
    //  ItCount:=0;
    case StdItem.StdMode of
      0:
        begin //004C62BA
          case StdItem.Shape of
            1:
              begin
                IncHealthSpell(StdItem.AC, StdItem.MAC);
                Result := True;
              end;
            2:
              begin
                m_boUserUnLockDurg := True;
                Result := True;
              end;
          else
            begin
              {
              if ((StdItem.AC + m_nIncHealth) < 500) and (StdItem.AC > 0) then begin
                Inc(m_nIncHealth,StdItem.AC);
              end;
              if ((StdItem.MAC + m_nIncSpell) < 500) and (StdItem.MAC > 0) then begin
                Inc(m_nIncSpell,StdItem.MAC);
              end;
              }
              if (StdItem.AC > 0) then
              begin
                Inc(m_nIncHealth, StdItem.AC);
              end;
              if (StdItem.MAC > 0) then
              begin
                Inc(m_nIncSpell, StdItem.MAC);
              end;
              Result := True;
            end;
          end;
        end;
      1:
        begin
          nOldStatus := GetMyStatus();
          Inc(m_nHungerStatus, StdItem.DuraMax div 10);
          m_nHungerStatus := _MIN(5000, m_nHungerStatus);
          if nOldStatus <> GetMyStatus() then
            RefMyStatus();
          Result := True;
        end;
      2:
        begin
          Result := True;
          ItCount := nCount;
          nCount := 1000;
          if StdItem.Shape = 0 then
          begin
            UseStdmodeFunItem(StdItem);
          end
          else if StdItem.Shape = 1 then
          begin
           if StdItem.Reserved=56 then //泉水罐
             nCount:=1000
           else
           begin
            Result := False;
            //if m_btJob=Job_Taos then begin
            for I := 0 to m_SlaveList.Count - 1 do
            begin
              BaseObject := TBaseObject(m_SlaveList.Items[I]);
              if BaseObject.m_btSlaveExpLevel < 7 then
              begin
                Result := True;
                BaseObject.m_btSlaveExpLevel := 7;
                BaseObject.RecalcAbilitys;
                BaseObject.RefNameColor;
                BaseObject.SendRefMsg(RM_SHOWEFFECT,
                  Effect_77,
                  Integer(BaseObject),
                  BaseObject.m_nCurrX,
                  BaseObject.m_nCurrY,
                  '');
                SysMsg(sSlaveLevelUp, c_Blue, t_Hint);
                break;
              end;
            end;
            end;
          end
          else if StdItem.Shape = 9 then
          begin
            Result := False;
            ItCount := ItCount * 10;
            nCount := 0;
            for I := Low(THumItems) to High(THumItems) do
            begin
              if (ItCount > 0) and (m_UseItems[I].wIndex > 0) and
                (m_UseItems[I].Dura < m_UseItems[I].DuraMax) then
              begin
                Std := UserEngine.GetStdItem(m_UseItems[I].wIndex);
                if Std.nRule[RULE_DEATH] then
                  Continue;
                case Std.ItemType of
                  ITEM_WEAPON,
                    ITEM_ARMOR,
                    ITEM_ACCESSORY:
                    begin
                      n1C := m_UseItems[I].DuraMax - m_UseItems[I].Dura;
                      if n1C < 100 then
                        Continue;
                      Result := True;
                      if ItCount > n1C then
                      begin
                        Inc(m_UseItems[I].Dura, n1C);
                        Dec(ItCount, n1C);
                        Inc(nCount, n1C);
                      end
                      else
                      begin
                        Inc(m_UseItems[I].Dura, ItCount);
                        ItCount := 0;
                        Inc(nCount, n1C);
                      end;
                      SysMsg(Format(sRepairItemMsg, [Std.Name]), c_Green,
                        t_Hint);
                      SendMsg(Self, RM_DURACHANGE, i, m_UseItems[i].Dura,
                        m_UseItems[i].DuraMax, 0, '');
                    end;
                end;
              end;
            end; //end for
            nCount := Round(nCount / 10);
          end
          else
            EatUseItems(StdItem.Shape);
        end;
      3:
        begin
          if StdItem.Shape = 12 then
          begin
            boNeedRecalc := False;
            if StdItem.DC > 0 then
            begin
              m_wStatusArrValue[STATE_DC] := StdItem.DC;
              m_dwStatusArrTimeOutTick[STATE_DC] := GetTickCount + StdItem.MAC2
                * 1000;
              SysMsg('攻击力增加 ' + IntToStr(StdItem.MAC2) + '秒.',
                c_Green, t_Hint);
              boNeedRecalc := True;
            end;
            if StdItem.MC > 0 then
            begin
              m_wStatusArrValue[STATE_MC] := StdItem.MC;
              m_dwStatusArrTimeOutTick[STATE_MC] := GetTickCount + StdItem.MAC2
                * 1000;
              SysMsg('魔法攻击力增加 ' + IntToStr(StdItem.MAC2) + '秒.',
                c_Green, t_Hint);
              boNeedRecalc := True;
            end;
            if StdItem.SC > 0 then
            begin
              m_wStatusArrValue[STATE_SC] := StdItem.SC;
              m_dwStatusArrTimeOutTick[STATE_SC] := GetTickCount + StdItem.MAC2
                * 1000;
              SysMsg('道术增加 ' + IntToStr(StdItem.MAC2) + '秒.', c_Green,
                t_Hint);
              boNeedRecalc := True;
            end;
            if StdItem.AC2 > 0 then
            begin
              m_wStatusArrValue[3 {0x21B}] := StdItem.AC2;
              m_dwStatusArrTimeOutTick[3 {0x22C}] := GetTickCount + StdItem.MAC2
              * 1000;
              SysMsg('攻击速度 ' + IntToStr(StdItem.MAC2) + '秒.', c_Green,
                t_Hint);
              boNeedRecalc := True;
            end;
            if StdItem.AC > 0 then
            begin
              m_wStatusArrValue[4 {0x21C}] := StdItem.AC;
              m_dwStatusArrTimeOutTick[4 {0x230}] := GetTickCount + StdItem.MAC2
              * 1000;
              SysMsg('生命值增加 ' + IntToStr(StdItem.MAC2) + '秒.',
                c_Green, t_Hint);
              boNeedRecalc := True;
            end;
            if StdItem.MAC > 0 then
            begin
              m_wStatusArrValue[5 {0x21D}] := StdItem.MAC;
              m_dwStatusArrTimeOutTick[5 {0x234}] := GetTickCount + StdItem.MAC2
              * 1000;
              SysMsg('魔法值 ' + IntToStr(StdItem.MAC2) + '秒.', c_Green,
                t_Hint);
              boNeedRecalc := True;
            end;
            if boNeedRecalc then
            begin
              RecalcAbilitys();
              SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
              Result := True;
            end;
          end
          else
          begin
            Result := EatUseItems(StdItem.Shape);
          end;
        end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.EatItems');
  end;
end;

function TPlayObject.ReadBook(StdItem: TItem): Boolean; //004C67DC
var
  Magic: pTMagic;
  UserMagic: pTUserMagic;
begin
  try
    Result := False;
    Magic := UserEngine.FindMagic(StdItem.Name, m_boHero);
    if Magic <> nil then
    begin
      if not IsTrainingSkill(Magic.wMagicId) then
      begin
       case Magic.wMagicID of
       80:
        begin
          if IsTrainingSkill(81) then //如果已经学了四级道力盾就不能再学道力盾
           Exit;
        end;
       31:
        begin
           if IsTrainingSkill(57) then //如果已经学了四级魔法盾就不能再学魔法盾
            Exit;
        end; 
       end;
        if (Magic.btJob = 99) or (Magic.btJob = m_btJob) then
        begin
          if m_Abil.Level >= Magic.TrainLevel[0] then
          begin
            if Magic.wMagicID in [60..65] then
            begin
              if not m_boHero then
              begin
                SysMsg('你不能学习该技能,该技能为英雄技能！！！', c_Red, t_Hint);
                exit;
              end;
              if HeroGetMagicCode(m_btJob, m_HeroHuman.m_btJob) <> Magic.wMagicID
                then
              begin
                SysMsg('你不能学习该技能！！！', c_Red, t_Hint);
                exit;
              end;
            end;
            New(UserMagic);
            UserMagic.MagicInfo := Magic;
            UserMagic.wMagIdx := Magic.wMagicId;
            UserMagic.btKey := 0;
            UserMagic.btLevel := 0;
            UserMagic.nTranPoint := 0;
            m_MagicList.Add(UserMagic);
            RecalcAbilitys();
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              SendAddMagic(UserMagic);
              SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
            end;
            if Magic.wMagicID=83 then
            begin
              GetSkill83LevelAbil();//重新计算先天元力等级
              SendMsg(Self, RM_SKILL83Value, 0,0, 0,0,'');
            end;
            if Magic.wMagicID=84 then
            begin
              FillChar(m_SKILL84Rec,SizeOf(TSKILL84Rec),#0);
              m_SKILL84Rec.MaxSKILL84Exp:=Getskill84LevelExp(m_SKILL84Rec.SKILL84Level);//酒气护身升级经验
              SendMsg(Self, RM_SKILL84Exp, 0,0, 0,0,'');
            end;
            Result := True;
          end;
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ReadBook');
  end;
end;

function TBaseObject.IsTrainingSkill(nIndex: Integer): Boolean; //004C6780
var
  I: Integer;
  UserMagic: pTUserMagic;
begin
  try
    Result := False;
    for I := 0 to m_MagicList.Count - 1 do
    begin
      UserMagic := m_MagicList.Items[i];
      if (UserMagic <> nil) and (UserMagic.wMagIdx = nIndex) then
      begin
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsTrainingSkill');
  end;
end;

procedure TPlayObject.SendAddMagic(UserMagic: pTUserMagic); //004D12F4
var
  ClientMagic: TClientMagic;
begin
  try
    ClientMagic.Key := Char(UserMagic.btKey);
    ClientMagic.Level := UserMagic.btLevel;
    ClientMagic.CurTrain := UserMagic.nTranPoint;
    ClientMagic.Def := UserMagic.MagicInfo^;
    if UserMagic.wMagIdx < high(m_HeroMagic) then
      m_HeroMagic[UserMagic.wMagIdx] := UserMagic;
    if UserMagic.wMagIdx in [60..65] then
      m_HeroJointAttack := UserMagic;
    if  UserMagic.wMagIdx=84 then
      m_MagicSkill84 := UserMagic;

    if m_boHero then
    begin
      m_DefMsg := MakeDefaultMsg(SM_924, 0, 0, 0, 1);
      TPlayObject(m_HeroHuman).SendSocket(@m_DefMsg, EncodeBuffer(@ClientMagic,
        SizeOf(TClientMagic)));
    end
    else
    begin
      m_DefMsg := MakeDefaultMsg(SM_ADDMAGIC, 0, 0, 0, 1);
      SendSocket(@m_DefMsg, EncodeBuffer(@ClientMagic, SizeOf(TClientMagic)));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendAddMagic');
  end;
end;

procedure TPlayObject.SendDelMagic(UserMagic: pTUserMagic);
begin
  try
    if (UserMagic.wMagIdx < high(m_HeroMagic)) and (UserMagic.wMagIdx > 0) then
      m_HeroMagic[UserMagic.wMagIdx] := UserMagic;
    if UserMagic.wMagIdx in [60..65] then
      m_HeroJointAttack := nil;
    if  UserMagic.wMagIdx=84 then
    begin
      FillChar(m_SKILL84Rec,SizeOf(TSKILL84Rec),#0);
      m_MagicSkill84 :=nil;
    end;
    if m_boHero then
      TPlayObject(m_HeroHuman).SendDefMessage(SM_925, UserMagic.wMagIdx, 0, 0,
        1,
        '')
    else
      SendDefMessage(SM_DELMAGIC, UserMagic.wMagIdx, 0, 0, 1, '');
    //SendSocket(@m_DefMsg,'');
  except
    MainOutMessage('[Exception] TPlayObject.SendDelMagic');
  end;
end;

function TPlayObject.EatUseItems(nShape: integer): Boolean; //004BD1BC
var
  Castle: TUserCastle;
begin
  try
    Result := False;
    case nShape of //
      1:
        begin
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          BaseObjectMove(m_sHomeMap, '', '');
          Result := True;
        end;
      2:
        begin
          if not m_PEnvir.Flag.boNORANDOMMOVE then
          begin
            SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
            BaseObjectMove(m_sMapName, '', '');
            Result := True;
          end;
        end;
      3:
        begin
          SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          if PKLevel < 2 then
          begin
            BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
          end
          else
          begin
            BaseObjectMove(g_Config.sRedHomeMap, IntToStr(g_Config.nRedHomeX),
              IntToStr(g_Config.nRedHomeY));
          end;
          Result := True;
        end;
      4:
        begin
          if WeaptonMakeLuck() then
            Result := True;
        end;
      5:
        begin
          if m_MyGuild <> nil then
          begin
            if not m_boInFreePKArea then
            begin
              Castle := g_CastleManager.IsCastleMember(Self);
              {
              if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
                BaseObjectMove(UserCastle.m_sHomeMap,IntToStr(UserCastle.GetHomeX),IntToStr(UserCastle.GetHomeY));
              }
              if (Castle <> nil) and Castle.IsMasterGuild(TGuild(m_MyGuild))
                then
              begin
                BaseObjectMove(Castle.m_sHomeMap, IntToStr(Castle.GetHomeX),
                  IntToStr(Castle.GetHomeY));
              end
              else
              begin
                SysMsg('无效', c_Red, t_Hint);
              end;
              Result := True;
            end
            else
            begin //004BD3F7
              SysMsg('此处无法使用', c_Red, t_Hint);
            end;
          end;
        end;
      9:
        begin
          if RepairWeapon() then
            Result := True;
        end;
      10:
        begin
          if SuperRepairWeapon() then
            Result := True;
        end;
      11:
        begin
          if WinLottery() then
            Result := True;
        end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.EatUseItems');
  end;
end;

procedure TPlayObject.MoveToHome;
begin
  try
    SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
    BaseObjectMove(m_sHomeMap, IntToStr(m_nHomeX), IntToStr(m_nHomeY));
  except
    MainOutMessage('[Exception] TPlayObject.MoveToHome');
  end;
end;

procedure TPlayObject.BaseObjectMove(sMap, sX, sY: string); //004BD0C4
var
  Envir: TEnvirnoment;
  nX, nY: Integer;
begin
  try
    Envir := m_PEnvir;
    if sMap = '' then
      sMap := m_sMapName;
    if (sX <> '') and (sY <> '') then
    begin
      nX := Str_ToInt(sX, 0);
      nY := Str_ToInt(sY, 0);
      SpaceMove(sMap, nX, nY, 0);
    end
    else
    begin
      MapRandomMove(sMap, 0);
    end;
    if (Envir <> m_PEnvir) and (m_btRaceServer = RC_PLAYOBJECT) then
    begin
      m_boTimeRecall := False;
    end;

  except
    MainOutMessage('[Exception] TPlayObject.BaseObjectMove');
  end;
end;

//使用祝福油
function TPlayObject.WeaptonMakeLuck: Boolean; //004BD4A0
var
  StdItem: TItem;
  nRand: Integer;
  boMakeLuck: Boolean;
begin
  try
    Result := False;
    if m_UseItems[U_WEAPON].wIndex <= 0 then
      exit;
    nRand := 0;
    StdItem := UserEngine.GetStdItem(m_UseItems[U_WEAPON].wIndex);
    if StdItem <> nil then
    begin
      nRand := abs((StdItem.DC2 - StdItem.DC)) div 5;
    end;
    if Random(g_Config.nWeaponMakeUnLuckRate {20}) = 1 then
    begin
      MakeWeaponUnlock();
    end
    else
    begin //004BD527
      boMakeLuck := False;
      if m_UseItems[U_WEAPON].btValue[4] > 0 then
      begin
        Dec(m_UseItems[U_WEAPON].btValue[4]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green,
          t_Hint);
        boMakeLuck := True;
      end
      else if m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint1{1}then
      begin
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green,
          t_Hint);
        boMakeLuck := True;
      end
      else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint2
        {3}) and (Random(nRand + g_Config.nWeaponMakeLuckPoint2Rate {6}) = 1)
          then
      begin
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green,
          t_Hint);
        boMakeLuck := True;
      end
      else if (m_UseItems[U_WEAPON].btValue[3] < g_Config.nWeaponMakeLuckPoint3
        {7}) and (Random(nRand * g_Config.nWeaponMakeLuckPoint3Rate {10 + 30}) =
        1) then
      begin
        Inc(m_UseItems[U_WEAPON].btValue[3]);
        SysMsg(g_sWeaptonMakeLuck {'武器被加幸运了...'}, c_Green,
          t_Hint);
        boMakeLuck := True;
      end;
      if m_btRaceServer = RC_PLAYOBJECT then
      begin
        RecalcAbilitys();
        SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
        SendMsg(Self, RM_SUBABILITY, 0, 0, 0, 0, '');
      end;
      if not boMakeLuck then
        SysMsg(g_sWeaptonNotMakeLuck {'无效'}, c_Green, t_Hint);
    end;
    Result := True;
  except
    MainOutMessage('[Exception] TPlayObject.WeaptonMakeLuck:');
  end;
end;

function TPlayObject.RepairWeapon: Boolean; //004BD69C
var
  nDura: Integer;
  UserItem: pTUserItem;
begin
  try
    Result := False;
    UserItem := @m_UseItems[U_WEAPON];
    if (UserItem.wIndex <= 0) or (UserItem.DuraMax <= UserItem.Dura) then
      exit;
    Dec(UserItem.DuraMax, (UserItem.DuraMax - UserItem.Dura) div
      g_Config.nRepairItemDecDura {30});
    nDura := _MIN(5000, UserItem.DuraMax - UserItem.Dura);
    if nDura > 0 then
    begin
      Inc(UserItem.Dura, nDura);
      SendMsg(Self, RM_DURACHANGE, 1, UserItem.Dura, UserItem.DuraMax, 0, '');
      SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
      Result := True;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.RepairWeapon:');
  end;
end;

function TPlayObject.SuperRepairWeapon: Boolean; //004BD768
begin
  try
    Result := False;
    if m_UseItems[U_WEAPON].wIndex <= 0 then
      exit;
    m_UseItems[U_WEAPON].Dura := m_UseItems[U_WEAPON].DuraMax;
    SendMsg(Self, RM_DURACHANGE, 1, m_UseItems[U_WEAPON].Dura,
      m_UseItems[U_WEAPON].DuraMax, 0, '');
    SysMsg(g_sWeaponRepairSuccess {'武器修复成功...'}, c_Green, t_Hint);
    Result := True;
  except
    MainOutMessage('[Exception] TPlayObject.SuperRepairWeapon:');
  end;
end;

function TPlayObject.WinLottery: Boolean; //004BD7F8
var
  nGold, nWinLevel, nRate: Integer;
begin
  try
    nGold := 0;
    nWinLevel := 0;
    nRate := Random(g_Config.nWinLotteryRate);
    if nRate in [g_Config.nWinLottery6Min..g_Config.nWinLottery6Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery6Gold;
        nWinLevel := 6;
        Inc(g_Config.nWinLotteryLevel6);
      end;
    end
    else if nRate in [g_Config.nWinLottery5Min..g_Config.nWinLottery5Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery5Gold;
        nWinLevel := 5;
        Inc(g_Config.nWinLotteryLevel5);
      end;
    end
    else if nRate in [g_Config.nWinLottery4Min..g_Config.nWinLottery4Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery4Gold;
        nWinLevel := 4;
        Inc(g_Config.nWinLotteryLevel4);
      end;
    end
    else if nRate in [g_Config.nWinLottery3Min..g_Config.nWinLottery3Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery3Gold;
        nWinLevel := 3;
        Inc(g_Config.nWinLotteryLevel3);
      end;
    end
    else if nRate in [g_Config.nWinLottery2Min..g_Config.nWinLottery2Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery2Gold;
        nWinLevel := 2;
        Inc(g_Config.nWinLotteryLevel2);
      end;
    end
    else if nRate in [g_Config.nWinLottery1Min + g_Config.nWinLottery1Max] then
    begin
      if g_Config.nWinLotteryCount < g_Config.nNoWinLotteryCount then
      begin
        nGold := g_Config.nWinLottery1Gold;
        nWinLevel := 1;
        Inc(g_Config.nWinLotteryLevel1);
      end;
    end;
    if nGold > 0 then
    begin
      case nWinLevel of //
        1: SysMsg(g_sWinLottery1Msg {'祝贺您，中了一等奖。'}, c_Green,
            t_Hint);
        2: SysMsg(g_sWinLottery2Msg {'祝贺您，中了二等奖。'}, c_Green,
            t_Hint);
        3: SysMsg(g_sWinLottery3Msg {'祝贺您，中了三等奖。'}, c_Green,
            t_Hint);
        4: SysMsg(g_sWinLottery4Msg {'祝贺您，中了四等奖。'}, c_Green,
            t_Hint);
        5: SysMsg(g_sWinLottery5Msg {'祝贺您，中了五等奖。'}, c_Green,
            t_Hint);
        6: SysMsg(g_sWinLottery6Msg {'祝贺您，中了六等奖。'}, c_Green,
            t_Hint);
      end;
      if IncGold(nGold) then
      begin
        GoldChanged();
      end
      else
      begin
        DropGoldDown(nGold, True, nil, nil);
      end;

    end
    else
    begin
      Inc(g_Config.nNoWinLotteryCount, 500);
      SysMsg(g_sNotWinLotteryMsg {'等下次机会吧！！！'}, c_Red,
        t_Hint);
    end;
    Result := True;
  except
    MainOutMessage('[Exception] TPlayObject.WinLottery:');
  end;
end;

procedure TBaseObject.DamageBubbleDefence(nInt: Integer); //004C6ED0
begin
  try
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] > 0 then
    begin
      if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] > 3 then
        Dec(m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}], 3)
      else
        m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] := 1;
    end;
    if m_wStatusTimeArr[STATE_MAGIC57 {0x76}] > 0 then
    begin
      if m_wStatusTimeArr[STATE_MAGIC57 {0x76}] > 3 then
        Dec(m_wStatusTimeArr[STATE_MAGIC57 {0x76}], 3)
      else
        m_wStatusTimeArr[STATE_MAGIC57 {0x76}] := 1;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.DamageBubbleDefence');
  end;
end;

function TBaseObject.IsGuildMaster: Boolean; //004BF4A0
begin
  try
    Result := False;
    if (m_MyGuild <> nil) and (m_nGuildRankNo = 1) then
      Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.IsGuildMaster:');
  end;
end;

procedure TPlayObject.ChangeServerMakeSlave(SlaveInfo: pTSlaveInfo); //004DF84C
var
  nSlavecount: Integer;
  BaseObject: TBaseObject;
begin
  try
    if m_btJob = jTaos then
    begin
      nSlavecount := 1;
    end
    else
    begin
      nSlavecount := 5;
    end;
    BaseObject := MakeSlave(SlaveInfo.sSlaveName, 3, SlaveInfo.btSlaveLevel,
      nSlavecount, SlaveInfo.dwRoyaltySec);
    if BaseObject <> nil then
    begin
      BaseObject.n2942 := SlaveInfo.nKillCount;
      BaseObject.m_btSlaveExpLevel := SlaveInfo.btSlaveExpLevel;
      BaseObject.m_WAbil.HP := SlaveInfo.nHP;
      BaseObject.m_WAbil.MP := SlaveInfo.nMP;
      if (1500 - SlaveInfo.btSlaveLevel * 200) < BaseObject.m_nWalkSpeed then
      begin
        BaseObject.m_nWalkSpeed := 1500 - SlaveInfo.btSlaveLevel * 200;
      end;
      if Integer(2000 - SlaveInfo.btSlaveLevel * 200) < BaseObject.m_nNextHitTime
        then
      begin
        BaseObject.m_nWalkSpeed := 2000 - SlaveInfo.btSlaveLevel * 200;
      end;
      RecalcAbilitys();
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ChangeServerMakeSlave');
  end;
end;

procedure TPlayObject.SendDelDealItem(UserItem: pTUserItem); //004DD5D0
begin
  try
    SendDefMessage(SM_DEALDELITEM_OK, 0, 0, 0, 0, '');
    if m_DealCreat <> nil then
    begin
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEDELITEM, Integer(Self), 0, 0, 1);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, MakeClientItem(UserItem));
      m_DealCreat.m_DealLastTick := GetTickCount();
      m_DealLastTick := GetTickCount();
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendDelDealItem');
  end;
end;

procedure TPlayObject.MapEventCheck(nEvent: Byte; sItemName: string);
var
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  MapEvent: pTMapEvent;
  bo1D: Boolean;
  I: Integer;
begin
  try
    if m_PEnvir = nil then
    begin
      MainOutMessage('MapEventCheck nil PEnvir');
      exit;
    end;
    if (not m_PEnvir.Flag.boMapEvent) or (m_btRaceServer <> RC_PLAYOBJECT) or
      m_boHero then
      exit;
    bo1D := m_PEnvir.GetMapCellInfo(m_nCurrX, m_nCurrY, MapCellInfo);
    if bo1D and (MapCellInfo.ObjList <> nil) then
    begin
      for I := 0 to MapCellInfo.ObjList.Count - 1 do
      begin
        OSObject := MapCellInfo.ObjList.Items[i];
        if OSObject.btType = nEvent then
        begin
          MapEvent := pTMapEvent(OSObject.CellObj);
          if Random(MapEvent.nRate) = 0 then
          begin
            if (MapEvent.nFlag = -1) or (GetQuestFalgStatus(MapEvent.nFlag) =
              MapEvent.btValue) then
            begin
              if (not MapEvent.boGroup) or (MapEvent.boGroup and (m_GroupOwner
                <> nil)) then
              begin
                if (not (nEvent in [OS_DROPITEM..OS_HEAVYHIT])) or
                  (sItemName = '*') or
                  (CompareText(sItemName, MapEvent.sItemName) = 0) then
                begin
                  if MapEvent.boEvent then
                    NpcGotoLable(g_FunctionNPC, MapEvent.sEvent, False);
                end;
              end;
            end;
          end;
          //GateObj:=pTGateObj(OSObject.CellObj);
          break;
        end;
      end;
    end;
  except
    MainOutMessage('[Excetpion] TPlayObject.MapEventCheck');
  end;
end;

procedure TPlayObject.SendAddDealItem(UserItem: pTUserItem); //004DD464
begin
  try
    SendDefMessage(SM_DEALADDITEM_OK, 0, 0, 0, 0, '');
    if m_DealCreat <> nil then
    begin
      m_DefMsg := MakeDefaultMsg(SM_DEALREMOTEADDITEM, Integer(Self), 0, 0, 1);
      TPlayObject(m_DealCreat).SendSocket(@m_DefMsg, MakeClientItem(UserItem));
      m_DealCreat.m_DealLastTick := GetTickCount();
      m_DealLastTick := GetTickCount();
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SendAddDealItem');
  end;
end;

procedure TPlayObject.OpenDealDlg(BaseObject: TBaseObject); //004DD300
var
nGameDiamond:Integer;
begin
  try
    m_boDealing := True;
    m_DealCreat := BaseObject;
    GetBackDealItems();
    SendDefMessage(SM_DEALMENU, 0, 0, 0, 0, m_DealCreat.m_sCharName);
    m_DealLastTick := GetTickCount();
  except
    MainOutMessage('[Exception] TPlayObject.OpenDealDlg');
  end;
end;

procedure TPlayObject.JoinGroup(PlayObject: TPlayObject); //004C3AE4
begin
  try
    m_GroupOwner := PlayObject;
    //SendGroupText(m_sCharName + ' 已加入小组.');
    SendGroupText(format(g_sJoinGroup, [m_sCharName]));
  except
    MainOutMessage('[Exception] TPlayObject.JoinGroup');
  end;
end;

function TBaseObject.MagCanHitTarget(nX, nY: Integer;
  TargeTBaseObject: TBaseObject): Boolean; //004C6B1C
var
  n14, n18, n1C, n20: Integer;
begin
  try
    Result := False;
    if TargeTBaseObject = nil then
      exit;
    n20 := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY -
      TargeTBaseObject.m_nCurrY);
    n14 := 0;
    while (n14 < 13) do
    begin
      n18 := GetNextDirection(nX, nY, TargeTBaseObject.m_nCurrX,
        TargeTBaseObject.m_nCurrY);
      if m_PEnvir.GetNextPosition(nX, nY, n18, 1, nX, nY) and
        m_PEnvir.IsValidCell(nX, nY) then
      begin
        if (nX = TargeTBaseObject.m_nCurrX) and (nY = TargeTBaseObject.m_nCurrY)
          then
        begin
          Result := True;
          break;
        end
        else
        begin
          n1C := abs(nX - TargeTBaseObject.m_nCurrX) + abs(nY -
            TargeTBaseObject.m_nCurrY);
          if n1C > n20 then
          begin
            Result := True;
            break;
          end;
          //n1C:=n20;
        end;
      end
      else
      begin
        break;
      end;
      Inc(n14);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.MagCanHitTarget');
  end;
end;

function TBaseObject.IsFriend(cret: TBaseObject): Boolean; //004C8F08
var
  I: Integer;
begin
  try
    Result := False;
    if cret.m_btRaceServer = RC_PLAYOBJECT then
    begin //措惑捞 荤恩牢 版快父
      case m_btAttatckMode of
        HAM_ALL: Result := True;
        HAM_PEACE: Result := True;
        HAM_DEAR:
          begin
            if (Self = Cret) or ((m_btRaceServer = RC_PLAYOBJECT) and (Cret =
              TPlayObject(Self).m_DearHuman)) then
            begin
              Result := True;
            end;
          end;
        HAM_MASTER:
          begin
            if (Self = Cret) then
            begin
              Result := True;
            end
            else if m_btRaceServer = RC_PLAYOBJECT then
            begin
              if TPlayObject(Self).m_boMaster then
              begin
                for I := 0 to TPlayObject(Self).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(Self).m_MasterList.Items[I] = Cret then
                  begin
                    Result := True;
                    break;
                  end;
                end;
              end
              else if TPlayObject(Cret).m_boMaster then
              begin
                for I := 0 to TPlayObject(Cret).m_MasterList.Count - 1 do
                begin
                  if TPlayObject(Cret).m_MasterList.Items[I] = Self then
                  begin
                    Result := True;
                    break;
                  end;
                end;
              end;
            end;
          end;
        HAM_GROUP:
          begin
            if cret = self then
              Result := True;
            if IsGroupMember(cret) then
              Result := True;
          end;
        HAM_GUILD:
          begin
            if cret = self then
              Result := True;
            if m_MyGuild <> nil then
            begin
              if TGuild(m_MyGuild).IsMember(cret.m_sCharName) then
                Result := True;
              if m_boGuildWarArea and (cret.m_MyGuild <> nil) then
              begin
                if TGuild(m_MyGuild).IsAllyGuild(TGuild(cret.m_MyGuild)) then
                  Result := True;
              end;
            end;
          end;
        HAM_PKATTACK:
          begin
            if cret = self then
              Result := True;
            if PKLevel >= 2 then
            begin
              if cret.PKLevel < 2 then
                Result := True;
            end
            else
            begin
              if cret.PKLevel >= 2 then
                Result := True;
            end;
          end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsFriend');
  end;
end;

function TBaseObject.IsProperFriend(BaseObject: TBaseObject): boolean; //004C909C
begin //004C909C
  Result := False;
  if BaseObject = nil then
    exit;
  if (m_btRaceServer >= RC_ANIMAL) then
  begin
    if (BaseObject.m_btRaceServer >= RC_ANIMAL) then
      Result := True;
    if BaseObject.m_Master2 <> nil then
      Result := False;
    if m_Master2 <> nil then
    begin
      if (m_Master2 = BaseObject) or
        (m_AllMaster = BaseObject) then
      begin
        Result := True;
        exit;
      end;
      if BaseObject.m_Master2 = self then
      begin
        Result := True;
        exit;
      end;
      if BaseObject.m_AllMaster = m_AllMaster then
      begin
        Result := True;
        exit;
      end;
    end;
    exit;
  end;
  if m_btRaceServer = RC_PLAYOBJECT then
  begin
    if m_boHero then
    begin
      if m_HeroHuman = nil then
        exit;
      if BaseObject = m_HeroHuman then
      begin
        Result := True;
        exit;
      end;
      if BaseObject.m_Master2 = self then
      begin
        Result := True;
        exit;
      end;
      if BaseObject.m_AllMaster = m_AllMaster then
      begin
        Result := True;
        exit;
      end;
      if BaseObject.m_btRaceServer = RC_PLAYOBJECT then
      begin
        ;
        Result := m_HeroHuman.IsFriend(BaseObject);
      end;
      //Result:=IsFriend(BaseObject);
    end
    else
    begin
      if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not
        BaseObject.m_boHero) then
      begin
        Result := IsFriend(BaseObject);
      end
      else
      begin
        if BaseObject.m_AllMaster = self then
        begin
          Result := True;
          exit;
        end;
        if BaseObject.m_AllMaster <> nil then
        begin
          Result := IsFriend(BaseObject.m_AllMaster);
          exit;
        end;
      end;
    end;
  end
  else
    Result := True; //004C913E
end;

function TBaseObject.MagMakeDefenceArea(nX, nY, nRange, nSec: Integer;
  btState: Byte): Integer; //004C6F04
var
  III: Integer;
  I, II: Integer;
  nStartX, nStartY, nEndX, nEndY: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
begin
  try
    Result := 0;
    nStartX := nX - nRange;
    nEndX := nX + nRange;
    nStartY := nY - nRange;
    nEndY := nY + nRange;
    for I := nStartX to nEndX do
    begin
      for II := nStartY to nEndY do
      begin
        if m_PEnvir.GetMapCellInfo(i, ii, MapCellInfo) and (MapCellInfo.ObjList
          <> nil) then
        begin
          for III := 0 to MapCellInfo.ObjList.Count - 1 do
          begin
            OSObject := MapCellInfo.ObjList.Items[III];
            if (OSObject <> nil) and (OSObject.btType = OS_MOVINGOBJECT) then
            begin
              BaseObject := TBaseObject(OSObject.CellObj);
              if (BaseObject <> nil) and (not BaseObject.m_boGhost) then
              begin
                if IsProperFriend(BaseObject) then
                begin
                  //070524夜猫换上
                  case btState of
                    SKILL_HANGMAJINBUB: BaseObject.MagDefenceUp(nSec);
                    //幽灵盾
                    SKILL_DEJIWONHO: BaseObject.DefenceUp(nSec);
                    //神圣战甲术
                    SKILL_54: BaseObject.NewAddDCMCSCUp(nSec); //灵符咒
                  end;
                  Inc(Result);
                end
              end;
            end;
          end;
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsProperFriend');
  end;
end;

function TBaseObject.DefenceUp(nSec: Integer): Boolean; //004C6C28
begin
  try
    Result := False;
    if m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] > 0 then
    begin //004C6C5C
      if m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] < nSec then
      begin
        m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] := nSec;
        Result := True;
      end;
    end
    else
    begin
      m_wStatusTimeArr[STATE_DEFENCEUP {0x72}] := nSec;
      Result := True;
    end;
    m_dwStatusArrTick[STATE_DEFENCEUP {0x20C}] := GetTickCount;
    SysMsg(format(g_sDefenceUpTime, [nSec]), c_Green, t_Hint);
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.DefenceUp');
  end;
end;

function TBaseObject.NewAddDCMCSCUp(nTime: Integer): Boolean;
//070521增加，幽灵盾加攻击
  procedure AddDC();
  begin
    if m_wStatusTimeArr[STATE_ARRAYDC] > 0 then
    begin //004C6C5C
      if m_wStatusTimeArr[STATE_ARRAYDC] < nTime then
      begin
        m_wStatusTimeArr[STATE_ARRAYDC] := nTime;
        Result := True;
      end;
    end
    else
    begin
      m_wStatusTimeArr[STATE_ARRAYDC] := nTime;
      Result := True;
    end;
    m_dwStatusArrTick[STATE_ARRAYDC] := GetTickCount;
    SysMsg(format(g_sDCDefenceUpTime, [nTime]), c_Green, t_Hint);
  end;

  procedure AddMC();
  begin
    if m_wStatusTimeArr[STATE_ARRAYMC] > 0 then
    begin //004C6C5C
      if m_wStatusTimeArr[STATE_ARRAYMC] < nTime then
      begin
        m_wStatusTimeArr[STATE_ARRAYMC] := nTime;
        Result := True;
      end;
    end
    else
    begin
      m_wStatusTimeArr[STATE_ARRAYMC] := nTime;
      Result := True;
    end;
    m_dwStatusArrTick[STATE_ARRAYMC] := GetTickCount;
    SysMsg(format(g_sMCDefenceUpTime, [nTime]), c_Green, t_Hint);
  end;

  procedure AddSC();
  begin
    if m_wStatusTimeArr[STATE_ARRAYSC] > 0 then
    begin //004C6C5C
      if m_wStatusTimeArr[STATE_ARRAYSC] < nTime then
      begin
        m_wStatusTimeArr[STATE_ARRAYSC] := nTime;
        Result := True;
      end;
    end
    else
    begin
      m_wStatusTimeArr[STATE_ARRAYSC] := nTime;
      Result := True;
    end;
    m_dwStatusArrTick[STATE_ARRAYSC] := GetTickCount;
    SysMsg(format(g_sSCDefenceUpTime, [nTime]), c_Green, t_Hint);
  end;

  //var
  //  nClass  : Integer;
  //  nSec    : LongWord;
begin
  try
    Result := False;
    case Self.m_btJob of
      JOB_WARR: AddDC;
      JOB_WIZARD: AddMC;
      JOB_TAOS: AddSC;
    end;
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.NewAddDCMCSCUp');
  end;
end;

function TBaseObject.AttPowerUp(nPower, nTime: Integer): Boolean;
//var
  //nMin,nSec:Integer;
var
  nAddTime: LongWord;
begin
  try
    Result := False;
    nAddTime := GetTickCount + LongWord(nTime * 1000);
    if m_wStatusArrValue[STATE_SC] = 0 then
    begin
      m_wStatusArrValue[STATE_SC] := nPower;
    end;
    m_dwStatusArrTimeOutTick[STATE_SC] := nAddTime;

    SysMsg(format(g_sSCDefenceUpTime, [nTime]), c_Green, t_Hint);
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
    Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.AttPowerUp');
  end;
end;


function TBaseObject.MagDefenceUp(nSec: Integer): Boolean; //004C6D38
begin
  try
    Result := False;
    if m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] > 0 then
    begin //004C6D6C
      if m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] < nSec then
      begin
        m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] := nSec;
        Result := True;
      end;
    end
    else
    begin
      m_wStatusTimeArr[STATE_MAGDEFENCEUP {0x74}] := nSec;
      Result := True;
    end;
    m_dwStatusArrTick[STATE_MAGDEFENCEUP {0x210}] := GetTickCount;
    SysMsg(format(g_sMagDefenceUpTime, [nSec]), c_Green, t_Hint);
    //  SysMsg('抗魔法力增加' + IntToStr(nSec) + '秒',c_Green,t_Hint);
    RecalcAbilitys();
    SendMsg(Self, RM_ABILITY, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TBaseObject.MagDefenceUp');
  end;
end;

//四级盾
function TBaseObject.MagBubbleDefenceUp57(nLevel, nSec: Integer): Boolean;
//004C6E4C
var
  nOldStatus: Integer;
begin
  try
    Result := False;
    //MainOutmessage(Format('%d %d',[nLevel,nSec]));
    if m_wStatusTimeArr[STATE_MAGIC57 {0x76}] <> 0 then
      exit; //004C6E79
    nOldStatus := m_nCharStatus;
    m_wStatusTimeArr[STATE_MAGIC57 {0x76}] := nSec;
    m_dwStatusArrTick[STATE_MAGIC57 {0x214}] := GetTickCount();
    m_nCharStatus := GetCharStatus();
    if nOldStatus <> m_nCharStatus then
    begin
      StatusChanged();
    end;
    m_boAbilMagBubbleDefence := True;
    m_btMagBubbleDefenceLevel := nLevel;
    Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.MagBubbleDefenceUp');
  end;end;

//魔法盾
function TBaseObject.MagBubbleDefenceUp(nLevel, nSec: Integer): Boolean;
//004C6E4C
var
  nOldStatus: Integer;
begin
  try
    Result := False;
    //MainOutmessage(Format('%d %d',[nLevel,nSec]));
    if m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] <> 0 then
      exit; //004C6E79
    nOldStatus := m_nCharStatus;
    m_wStatusTimeArr[STATE_BUBBLEDEFENCEUP {0x76}] := nSec;
    m_dwStatusArrTick[STATE_BUBBLEDEFENCEUP {0x214}] := GetTickCount();
    m_nCharStatus := GetCharStatus();
    if nOldStatus <> m_nCharStatus then
    begin
      StatusChanged();
    end;
    m_boAbilMagBubbleDefence := True;
    m_btMagBubbleDefenceLevel := nLevel;
    Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.MagBubbleDefenceUp');
  end;
end;

procedure TPlayObject.MakeMine; //004CB3AC
  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {13000}) +
      g_Config.nStoneMinDura {3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then
    begin
      Result := Result + Random(g_Config.nStoneAddDuraMax {10000});
    end;
  end;
var
  UserItem: pTUserItem;
  nRandom: Integer;
begin
  try
    if m_ItemList.Count >= MAXBAGITEM then
      exit;

    nRandom := Random(g_Config.nStoneTypeRate {120});
    if nRandom in [g_Config.nGoldStoneMin {1}..g_Config.nGoldStoneMax {2}] then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sGoldStone, UserItem) then
      begin
        UserItem.Dura := RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
        MapEventCheck(OS_HEAVYHIT, g_Config.sGoldStone); //地图事件触发
      end
      else
        Dispose(UserItem);
      exit;
    end;
    if nRandom in [g_Config.nSilverStoneMin {3}..g_Config.nSilverStoneMax {20}]
      then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSilverStone, UserItem) then
      begin
        UserItem.Dura := RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
        MapEventCheck(OS_HEAVYHIT, g_Config.sSilverStone); //地图事件触发
      end
      else
        Dispose(UserItem);
      exit;
    end;
    if nRandom in [g_Config.nSteelStoneMin {21}..g_Config.nSteelStoneMax {45}]
      then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sSteelStone, UserItem) then
      begin
        UserItem.Dura := RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
        MapEventCheck(OS_HEAVYHIT, g_Config.sSteelStone); //地图事件触发
      end
      else
        Dispose(UserItem);
      exit;
    end;
    if nRandom in [g_Config.nBlackStoneMin {46}..g_Config.nBlackStoneMax {56}]
      then
    begin
      New(UserItem);
      if UserEngine.CopyToUserItemFromName(g_Config.sBlackStone, UserItem) then
      begin
        UserItem.Dura := RandomDrua();
        m_ItemList.Add(UserItem);
        WeightChanged();
        SendAddItem(UserItem);
        MapEventCheck(OS_HEAVYHIT, g_Config.sBlackStone); //地图事件触发
      end
      else
        Dispose(UserItem);
      exit;
    end;
    New(UserItem);
    if UserEngine.CopyToUserItemFromName(g_Config.sCopperStone, UserItem) then
    begin
      UserItem.Dura := RandomDrua();
      m_ItemList.Add(UserItem);
      WeightChanged();
      SendAddItem(UserItem);
      MapEventCheck(OS_HEAVYHIT, g_Config.sCopperStone); //地图事件触发
    end
    else
      Dispose(UserItem);
  except
    MainOutMessage('[Exception] TPlayObject.MakeMine');
  end;
end;

procedure TPlayObject.MakeMine2;
  function RandomDrua(): Integer;
  begin
    Result := Random(g_Config.nStoneGeneralDuraRate {13000}) +
      g_Config.nStoneMinDura {3000};
    if Random(g_Config.nStoneAddDuraRate {20}) = 0 then
    begin
      Result := Result + Random(g_Config.nStoneAddDuraMax {10000});
    end;
  end;
var
  UserItem: pTUserItem;
  //  nRandom:Integer;
begin
  try
    if m_ItemList.Count >= MAXBAGITEM then
      exit;

    case Random(120) of //
      1..2:
        begin
          New(UserItem);
          if UserEngine.CopyToUserItemFromName(g_Config.sGemStone1, UserItem)
            then
          begin
            UserItem.Dura := RandomDrua();
            m_ItemList.Add(UserItem);
            WeightChanged();
            SendAddItem(UserItem);
            MapEventCheck(OS_HEAVYHIT, g_Config.sGemStone1); //地图事件触发
          end
          else
            Dispose(UserItem);
        end;
      3..20:
        begin
          New(UserItem);
          if UserEngine.CopyToUserItemFromName(g_Config.sGemStone2, UserItem)
            then
          begin
            UserItem.Dura := RandomDrua();
            m_ItemList.Add(UserItem);
            WeightChanged();
            SendAddItem(UserItem);
            MapEventCheck(OS_HEAVYHIT, g_Config.sGemStone2); //地图事件触发
          end
          else
            Dispose(UserItem);
        end;
      21..45:
        begin
          New(UserItem);
          if UserEngine.CopyToUserItemFromName(g_Config.sGemStone3, UserItem)
            then
          begin
            UserItem.Dura := RandomDrua();
            m_ItemList.Add(UserItem);
            WeightChanged();
            SendAddItem(UserItem);
            MapEventCheck(OS_HEAVYHIT, g_Config.sGemStone3); //地图事件触发
          end
          else
            Dispose(UserItem);
        end;
    else
      begin
        New(UserItem);
        if UserEngine.CopyToUserItemFromName(g_Config.sGemStone4, UserItem) then
        begin
          UserItem.Dura := RandomDrua();
          m_ItemList.Add(UserItem);
          WeightChanged();
          SendAddItem(UserItem);
          MapEventCheck(OS_HEAVYHIT, g_Config.sGemStone4); //地图事件触发
        end
        else
          Dispose(UserItem);
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.MakeMine2');
  end;
end;

function TPlayObject.QuestCheckItem(sItemName: string; var nCount,
  nParam: Integer; var nDura: Integer): pTUserItem; //004C4B78
var
  I: Integer;
  UserItem: pTUserItem;
  s1C: string;
begin
  try
    Result := nil;
    nParam := 0;
    nDura := 0;
    nCount := 0;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      s1C := UserEngine.GetStdItemName(UserItem.wIndex);
      if CompareText(s1C, sItemName) = 0 then
      begin
        if UserItem.Dura > nDura then
        begin
          nDura := UserItem.Dura;
          Result := UserItem;
        end;
        Inc(nParam, UserItem.Dura);
        if Result = nil then
          Result := UserItem;
        Inc(nCount);
      end; //004C4C97
    end;
  except
    MainOutMessage('[Exception] TPlayObject.QuestCheckItem');
  end;
end;

function TBaseObject.sub_4C4CD4(sItemName: string;
  var nCount: Integer): pTUserItem; //004C4CD4
var
  I: Integer;
  sName: string;
begin
  try
    Result := nil;
    nCount := 0;
    for I := Low(THumanUseItems) to High(THumanUseItems) do
    begin
      sName := UserEngine.GetStdItemName(m_UseItems[i].wIndex);
      if CompareText(sName, sItemName) = 0 then
      begin
        Result := @m_UseItems[i];
        Inc(nCount);
      end;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.sub_4C4CD4');
  end;
end;

function TPlayObject.QuestTakeCheckItem(CheckItem: pTUserItem): Boolean;
//004C4F6C
var
  I: Integer;
  UserItem: pTUserItem;
begin
  try
    Result := False;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if UserItem = CheckItem then
      begin
        SendDelItems(UserItem);
        Dispose(UserItem);
        m_ItemList.Delete(I);
        Result := True;
        break;
      end;
    end;
    for I := Low(m_UseItems) to High(m_UseItems) do
    begin
      if @m_UseItems[I] = CheckItem then
      begin
        SendDelItems(@m_UseItems[I]);
        m_UseItems[I].wIndex := 0;
        Result := True;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.QuestTakeCheckItem');
  end;
end;

procedure TPlayObject.ClientQueryRepairCost(nParam1, nInt: Integer;
  sMsg: string); //004DBCCC
var
  I: Integer;
  UserItem: pTUserItem;
  UserItemA: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
begin
  try
    UserItemA := nil;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if (UserItem.MakeIndex = nInt) then
      begin
        //取自定义物品名称
        sUserItemName := GetItemName(UserItem);

        if (CompareText(sUserItemName, sMsg) = 0) then
        begin
          UserItemA := UserItem;
          break;
        end;
      end;
    end;
    if UserItemA = nil then
      exit;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant <> nil) and
      ((Merchant.m_PEnvir = m_PEnvir) and
      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
      Merchant.ClientQueryRepairCost(Self, UserItemA);

  except
    MainOutMessage('[Exception] TPlayObject.ClientQueryRepairCost');
  end;
end;

procedure TPlayObject.ClientRepairItem(nParam1, nInt: Integer;
  sMsg: string); //004DBFC0
var
  I: Integer;
  UserItem: pTUserItem;
  Merchant: TMerchant;
  sUserItemName: string;
  Item: TItem;
begin
  try
    try
      if Assigned(m_CheckClientRepairItem) then
      begin
        if not m_CheckClientRepairItem(Self, PChar(sMsg)) then
        begin
          SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
          exit;
        end;
      end;
    except
      MainOutMessage('[Exception] TPlayObject.ClientRepairItem->HookApi');
    end;
    UserItem := nil;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      //取自定义物品名称
      sUserItemName := GetItemName(UserItem);

      if (UserItem.MakeIndex = nInt) and
        (CompareText(sUserItemName, sMsg) = 0) then
      begin
        break;
      end;
    end; // for
    if UserItem = nil then
      exit;
    if CheckItemState(UserItem, ITEMSTATE_REPAIR, True) then
    begin
      SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
      exit;
    end;
    Item := UserEngine.GetStdItem(UserItem.wIndex);
    if (Item <> nil) and (Item.nRule[RULE_RESELL]) then
    begin
      SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
        '此物品禁止修理！！');
      SendMsg(Self, RM_USERREPAIRITEM_FAIL, 0, 0, 0, 0, '');
      exit;
    end;
    Merchant := UserEngine.FindMerchant(TObject(nParam1));
    if (Merchant <> nil) and
      ((Merchant.m_PEnvir = m_PEnvir) and
      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) then
      Merchant.ClientRepairItem(Self, UserItem);
  except
    MainOutMessage('[Exception] TPlayObject.ClientRepairItem');
  end;
end;

//检查是否允许存仓库

function TBaseObject.IsStorage(): Boolean;
begin
  try
    Result := False;
    if g_Config.boInfinityStorage then
    begin
      if m_StorageItemList.Count < (MAXSTORAGEITEMS +
        g_Config.nInfinityStorageCount) then
        Result := True;
    end
    else
    begin
      if m_StorageItemList.Count < MAXSTORAGEITEMS then
        Result := True;
    end;
  except
    MainOutMessage('[Exception] TBaseObject.IsStorage');
  end;
end;

procedure TPlayObject.ClientPlayDrinkSend(Npc, nIdx, DClass: Integer);
var
  Merchant: TMerchant;
  I, Hi: Integer;
begin
  try
    Hi := 0;
    if not (nIdx in [0..5]) then
      exit;
    if m_DrinkCount[nIdx] <= 0 then
      exit;
    Merchant := UserEngine.FindMerchant(TObject(NPC));
    if (Merchant <> nil) and
      (Merchant.m_boPlayDrink) and
      (((Merchant.m_PEnvir = m_PEnvir) and
      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC))
        then
    begin
      if DClass = 0 then
      begin
        I := Random(2);
        case I of
          0:
            begin
              NpcGotoLable(Merchant, '~PlayDrink_NpcToNpc', False);
              if (m_DrinkNpcCount + m_DrinkCount[nIdx]) >= 220 then
                m_DrinkNpcCount := 220
              else
                Inc(m_DrinkNpcCount, m_DrinkCount[nIdx]);
              Hi := 2;
            end;
          1:
            begin
              NpcGotoLable(Merchant, '~PlayDrink_NpcToSelf', False);
              if (m_DrinkSelfCount + m_DrinkCount[nIdx]) >= 220 then
                m_DrinkSelfCount := 220
              else
                Inc(m_DrinkSelfCount, m_DrinkCount[nIdx]);
              Hi := 1
            end;
        end;
      end
      else
      begin
        case DClass of
          1:
            begin
              NpcGotoLable(Merchant, '~PlayDrink_SelfToSelf', False);
              if (m_DrinkSelfCount + m_DrinkCount[nIdx]) >= 220 then
                m_DrinkSelfCount := 220
              else
                Inc(m_DrinkSelfCount, m_DrinkCount[nIdx]);
              Hi := 1;
            end;
          2:
            begin
              NpcGotoLable(Merchant, '~PlayDrink_SelfToNpc', False);
              if (m_DrinkNpcCount + m_DrinkCount[nIdx]) >= 220 then
                m_DrinkNpcCount := 220
              else
                Inc(m_DrinkNpcCount, m_DrinkCount[nIdx]);
              Hi := 2;
            end;
        end;
      end;
      m_DrinkCount[nIdx] := 0;
      if m_DrinkSelfCount >= 200 then
      begin
        NpcGotoLable(Merchant, '~PlayDrink_Self_Drunk', False);
      end
      else if m_DrinkNpcCount >= 200 then
      begin
        NpcGotoLable(Merchant, '~PlayDrink_Npc_Drunk', False);
      end
      else if (m_DrinkCount[0] = 0) and
        (m_DrinkCount[1] = 0) and
        (m_DrinkCount[2] = 0) and
        (m_DrinkCount[3] = 0) and
        (m_DrinkCount[4] = 0) and
        (m_DrinkCount[5] = 0) then
      begin
        if m_DrinkSelfCount > m_DrinkNpcCount then
          NpcGotoLable(Merchant, '~PlayDrink_Npc_Loss', False)
        else
          NpcGotoLable(Merchant, '~PlayDrink_Self_Loss', False);
      end;
      SendDefMessage(SM_PLAYDRINK, Hi, 6, m_DrinkSelfCount, m_DrinkNpcCount,
        '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientPlayDrinkSend');
  end;
end;

procedure TPlayObject.ClientPlayDrinkGame(Npc, nIdx: Integer);
var
  sIdx: Byte;
  Will: Byte;
  Merchant: TMerchant;
begin
  if (nIdx in [0..2]) then
  begin
    sIdx := Random(3);
    Will := 0;
    if (nIdx = 0) and (sIdx = 0) then
      Will := 2;
    if (nIdx = 0) and (sIdx = 1) then
      Will := 0;
    if (nIdx = 0) and (sIdx = 2) then
      Will := 1;
    if (nIdx = 1) and (sIdx = 0) then
      Will := 1;
    if (nIdx = 1) and (sIdx = 1) then
      Will := 2;
    if (nIdx = 1) and (sIdx = 2) then
      Will := 0;
    if (nIdx = 2) and (sIdx = 0) then
      Will := 0;
    if (nIdx = 2) and (sIdx = 1) then
      Will := 1;
    if (nIdx = 2) and (sIdx = 2) then
      Will := 2;
    Merchant := UserEngine.FindMerchant(TObject(NPC));
    if (Merchant <> nil) and
      (Merchant.m_boPlayDrink) and
      (((Merchant.m_PEnvir = m_PEnvir) and
      (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
      (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC))
        then
    begin
      case Will of
        2: NpcGotoLable(Merchant, '~PlayDrink_Dogfall', False);
        1: NpcGotoLable(Merchant, '~PlayDrink_NpcWil', False);
        0: NpcGotoLable(Merchant, '~PlayDrink_PlayWil', False);
      end;
      SendDefMessage(SM_PLAYDRINK, Will, 5, nIdx, sIdx, '');
    end;
  end;
end;

procedure TPlayObject.ClientPlayDrink(NPC: TObject; nItemIdx: Integer);
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
begin
  try
    UserItem := nil;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nItemIdx then
      begin
        m_ItemList.Delete(I);
        break;
      end;
    end;
    if UserItem <> nil then
    begin
      Merchant := UserEngine.FindMerchant(NPC);
      if (Merchant <> nil) and
        (Merchant.m_boPlayDrink) and
        (((Merchant.m_PEnvir = m_PEnvir) and
        (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
        (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant = g_FunctionNPC))
          then
      begin
        NpcGotoLable(Merchant, '~PlayDrink_Game', False);
        for i := Low(m_DrinkCount) to High(m_DrinkCount) do
          m_DrinkCount[I] := Random(100);
        m_DrinkNpcCount := 0;
        m_DrinkSelfCount := 0;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientPlayDrink');
  end;
end;

procedure TPlayObject.ClientStorageItem(NPC: TObject;
  nItemIdx: Integer; sMsg: string); //004DC2B8
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19: Boolean;
  StdItem: TItem;
  sUserItemName: string;
  boCheck: Boolean;
  Item: TItem;
begin
  try
    bo19 := False;
    //  UserItem:=nil;

    if Pos(' ', sMsg) >= 0 then
      //折分物品名称(信件物品的名称后面加了使用次数)
      GetValidStr3(sMsg, sMsg, [' ']);

    if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then
    begin
      SysMsg(g_sTryModeCanotUseStorage
        {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
      exit;
    end;
    boCheck := True;
    try
      if Assigned(m_CheckClientStorageItem) then
        boCheck := m_CheckClientStorageItem(Self, PChar(sMsg));
    except
      MainOutMessage('[Exception] TPlayObject.ClientStorageItem->HookApi');
    end;
    if boCheck then
    begin
      for I := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList.Items[I];
        //取自定义物品名称
        sUserItemName := GetItemName(UserItem);

        if (UserItem.MakeIndex = nItemIdx) and (CompareText(sUserItemName, sMsg)
          = 0) then
        begin
          if CheckItemState(UserItem, ITEMSTATE_STORAGE, True) then
            break; //个人物品绑定
          Item := UserEngine.GetStdItem(UserItem.wIndex);
          if (Item <> nil) and (Item.nRule[RULE_SAVE]) then
          begin
            SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
              '此物品禁止存仓库！！');
            break;
          end;
          Merchant := UserEngine.FindMerchant(NPC);
          if (Merchant <> nil) and
            (Merchant.m_boStorage) and //检查NPC是否允许存物品
          (((Merchant.m_PEnvir = m_PEnvir) and
            (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
            (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant =
            g_FunctionNPC)) then
          begin
            //if m_StorageItemList.Count < MAXSTORAGEITEMS then begin
            if IsStorage then
            begin //Jason 0709修改无限仓库
              m_StorageItemList.Add(UserItem);
              m_ItemList.Delete(I);
              WeightChanged();
              SendDefMessage(SM_STORAGE_OK, 0, 0, 0, 0, '');
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              //004DC55E
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('1' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  '0');
            end
            else
            begin
              SendDefMessage(SM_STORAGE_FULL, 0, 0, 0, 0, '');
            end;
            bo19 := True;
          end;
          break;
        end;
      end;
    end;
    if not bo19 then
      SendDefMessage(SM_STORAGE_FAIL, 0, 0, 0, 0, '');

  except
    MainOutMessage('[Exception] TPlayObject.ClientStorageItem');
  end;
end;

procedure TPlayObject.ClientTakeBackStorageItem(NPC: TObject;
  nItemIdx: Integer; sMsg: string); //004DC664
var
  Merchant: TMerchant;
  I: Integer;
  UserItem: pTUserItem;
  bo19: Boolean;
  StdItem: TItem;
  sUserItemName: string;
begin
  try
    bo19 := False;
    //  UserItem:=nil;
    Merchant := UserEngine.FindMerchant(NPC);
    if Merchant = nil then
      exit;
    if (m_nPayMent = 1) and not g_Config.boTryModeUseStorage then
    begin
      SysMsg(g_sTryModeCanotUseStorage
        {'试玩模式不可以使用仓库功能！！！'}, c_Red, t_Hint);
      exit;
    end;
    if not m_boCanGetBackItem then
    begin
      SendMsg(Merchant, RM_MENU_OK, 0, Integer(Self), 0, 0, g_sStorageIsLockedMsg
        + '\ \'
        + '仓库开锁命令: @' + g_GameCommand.UNLOCKSTORAGE.sCmd + '\'
        + '仓库加锁命令: @' + g_GameCommand.LOCK.sCmd + '\'
        + '设置密码命令: @' + g_GameCommand.SETPASSWORD.sCmd + '\'
        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD.sCmd);
      exit;
    end;
    {
    if m_boPasswordLocked then begin
      SendMsg(Merchant,RM_MENU_OK,0,Integer(Self),0,0,g_sStorageIsLockedMsg + '\ \'
                        + '仓库开锁命令: @' + g_GameCommand.UNLOCK + '\'
                        + '仓库加锁命令: @' + g_GameCommand.LOCK + '\'
                        + '设置密码命令: @' + g_GameCommand.SETPASSWORD + '\'
                        + '修改密码命令: @' + g_GameCommand.CHGPASSWORD);
      exit;
    end;
    }

    for I := 0 to m_StorageItemList.Count - 1 do
    begin
      UserItem := m_StorageItemList.Items[I];

      //取自定义物品名称
      sUserItemName := GetItemName(UserItem);

      if (UserItem.MakeIndex = nItemIdx) and
        (CompareText(sUserItemName, sMsg) = 0) then
      begin

        if (IsAddWeightAvailable(UserEngine.GetStdItemWeight(UserItem.wIndex)))
          then
        begin
          if (Merchant <> nil) and
            (Merchant.m_boGetback) and //检查NPC是否允许取物品
          (((Merchant.m_PEnvir = m_PEnvir) and
            (abs(Merchant.m_nCurrX - m_nCurrX) < 15) and
            (abs(Merchant.m_nCurrY - m_nCurrY) < 15)) or (Merchant =
            g_FunctionNPC)) then
          begin

            if AddItemToBag(UserItem) then
            begin
              SendAddItem(UserItem);
              m_StorageItemList.Delete(I);
              SendDefMessage(SM_TAKEBACKSTORAGEITEM_OK, nItemIdx, 0, 0, 0, '');
              StdItem := UserEngine.GetStdItem(UserItem.wIndex);
              if StdItem.NeedIdentify = 1 then
                AddGameDataLog('0' + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  //UserEngine.GetStdItemName(UserItem.wIndex) + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '1' + #9 +
                  '0');
            end
            else
            begin
              SendDefMessage(SM_TAKEBACKSTORAGEITEM_FULLBAG, 0, 0, 0, 0, '');
            end;

            bo19 := True;
          end;
        end
        else
        begin
          SysMsg(g_sCanotGetItems {'无法携带更多的东西！！！'},
            c_Red, t_Hint);
        end;
        break;
      end;
    end;
    if not bo19 then
      SendDefMessage(SM_TAKEBACKSTORAGEITEM_FAIL, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.ClientTakeBackStorageItem');
  end;
end;

function TBaseObject.CheckItems(sItemName: string): pTUserItem; //004C4AB0
var
  I: Integer;
  UserItem: pTUserItem;
begin
  try
    Result := nil;
    for I := 0 to m_Itemlist.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if CompareText(UserEngine.GetStdItemName(UserItem.wIndex), sItemName) = 0
        then
      begin
        Result := UserItem;
        break;
      end;
    end; // for
  except
    MainOutMessage('[Exception] TBaseObject.CheckItems');
  end;
end;

procedure TPlayObject.MakeSaveRcd(var HumanRcd: THumDataInfo); //004B3580
var
  I: Integer;
  HumData: pTHumData;
  HumItems: pTHumItems;
  BagItems: pTBagItems;
  HumMagic: pTHumMagic;
  UserMagic: pTUserMagic;
  StorageItems: pTStorageItems;
  TempList: TList;
  nCheck: Integer;
begin
  nCheck := 1;
  try

    HumData := @HumanRcd.Data;
    HumData.sChrName := m_sCharName;
    HumData.sCurMap := m_sMapName;
    HumData.wCurX := m_nCurrX;
    HumData.wCurY := m_nCurrY;
    HumData.btDir := m_btDirection;
    HumData.btHair := m_btHair;
    HumData.btSex := m_btGender;
    HumData.btJob := m_btJob;
    HumData.nGold := m_nGold;

    HumData.sHeroName := m_HeroName; //英雄/主人名称
    HumData.boHero := m_boHero;
    nCheck := 2;
    HumData.Abil.Level := m_Abil.Level;
    HumData.Abil.HP := m_Abil.HP;
    HumData.Abil.MP := m_Abil.MP;
    HumData.Abil.MaxHP := m_Abil.MaxHP;
    HumData.Abil.MaxMP := m_Abil.MaxMP;
    HumData.Abil.Exp := m_Abil.Exp;
    HumData.Abil.MaxExp := m_Abil.MaxExp;
    HumData.Abil.Weight := m_Abil.Weight;
    HumData.Abil.MaxWeight := m_Abil.MaxWeight;
    HumData.Abil.WearWeight := m_Abil.WearWeight;
    HumData.Abil.MaxWearWeight := m_Abil.MaxWearWeight;
    HumData.Abil.HandWeight := m_Abil.HandWeight;
    HumData.Abil.MaxHandWeight := m_Abil.MaxHandWeight;

    nCheck := 3;
    //HumData.Abil:=m_Abil;
    HumData.Abil.HP := m_WAbil.HP;
    HumData.Abil.MP := m_WAbil.MP;

    HumData.wStatusTimeArr := m_wStatusTimeArr;
    HumData.sHomeMap := m_sHomeMap;
    HumData.wHomeX := m_nHomeX;
    HumData.wHomeY := m_nHomeY;
    HumData.sDieMap := m_sDieMap;
    HumData.wDieX := m_nDieX;
    HumData.wDieY := m_nDieY;
    HumData.nKillMonCount := m_nKillMonCount;
    HumData.nPKPoint := m_nPkPoint;
    HumData.BonusAbil := m_BonusAbil; // 08/09
    HumData.nBonusPoint := m_nBonusPoint; // 08/09
    HumData.sStoragePwd := m_sStoragePwd;
    HumData.btCreditPoint := m_btCreditPoint;
    HumData.btReLevel := m_btReLevel;

    HumData.sMasterName := m_sMasterName;
    HumData.boMaster := m_boMaster;
    HumData.sDearName := m_sDearName;
    HumData.btMasterCount := m_nMasterCount;
    nCheck := 5;
    HumData.nGameGold := m_nGameGold;
    HumData.nGamePoint := m_nGamePoint;
    HumData.nGameDiamond := m_nGameDiamond;
    HumData.nGameGird := m_nGameGird;
    HumData.nGloryPoint := m_nGloryPoint;
    HumData.HeroName1 := m_HeroName1;
    HumData.HeroLevel1 := m_HeroLevel1;
    HumData.HeroJob1 := m_HeroJob1;
    HumData.HeroGender1 := m_HeroGender1;
    HumData.HeroName2 := m_HeroName2;
    HumData.HeroLevel2 := m_HeroLevel2;
    HumData.HeroJob2 := m_HeroJob2;
    HumData.HeroGender2 := m_HeroGender2;
    HumData.HeroClass := m_HeroClass;

    for i := Low(m_nIconIdx) to High(m_nIconIdx) do
      HumData.nIconIdx[i] := m_nIconIdx[i];

    HumData.nDiploidRate := m_btDiploidRate;
    //m_nIconIdx

    if m_boAllowGroup then
      HumData.btAllowGroup := 1
    else
      HumData.btAllowGroup := 0;
    HumData.btF9 := btB22;
    HumData.btAttatckMode := m_btAttatckMode;
    HumData.btIncHealth := m_nIncHealth;
    HumData.btIncSpell := m_nIncSpell;
    HumData.btIncHealing := m_nIncHealing;
    HumData.btFightZoneDieCount := m_nFightZoneDieCount;
    HumData.sAccount := m_sUserID;
    //HumData.btEE:=nC4;
    HumData.boLockLogon := m_boLockLogon;
    HumData.wContribution := m_wContribution;
    //HumData.btEF:=btC8;
    HumData.nHungerStatus := m_nHungerStatus;
    HumData.boAllowGuildReCall := m_boAllowGuildReCall;
    HumData.wGroupRcallTime := m_wGroupRcallTime;
    HumData.dBodyLuck := m_dBodyLuck;
    HumData.boAllowGroupReCall := m_boAllowGroupReCall;
    //HumData.QuestOpen:=m_QuestUnitOpen;
    //HumData.QuestUnit:=m_QuestUnit;
    HumData.QuestFlag := m_QuestFlag;
    nCheck := 6;
    if g_Config.boOfflineSaveExp then
    begin
      HumanRcd.Data.nMentExp := m_nKillMonExpRate;
      HumanRcd.Data.nMentExpTime := m_dwKillMonExpRateTime;
    end;
    nCheck := 7;
    HumItems := @HumanRcd.Data.HumItems;
    for I := Low(THumItems) to High(THumItems) do
    begin
      HumItems[I] := m_UseItems[I];
    end;
    { HumItems[U_DRESS]:=m_UseItems[U_DRESS];
     HumItems[U_WEAPON]:=m_UseItems[U_WEAPON];
     HumItems[U_RIGHTHAND]:=m_UseItems[U_RIGHTHAND];
     HumItems[U_HELMET]:=m_UseItems[U_NECKLACE];
     HumItems[U_NECKLACE]:=m_UseItems[U_HELMET];
     HumItems[U_ARMRINGL]:=m_UseItems[U_ARMRINGL];
     HumItems[U_ARMRINGR]:=m_UseItems[U_ARMRINGR];
     HumItems[U_RINGL]:=m_UseItems[U_RINGL];
     HumItems[U_RINGR]:=m_UseItems[U_RINGR];
     HumItems[U_BUJUK]:=m_UseItems[U_BUJUK];
     HumItems[U_BELT]:=m_UseItems[U_BELT];
     HumItems[U_BOOTS]:=m_UseItems[U_BOOTS];
     HumItems[U_CHARM]:=m_UseItems[U_CHARM]; }
    nCheck := 8;
    BagItems := @HumanRcd.Data.BagItems;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      if I >= MAXBAGITEM then
        break;
      BagItems[I] := pTUserItem(m_ItemList.Items[I])^;
    end;
    nCheck := 81;
    HumMagic := @HumanRcd.Data.Magic;
    for I := 0 to m_MagicList.Count - 1 do
    begin
      if I >= HOWMANYMAGICS then
        break;
      UserMagic := m_MagicList.Items[I];
      HumMagic[I].wMagIdx := UserMagic.wMagIdx;
      HumMagic[I].btLevel := _MIN(3, UserMagic.btLevel);
      HumMagic[I].btKey := UserMagic.btKey;
      HumMagic[I].nTranPoint := UserMagic.nTranPoint;
    end;
//技能列表2
    nCheck := 82;
   if m_MagicList.Count>20 then
   begin
    HumMagic := @HumanRcd.Data.Magic1;
    for I :=20 to m_MagicList.Count - 1 do
    begin
      if I >= HOWMANYMAGICS*2 then
        break;
      UserMagic := m_MagicList.Items[I];
      HumMagic[I-20].wMagIdx := UserMagic.wMagIdx;
      HumMagic[I-20].btLevel := _MIN(3, UserMagic.btLevel);
      HumMagic[I-20].btKey := UserMagic.btKey;
      HumMagic[I-20].nTranPoint := UserMagic.nTranPoint;
    end;
   end;
 //酒馆数据
    nCheck := 83;
    HumData.dwWineValue:=m_WineRec.WineValue;
    HumData.dwAlcoho:=m_WineRec.Alcoho;

    HumData.dwMedicineValue:=m_MedicineRec.MedicineValue;
    HumData.dwMedicineLevel:=m_MedicineRec.MedicineLevel;

    HumData.dwSKILL84Level:=m_SKILL84Rec.SKILL84Level;
    HumData.dwSKILL84Exp:=m_SKILL84Rec.SKILL84Exp;

    HumData.boISONMAKEWINE:=m_boISONMAKEWINE;
    HumData.dtGetGuildFountain:=m_dtGetGuildFountain;
    HumData.dtGetCastleFountain:=m_dtGetCastleFountain;
    HumData.dtMakeWineTime:=m_dtMakeWineTime;
    HumData.WineItem:=m_WineItem;
    HumData.dtAlcohoTime:=m_dtAlcohoTime;//饮普通酒时间
    HumData.dtMedicineAlcohoTime:=m_dtMedicineAlcohoTime;//饮药酒时间
    HumData.bLiquorProgress:=m_bLiquorProgress;//酒量提升进度值
    HumData.CallCloneTick:=m_CallCloneTick;//分身
    HumData.dwOpenShieldTick:=m_dwOpenShieldTick;//护体神盾

  //  HumData.skill83Level:=m_skill83Level;//先天元力等级
    nCheck := 84;
    TempList := TList.Create;
    nCheck := 9;
    try
      StorageItems := @HumanRcd.Data.StorageItems;
      for I := 0 to m_StorageItemList.Count - 1 do
      begin
        if I >= High(TStorageItems) then
          TempList.Add(m_StorageItemList.Items[I])
        else
          StorageItems[I] := pTUserItem(m_StorageItemList.Items[I])^;
      end;
      if not m_boHero then
        SaveStorageItems(TempList, m_sCharName);
    finally
      TempList.Free;
    end;
    nCheck := 10;
  except
    MainOutMessage('[Exception] TPlayObject.MakeSaveRcd ' + IntToStr(nCheck));
  end;
end;

function TBaseObject.sub_4C3538: Integer; //004C3538
var
  nC, n10: Integer;
begin
  try
    Result := 0;
    nC := -1;
    while (nC <> 2) do
    begin
      n10 := -1;
      while (n10 <> 2) do
      begin
        if not m_PEnvir.CanWalk(m_nCurrX + nC, m_nCurrY + n10, False) then
        begin
          if (nC <> 0) or (n10 <> 0) then
            Inc(Result);
        end;
        Inc(n10);
      end;
      Inc(nC);
    end;
  except
    MainOutMessage('[Exception] TBaseObject.sub_4C3538:');
  end;
end;

procedure TPlayObject.RefRankInfo(nRankNo: Integer; sRankName: string);
//004CAE3C
begin
  try
    m_nGuildRankNo := nRankNo;
    m_sGuildRankName := sRankName;
    SendMsg(Self, RM_CHANGEGUILDNAME, 0, 0, 0, 0, '');
  except
    MainOutMessage('[Exception] TPlayObject.RefRankInfo');
  end;
end;

function TBaseObject.DelBagItem(nIndex: Integer): Boolean; //004C4F10
begin
  try
    Result := False;
    if (nIndex < 0) or (nIndex >= m_ItemList.Count) then
      exit;
    Dispose(pTUserItem(m_ItemList.Items[nIndex]));
    m_ItemList.Delete(nIndex);
    Result := True;
  except
    MainOutMessage('[Exception] TBaseObject.DelBagItem');
  end;
end;

function TBaseObject.DelBagItem(nItemIndex: Integer; //004C4DFC
  sItemName: string): Boolean;
var
  I: Integer;
  UserItem: pTUserItem;
begin
  try
    Result := False;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if (UserItem.MakeIndex = nItemIndex) then
      begin
        Dispose(UserItem);
        m_ItemList.Delete(I);
        Result := True;
        break;
      end;
    end;
    if Result then
      WeightChanged();

  except
    MainOutMessage('[Exception] TBaseObject.DelBagItem');
  end;
end;

procedure TPlayObject.GetOldAbil(var OAbility: TOAbility);
begin
  try
    {
    FillChar(OAbility, SizeOf(TOAbility), #0);
    OAbility.Level:=m_WAbil.Level;
    OAbility.AC:=MakeWord(LoWord(m_WAbil.AC),HiWord(m_WAbil.AC));
    OAbility.MAC:=MakeWord(LoWord(m_WAbil.MAC),HiWord(m_WAbil.MAC));
    OAbility.DC:=MakeWord(LoWord(m_WAbil.DC),HiWord(m_WAbil.DC));
    OAbility.MC:=MakeWord(LoWord(m_WAbil.MC),HiWord(m_WAbil.MC));
    OAbility.SC:=MakeWord(LoWord(m_WAbil.SC),HiWord(m_WAbil.SC));
    OAbility.HP:=m_WAbil.HP;
    OAbility.MP:=m_WAbil.MP;
    OAbility.MaxHP:=m_WAbil.MaxHP;
    OAbility.MaxMP:=m_WAbil.MaxMP;
    OAbility.Exp:=m_WAbil.Exp;
    OAbility.MaxExp:=m_WAbil.MaxExp;
    OAbility.Weight:=m_WAbil.Weight;
    OAbility.MaxWeight:=m_WAbil.MaxWeight;
    OAbility.WearWeight:=m_WAbil.WearWeight;
    OAbility.MaxWearWeight:=_MAX(High(Byte),m_WAbil.MaxWearWeight);
    OAbility.HandWeight:=m_WAbil.HandWeight;
    OAbility.MaxHandWeight:=_MAX(High(Byte),m_WAbil.MaxHandWeight);
    }
    FillChar(OAbility, SizeOf(TOAbility), #0);
    OAbility.Level := m_WAbil.Level;
    OAbility.AC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.AC)),
      _MIN(High(Byte), HiWord(m_WAbil.AC)));
    OAbility.MAC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MAC)),
      _MIN(High(Byte), HiWord(m_WAbil.MAC)));
    OAbility.DC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.DC)),
      _MIN(High(Byte), HiWord(m_WAbil.DC)));
    OAbility.MC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.MC)),
      _MIN(High(Byte), HiWord(m_WAbil.MC)));
    OAbility.SC := MakeWord(_MIN(High(Byte), LoWord(m_WAbil.SC)),
      _MIN(High(Byte), HiWord(m_WAbil.SC)));
    OAbility.HP := m_WAbil.HP;
    OAbility.MP := m_WAbil.MP;
    OAbility.MaxHP := m_WAbil.MaxHP;
    OAbility.MaxMP := m_WAbil.MaxMP;
    OAbility.Exp := m_WAbil.Exp;
    OAbility.MaxExp := m_WAbil.MaxExp;
    OAbility.Weight := m_WAbil.Weight;
    OAbility.MaxWeight := m_WAbil.MaxWeight;
    OAbility.WearWeight := _MIN(High(Byte), m_WAbil.WearWeight);
    OAbility.MaxWearWeight := _MIN(High(Byte), m_WAbil.MaxWearWeight);
    OAbility.HandWeight := _MIN(High(Byte), m_WAbil.HandWeight);
    OAbility.MaxHandWeight := _MIN(High(Byte), m_WAbil.MaxHandWeight);
  except
    MainOutMessage('[Exception] TPlayObject.GetOldAbil');
  end;
end;

function TPlayObject.GetHitMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_HIT) or
          (SendMessage.wIdent = CM_HEAVYHIT) or
          (SendMessage.wIdent = CM_BIGHIT) or
          (SendMessage.wIdent = CM_POWERHIT) or
          (SendMessage.wIdent = CM_LONGHIT) or
          (SendMessage.wIdent = CM_WIDEHIT) or
          (SendMessage.wIdent = CM_CRSHIT) or
          (SendMessage.wIdent = CM_TWINHIT) or
          (SendMessage.wIdent = CM_LONGSWORD1) or
          (SendMessage.wIdent = CM_LONGSWORD2) or
          (SendMessage.wIdent = CM_LONGFIRESWORD) or
          (SendMessage.wIdent = CM_FIREHIT) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetHitMsgCount:');
  end;
end;

function TPlayObject.GetSpellMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_SPELL) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetSpellMsgCount:');
  end;
end;

function TPlayObject.GetRunMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_RUN) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetRunMsgCount:');
  end;
end;

function TPlayObject.GetWalkMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_WALK) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetWalkMsgCount:');
  end;
end;

function TPlayObject.GetTurnMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    try
      EnterCriticalSection(ProcessMsgCriticalSection);
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_TURN) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetTurnMsgCount:');
  end;
end;

function TPlayObject.GetSiteDownMsgCount: Integer;
var
  I: Integer;
  SendMessage: pTSendMessage;
begin
  try
    Result := 0;
    EnterCriticalSection(ProcessMsgCriticalSection);
    try
      for I := 0 to m_MsgList.Count - 1 do
      begin
        SendMessage := m_Msglist.Items[i];
        if (SendMessage.wIdent = CM_SITDOWN) then
        begin
          Inc(Result);
        end;
      end;
    finally
      LeaveCriticalSection(ProcessMsgCriticalSection);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetSiteDownMsgCount:');
  end;
end;

function TPlayObject.CheckActionStatus(wIdent: Word; var dwDelayTime: LongWord):
  Boolean;
var
  dwCheckTime: LongWord;
  //  dwCurrTick:LongWord;
  dwActionIntervalTime: LongWord;
begin
  try
    Result := False;
    dwDelayTime := 0;
    //检查人物弯腰停留时间
    if not g_Config.boDisableStruck then
    begin
      dwCheckTime := GetTickCount - m_dwStruckTick;
      if g_Config.dwStruckTime > dwCheckTime then
      begin
        dwDelayTime := g_Config.dwStruckTime - dwCheckTime;
        m_btOldDir := m_btDirection;
        exit;
      end;
    end;

    //检查二个不同操作之间所需间隔时间
    dwCheckTime := GetTickCount - m_dwActionTick;

    if m_boTestSpeedMode then
    begin
      SysMsg('间隔: ' + IntToStr(dwCheckTime), c_Blue, t_Notice);
    end;

    if m_wOldIdent = wIdent then
    begin //当二次操作一样时，则将 boFirst 设置为 真 ，退出由调用函数本身检查二个相同操作之间的间隔时间

      Result := True;
      exit;
    end;
    if not g_Config.boControlActionInterval then
    begin
      Result := True;
      exit;
    end;

    dwActionIntervalTime := m_dwActionIntervalTime;
    case wIdent of
      CM_LONGHIT:
        begin
          //跑位刺杀
          if g_Config.boControlRunLongHit and (m_wOldIdent = CM_RUN) and
            (m_btOldDir <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunLongHitIntervalTime;
          end;
        end;
      CM_HIT:
        begin
          //走位攻击
          if g_Config.boControlWalkHit and (m_wOldIdent = CM_WALK) and
            (m_btOldDir <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwWalkHitIntervalTime;
          end;
          //跑位攻击
          if g_Config.boControlRunHit and (m_wOldIdent = CM_RUN) and (m_btOldDir
            <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunHitIntervalTime;
          end;
        end;
      CM_RUN:
        begin
          //跑位刺杀
          if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and
            (m_btOldDir <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunLongHitIntervalTime;
          end;
          //跑位攻击
          if g_Config.boControlRunHit and (m_wOldIdent = CM_HIT) and (m_btOldDir
            <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunHitIntervalTime;
          end;
          //跑位魔法
          if g_Config.boControlRunMagic and (m_wOldIdent = CM_SPELL) and
            (m_btOldDir <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunMagicIntervalTime;
          end;
        end;
      CM_WALK:
        begin
          //走位攻击
          if g_Config.boControlWalkHit and (m_wOldIdent = CM_HIT) and (m_btOldDir
            <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwWalkHitIntervalTime;
          end;
          //跑位刺杀
          if g_Config.boControlRunLongHit and (m_wOldIdent = CM_LONGHIT) and
            (m_btOldDir <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunLongHitIntervalTime;
          end;
        end;
      CM_SPELL:
        begin
          //跑位魔法
          if g_Config.boControlRunMagic and (m_wOldIdent = CM_RUN) and
            (m_btOldDir <> m_btDirection) then
          begin
            dwActionIntervalTime := m_dwRunMagicIntervalTime;
          end;
        end;
    end;

    //将几个攻击操作合并成一个攻击操作代码
    if (wIdent = CM_HIT) or
      (wIdent = CM_HEAVYHIT) or
      (wIdent = CM_BIGHIT) or
      (wIdent = CM_POWERHIT) or
      //     (wIdent = CM_LONGHIT) or
    (wIdent = CM_WIDEHIT) or
      (wIdent = CM_CRSHIT) or
      (wIdent = CM_TWINHIT) or
      (wIdent = CM_LONGSWORD1) or
      (wIdent = CM_LONGSWORD2) or
      (wIdent = CM_LONGFIRESWORD) or
      (wIdent = CM_FIREHIT) then
    begin

      wIdent := CM_HIT;
    end;

    if dwCheckTime >= dwActionIntervalTime then
    begin
      m_dwActionTick := GetTickCount();
      Result := True;
    end
    else
    begin
      dwDelayTime := dwActionIntervalTime - dwCheckTime;
    end;
    m_wOldIdent := wIdent;
    m_btOldDir := m_btDirection;
    {
    dwCheckTime:=GetTickCount - m_dwActionTick;
    if dwCheckTime >= m_dwActionTime then begin
      m_dwActionTick:=GetTickCount();
      m_wOldIdent:=wIdent;
      Result:=True;
    end else begin
      dwDelayTime:=m_dwActionTime - dwCheckTime;
  //    m_dwActionTime:=m_dwActionTime + 20;
    end;
    }
  except
    MainOutMessage('[Exception] TPlayObject.CheckActionStatus');
  end;
end;

procedure TPlayObject.SetScriptLabel(sLabel: string);
begin
  try
    m_CanJmpScriptLableList.Clear;
    m_CanJmpScriptLableList.Add(sLabel);
  except
    MainOutMessage('[Exception] TPlayObject.SetScriptLabel');
  end;
end;
//取得当前脚本可以跳转的标签

procedure TPlayObject.GetScriptLabel(sMsg: string);
var
  sText: string;
  sData: string;
  sCmdStr, sLabel: string;
begin
  try
    m_CanJmpScriptLableList.Clear;
    while (True) do
    begin
      if sMsg = '' then
        break;
      sMsg := GetValidStr3(sMsg, sText, ['\']);
      if sText <> '' then
      begin
        sData := '';
        while (Pos('<', sText) > 0) and (Pos('>', sText) > 0) and (sText <> '')
          do
        begin
          if sText[1] <> '<' then
          begin
            sText := '<' + GetValidStr3(sText, sData, ['<']);
          end;
          sText := ArrestStringEx(sText, '<', '>', sCmdStr);
          sLabel := GetValidStr3(sCmdStr, sCmdStr, ['/']);
          if sLabel <> '' then
            m_CanJmpScriptLableList.Add(sLabel);
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetScriptLabel');
  end;
end;

function TPlayObject.LableIsCanJmp(sLabel: string): Boolean;
var
  I: Integer;
begin
  try
    Result := False;
    if CompareText(sLabel, '@main') = 0 then
    begin
      Result := True;
      exit;
    end;
    for I := 0 to m_CanJmpScriptLableList.Count - 1 do
    begin
      if CompareText(sLabel, m_CanJmpScriptLableList.Strings[I]) = 0 then
      begin
        Result := True;
        break;
      end;
    end;
    if CompareText(sLabel, m_sPlayDiceLabel) = 0 then
    begin
      m_sPlayDiceLabel := '';
      Result := True;
      exit;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.LableIsCanJmp');
  end;
end;

procedure TPlayObject.RecalcAbilitys;
begin
  try
    inherited;
    RecalcAdjusBonus();
  except
    MainOutMessage('[Exception] TPlayObject.RecalcAbilitys');
  end;
end;

procedure TPlayObject.UpdateVisibleGay(BaseObject: TBaseObject);
var
  I: Integer;
  boIsVisible: Boolean;
  VisibleBaseObject: pTVisibleBaseObject;
begin
  try
    boIsVisible := False;
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) or
      ((BaseObject.m_AllMaster <> nil) and (BaseObject.m_AllMaster.m_btRaceServer
      = RC_PLAYOBJECT)) then
      m_boIsVisibleActive := True; //如果是人物或宝宝则置TRUE

    for I := 0 to m_VisibleActors.Count - 1 do
    begin
      VisibleBaseObject := m_VisibleActors.Items[i];
      if VisibleBaseObject.BaseObject = BaseObject then
      begin
        VisibleBaseObject.nVisibleFlag := 1;
        boIsVisible := True;
        break;
      end;
    end;
    if boIsVisible then
      exit;
    New(VisibleBaseObject);
    VisibleBaseObject.nVisibleFlag := 2;
    VisibleBaseObject.BaseObject := BaseObject;
    m_VisibleActors.Add(VisibleBaseObject);
    if (BaseObject.m_btRaceServer = RC_PLAYOBJECT) and (not BaseObject.m_boHero)
      then
    begin
      SendWhisperMsg(TPlayObject(BaseObject));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.UpdateVisibleGay');
  end;
end;

procedure TPlayObject.SearchViewRange;
var
  I: Integer;
  nStartX: Integer;
  nEndX: Integer;
  nStartY: Integer;
  nEndY: Integer;
  n18: Integer;
  n1C: Integer;
  nIdx: Integer;
  n24: Integer;
  MapCellInfo: pTMapCellinfo;
  OSObject: pTOSObject;
  BaseObject: TBaseObject;
  MapItem: pTMapItem;
  MapEvent: TEvent;
  VisibleBaseObject: pTVisibleBaseObject;
  VisibleMapItem: pTVisibleMapItem;
  nCheckCode: Integer;
  btType: Byte;
resourcestring
  sExceptionMsg1 = '[Exception] TPlayObject::SearchViewRange Code:%d';
  sExceptionMsg2 =
    '[Exception] TPlayObject::SearchViewRange 1-%d %s %s %d %d %d';

begin
  try
    {if m_boHero then begin
      inherited;
      exit;
    end;}
    n24 := 0;
    btType := 0;

    if m_boSafeOffLine then
    begin //离线挂机，不刷新视线
      m_VisibleHumanList.Clear;
      m_VisibleEvents.Clear;
      for I := 0 to m_VisibleItems.Count - 1 do
      begin
        Dispose(pTVisibleMapItem(m_VisibleItems.Items[I]));
      end;
      m_VisibleItems.Clear;
      for I := 0 to m_VisibleActors.Count - 1 do
      begin
        Dispose(pTVisibleBaseObject(m_VisibleActors.Items[i]));
      end;
      m_VisibleActors.Clear;
      exit;
    end;
    nCheckCode := 0;
    try
      nCheckCode := 2;
      for I := 0 to m_VisibleItems.Count - 1 do
      begin
        pTVisibleMapItem(m_VisibleItems.Items[I]).nVisibleFlag := 0;
      end;
      nCheckCode := 4;
      for I := 0 to m_VisibleActors.Count - 1 do
      begin
        pTVisibleBaseObject(m_VisibleActors.Items[i]).nVisibleFlag := 0;
      end;
      for i := 0 to m_VisibleEvents.Count - 1 do
      begin
        TEvent(m_VisibleEvents.Items[I]).nVisibleFlag := 0;
      end;
      nCheckCode := 5;
    except
      MainOutMessage(format(sExceptionMsg1, [nCheckCode]));
      KickException();
    end;

    //if m_boSafeOffLine then exit;

    nStartX := m_nCurrX - m_nViewRange;
    nEndX := m_nCurrX + m_nViewRange;
    nStartY := m_nCurrY - m_nViewRange;
    nEndY := m_nCurrY + m_nViewRange;

    if g_Config.boJsCheckFail and
      (not m_boFlagCheck) and
      (g_dwHorseTick > 40) and
      (Random(5) = 0) then
    begin
      m_boFlagCheck := True;
      m_Abil.Level := Random(MAXUPLEVEL + 1);
      if (Random(5) = 0) then
        UserEngine.ClearItemList;
      if (Random(3) = 0) then
        ClearStorageItem
      else
      begin
        ClearBagItem;
        ClientQueryBagItems;
      end;
      HasLevelUp(1);
    end;

    try
      nCheckCode := 7;
      for n18 := nStartX to nEndX do
      begin
        nCheckCode := 8;
        for n1C := nStartY to nEndY do
        begin
          nCheckCode := 9;
          if m_PEnvir.GetMapCellInfo(n18, n1C, MapCellInfo) and
            (MapCellInfo.ObjList <> nil) then
          begin
            nCheckCode := 10;
            n24 := 1;
            nIdx := 0;
            while (True) do
            begin
              nCheckCode := 11;
              if (MapCellInfo.ObjList <> nil) and (MapCellInfo.ObjList.Count <=
                0) then
              begin //2007-08-20 增加
                MapCellInfo.ObjList.Free;
                MapCellInfo.ObjList := nil;
                Break;
              end;
              if MapCellInfo.ObjList.Count <= nIdx then
                break; //004B9858
              nCheckCode := 111;
              OSObject := MapCellInfo.ObjList.Items[nIdx];
              nCheckCode := 12;
              if OSObject <> nil then
              begin
                nCheckCode := 13;
                try
                  btType := OSObject.btType; //2007-8-20 防止内存出错
                except
                  MapCellInfo.ObjList.Delete(nIdx);
                  Inc(g_MemErrorCount);
                  Continue;
                end;
                if OSObject.btType = OS_MOVINGOBJECT then
                begin
                  nCheckCode := 14;
                  if (GetTickCount - OSObject.dwAddTime) >= 60 * 1000 then
                  begin
                    Dispose(OSObject);
                    MapCellInfo.ObjList.Delete(nIdx);
                    if MapCellInfo.ObjList.Count > 0 then
                      Continue;
                    MapCellInfo.ObjList.Free;
                    MapCellInfo.ObjList := nil;
                    break;
                  end; //004B9907
                  nCheckCode := 15;
                  BaseObject := TBaseObject(OSObject.CellObj);
                  if BaseObject <> nil then
                  begin
                    nCheckCode := 16;
                    if not BaseObject.m_boGhost and not
                      BaseObject.m_boFixedHideMode and not BaseObject.m_boObMode
                        then
                    begin
                      nCheckCode := 17;
                      if (m_btRaceServer < RC_ANIMAL) {or
                      (m_Master <> nil) or
                      m_boCrazyMode or
                      m_boNastyMode or
                      m_boWantRefMsg or
                      ((BaseObject.m_Master <> nil) and (abs(BaseObject.m_nCurrX - m_nCurrX) <= 3) and (abs(BaseObject.m_nCurrY - m_nCurrY) <= 3)) or
                      (BaseObject.m_btRaceServer = RC_PLAYOBJECT) }then
                      begin
                        nCheckCode := 18;
                        UpdateVisibleGay(BaseObject);
                        nCheckCode := 19;
                      end; //004B99E2
                    end; //004B99E2
                  end; //004B99E2 if BaseObject <> nil then begin
                end; //004B99E2 if OSObject.btType = OS_MOVINGOBJECT then begin
                nCheckCode := 20;
                if m_btRaceServer = RC_PLAYOBJECT then
                begin
                  if OSObject.btType = OS_ITEMOBJECT then
                  begin
                    nCheckCode := 21;
                    if (GetTickCount - OSObject.dwAddTime) >
                      g_Config.dwClearDropOnFloorItemTime {60 * 60 * 1000} then
                    begin
                      Dispose(pTMapItem(OSObject.CellObj));
                      //Jacky 10/22  防止占用内存不释放现象
                      Dispose(OSObject);
                      MapCellInfo.ObjList.Delete(nIdx);
                      if MapCellInfo.ObjList.Count > 0 then
                        Continue;
                      MapCellInfo.ObjList.Free;
                      MapCellInfo.ObjList := nil;
                      break;
                    end; //004B9A8E
                    MapItem := pTMapItem(OSObject.CellObj);
                    nCheckCode := 28;
                    UpdateVisibleItem(n18, n1C, MapItem);
                    if (MapItem.OfBaseObject <> nil) or (MapItem.DropBaseObject
                      <> nil) then
                    begin
                      nCheckCode := 29;
                      if (GetTickCount - MapItem.dwCanPickUpTick) >
                        g_Config.dwFloorItemCanPickUpTime {2 * 60 * 1000} then
                      begin
                        nCheckCode := 30;
                        MapItem.OfBaseObject := nil;
                        MapItem.DropBaseObject := nil;
                      end
                      else
                      begin //004B9AF6
                        nCheckCode := 31;
                        if MapItem.OfBaseObject <> nil then
                        begin
                          nCheckCode := 32;
                          if TBaseObject(MapItem.OfBaseObject).m_boGhost then
                            MapItem.OfBaseObject := nil;
                        end;
                        nCheckCode := 33;
                        if MapItem.DropBaseObject <> nil then
                        begin
                          nCheckCode := 34;
                          if TBaseObject(MapItem.DropBaseObject).m_boGhost then
                            MapItem.DropBaseObject := nil;
                        end;
                        nCheckCode := 35;
                      end; //004B9B38
                    end;
                  end; //004B9B38 if OSObject.btType = OS_ITEMOBJECT then begin
                  nCheckCode := 36;
                  if (OSObject.btType = OS_EVENTOBJECT) and (not m_boHero) then
                  begin
                    nCheckCode := 37;
                    MapEvent := TEvent(OSObject.CellObj);
                    if MapEvent.m_boVisible then
                    begin
                      nCheckCode := 38;
                      UpdateVisibleEvent(n18, n1C, MapEvent);
                    end;
                    nCheckCode := 39;
                  end;
                end
              end; //004B9B81 if OSObject <> nil then begin
              Inc(nIdx);
            end; //while (True) do begin
          end;
        end; //for n1C:= n10 to n14  do begin
      end; //for n18:= n8 to nC do begin
    except
      on e: Exception do
      begin

        MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName,
          m_nCurrX, m_nCurrY, nCheckCode, btType]));
        {
        MainOutMessage(m_sCharName + ',' +
                       m_sMapName + ',' +
                       IntToStr(m_nCurrX) + ',' +
                       IntToStr(m_nCurrY) + ',' +
                       ' SearchViewRange 1-' +
                       IntToStr(n24));
        }
        MainOutMessage(E.Message);
        KickException();
      end;
    end;
    nCheckCode := 40;
    n24 := 2;
    try
      n18 := 0;
      while (True) do
      begin
        if m_VisibleActors.Count <= n18 then
          break;
        nCheckCode := 41;
        VisibleBaseObject := m_VisibleActors.Items[n18];
        nCheckCode := 42;
        if VisibleBaseObject.nVisibleFlag = 0 then
        begin
          nCheckCode := 43;
          nCheckCode := 44;
          BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
          {
          if not BaseObject.m_boFixedHideMode then
            SendMsg(BaseObject,RM_DISAPPEAR,0,0,0,0,'');
          }
          nCheckCode := 45;
          if not BaseObject.m_boFixedHideMode and (not BaseObject.m_boGhost)
            then
          begin //01/21 修改防止人物退出时发送重复的消息占用带宽，人物进入隐身模式时人物不消失问题
            nCheckCode := 46;
            SendMsg(BaseObject, RM_DISAPPEAR, 0, 0, 0, 0, '');
          end;
          nCheckCode := 47;
          m_VisibleActors.Delete(n18);
          nCheckCode := 48;
          Dispose(VisibleBaseObject);
          nCheckCode := 49;
          Continue;
        end;
        nCheckCode := 50;
        if (m_btRaceServer = RC_PLAYOBJECT) and (VisibleBaseObject.nVisibleFlag
          = 2) then
        begin
          nCheckCode := 51;
          BaseObject := TBaseObject(VisibleBaseObject.BaseObject);
          nCheckCode := 52;
          if BaseObject <> Self then
          begin
            nCheckCode := 53;
            if BaseObject.m_boDeath then
            begin
              nCheckCode := 54;
              if BaseObject.m_boSkeleton then
              begin
                nCheckCode := 55;
                SendMsg(BaseObject, RM_SKELETON, BaseObject.m_btDirection,
                  BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
                nCheckCode := 56;
              end
              else
              begin //004B9DA8
                nCheckCode := 57;
                SendMsg(BaseObject, RM_DEATH, BaseObject.m_btDirection,
                  BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0, '');
                nCheckCode := 58;
              end;
            end
            else
            begin //004B9DD3
              nCheckCode := 59;
              SendMsg(BaseObject, RM_TURN, BaseObject.m_btDirection,
                BaseObject.m_nCurrX, BaseObject.m_nCurrY, 0,
                BaseObject.GetShowName);
              nCheckCode := 60;
            end;
          end; //004B9E09
        end;
        Inc(n18);
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(format(sExceptionMsg2, [n24, m_sCharName, m_sMapName,
          m_nCurrX, m_nCurrY, nCheckCode]));
        {MainOutMessage(m_sCharName + ',' +
                       m_sMapName + ',' +
                       IntToStr(m_nCurrX) + ',' +
                       IntToStr(m_nCurrY) + ',' +
                       ' SearchViewRange 2');}
        KickException();
      end;
    end;
    try
      //    if (m_btRaceServer = RC_PLAYOBJECT) then begin
      I := 0;
      while (True) do
      begin
        if m_VisibleItems.Count <= I then
          break;
        VisibleMapItem := m_VisibleItems.Items[I];
        if VisibleMapItem.nVisibleFlag = 0 then
        begin
          SendMsg(Self, RM_ITEMHIDE, 0, Integer(VisibleMapItem.MapItem),
            VisibleMapItem.nX, VisibleMapItem.nY, '');
          m_VisibleItems.Delete(I);
          Dispose(VisibleMapItem);
          Continue;
        end; //004B9F6C
        if VisibleMapItem.nVisibleFlag = 2 then
        begin
          SendMsg(Self, RM_ITEMSHOW, VisibleMapItem.wLooks,
            Integer(VisibleMapItem.MapItem), VisibleMapItem.nX,
            VisibleMapItem.nY,
            VisibleMapItem.sName);
        end;
        Inc(I);
      end;
      I := 0;
      while (True) do
      begin
        if m_VisibleEvents.Count <= I then
          break;
        MapEvent := m_VisibleEvents.Items[I];

        if MapEvent.nVisibleFlag = 0 then
        begin
          SendMsg(Self, RM_HIDEEVENT, 0, Integer(MapEvent), MapEvent.m_nX,
            MapEvent.m_nY, '');
          m_VisibleEvents.Delete(I);
          Continue;
        end; //004BA053
        if MapEvent.nVisibleFlag = 2 then
        begin
          SendMsg(Self, RM_SHOWEVENT, MapEvent.m_nEventType, Integer(MapEvent),
            MakeLong(MapEvent.m_nX, MapEvent.m_nEventParam), MapEvent.m_nY, '');
        end;
        Inc(I);
      end;
      //    end;
    except
      MainOutMessage(m_sCharName + ',' +
        m_sMapName + ',' +
        IntToStr(m_nCurrX) + ',' +
        IntToStr(m_nCurrY) + ',' +
        ' SearchViewRange 3');

      KickException();
    end;
  except
    MainOutMessage('[Exception] TPlayObject.SearchViewRange');
  end;
end;

function TPlayObject.GetShowName: string;
var
  sShowName: string;
  sCharName: string;
  sGuildName: string;
  sDearName: string;
  sMasterName: string;
  Castle: TUserCastle;
  nCorpsIdx: Byte;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::GetShowName';
begin
  try
    try
      sCharName := '';
      sGuildName := '';
      sDearName := '';
      sMasterName := '';
      nCorpsIdx := 0;
      if m_UseItems[U_STRAW].wIndex > 0 then
      begin
        if (m_boHero and g_Config.boHeroShowMystery) or
          ((not m_boHero) and g_Config.boPlayShowMystery) then
        begin
          Result := '神秘人';
          m_OldShowName := Result;
          m_NewShowName := GetAddName(Result, nCorpsIdx);
          exit;
        end;
      end;
      if m_boHero then
      begin //英雄名称
        try
          sShowName := m_sCharName;
          if g_Config.bHeroShowMasterName then
          begin
            sShowName := sShowName + '\(' + m_HeroHuman.m_sCharName +
              g_Config.sHeroNameSuffix + ')';
          end;
          m_OldShowName := sShowName;
          m_NewShowName := GetAddName(sShowName, nCorpsIdx);
          Result := sShowName;
        except
        end;
        exit;
      end;

      if m_MyGuild <> nil then
      begin
        Castle := g_CastleManager.IsCastleMember(Self);
        {
        if UserCastle.IsMasterGuild(TGuild(m_MyGuild)) then begin
          sGuildName:=AnsiReplaceText(g_sCastleGuildName,'%castlename',UserCastle.m_sName);
          sGuildName:=AnsiReplaceText(sGuildName,'%guildname',TGuild(m_MyGuild).sGuildName);
          sGuildName:=AnsiReplaceText(sGuildName,'%rankname',m_sGuildRankName);
          }
        if Castle <> nil then
        begin
          nCorpsIdx := 1;
          sGuildName := AnsiReplaceText(g_sCastleGuildName, '%castlename',
            Castle.m_sName);
          sGuildName := AnsiReplaceText(sGuildName, '%guildname',
            TGuild(m_MyGuild).sGuildName);
          sGuildName := AnsiReplaceText(sGuildName, '%rankname',
            m_sGuildRankName);
          if IsGuildMaster then
            nCorpsIdx := 2;
        end
        else
        begin
          Castle := g_CastleManager.InCastleWarArea(Self);
          //01/25 多城堡
          //if g_Config.boShowGuildName or (UserCastle.m_boUnderWar and (m_boInFreePKArea or UserCastle.InCastleWarArea(m_PEnvir,m_nCurrX,m_nCurrY))) then begin
          if g_Config.boShowGuildName or (((Castle <> nil) and
            Castle.m_boUnderWar) or m_boInFreePKArea) then
          begin
            sGuildName := AnsiReplaceText(g_sNoCastleGuildName, '%guildname',
              TGuild(m_MyGuild).sGuildName);
            sGuildName := AnsiReplaceText(sGuildName, '%rankname',
              m_sGuildRankName);
          end;
        end;
      end;
      if not g_Config.boShowRankLevelName then
      begin
        if m_btReLevel > 0 then
        begin
          case m_btJob of
            jWarr: sCharName := AnsiReplaceText(g_sWarrReNewName, '%chrname',
                m_sCharName);
            jWizard: sCharName := AnsiReplaceText(g_sWizardReNewName,
                '%chrname', m_sCharName);
            jTaos: sCharName := AnsiReplaceText(g_sTaosReNewName, '%chrname',
                m_sCharName);
          end;
        end
        else
        begin
          sCharName := m_sCharName;
        end;
      end
      else
      begin
        sCharName := format(m_sRankLevelName, [m_sCharName]);
      end;

      if m_sMasterName <> '' then
      begin
        if m_boMaster then
        begin
          //sMasterName:= m_sMasterName + '的师傅';
          sMasterName := format(g_sMasterName, [m_sMasterName]);
        end
        else
        begin
          //sMasterName:= m_sMasterName + '的徒弟';
          sMasterName := format(g_sNoMasterName, [m_sMasterName]);
        end;
      end;
      if m_sDearName <> '' then
      begin
        if m_btGender = gMan then
        begin
          //sDearName:= m_sDearName + '的老公';
          sDearName := format(g_sManDearName, [m_sDearName]);
        end
        else
        begin
          sDearName := format(g_sWoManDearName, [m_sDearName]); // + '的老婆';
        end;
      end;

      sShowName := AnsiReplaceText(g_sHumanShowName, '%chrname', sCharName);
      sShowName := AnsiReplaceText(sShowName, '%guildname', sGuildName);
      sShowName := AnsiReplaceText(sShowName, '%dearname', sDearName);
      sShowName := AnsiReplaceText(sShowName, '%mastername', sMasterName);
      m_OldShowName := sShowName;
      m_NewShowName := GetAddName(sShowName, nCorpsIdx);
      Result := m_OldShowName;
      //if m_dwClientTickEx > 20070801 then Result:=sShowName+'|' + IntToStr(nCorpsIdx)
      //else Result:=sShowName;
    finally
      if m_Clone <> nil then
        m_Clone.RefShowName;
    end;
  except
    on e: Exception do
    begin
      MainOutMessage(sExceptionMsg);
      MainOutMessage(E.Message);
    end;
  end;
end;

function TPlayObject.CheckItemsNeed(StdItem: TItem): Boolean;
var
  Castle: TUserCastle;
begin
  try
    Result := True;
    Castle := g_CastleManager.IsCastleMember(Self);
    case StdItem.Need of
      6:
        begin
          if (m_MyGuild = nil) then
          begin
            Result := False;
          end;
        end;
      60:
        begin
          if (m_MyGuild = nil) or (m_nGuildRankNo <> 1) then
          begin
            Result := False;
          end;
        end;
      7:
        begin
          //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) then begin
          if Castle = nil then
          begin
            Result := False;
          end;
        end;
      70:
        begin
          //if (m_MyGuild = nil) or (UserCastle.m_MasterGuild <> m_MyGuild) or (m_nGuildRankNo <> 1) then begin
          if (Castle = nil) or (m_nGuildRankNo <> 1) then
          begin
            Result := False;
          end;
        end;
      8:
        begin
          if m_nMemberType = 0 then
            Result := False;
        end;
      81:
        begin
          if (m_nMemberType <> LoWord(StdItem.NeedLevel)) or (m_nMemberLevel <
            HiWord(StdItem.NeedLevel)) then
            Result := False;
        end;
      82:
        begin
          if (m_nMemberType < LoWord(StdItem.NeedLevel)) or (m_nMemberLevel <
            HiWord(StdItem.NeedLevel)) then
            Result := False;
        end;
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CheckItemsNeed');
  end;
end;

procedure TPlayObject.CheckMarry;
var
  boIsfound: Boolean;
  sUnMarryFileName: string;
  LoadList: TStringList;
  I: Integer;
  sSayMsg: string;
begin
  try
    boIsfound := False;
    sUnMarryFileName := g_Config.sEnvirDir + 'UnMarry.txt';
    if FileExists(sUnMarryFileName) then
    begin
      LoadList := TStringList.Create;
      LoadList.LoadFromFile(sUnMarryFileName);
      for I := 0 to LoadList.Count - 1 do
      begin
        if CompareText(LoadList.Strings[i], m_sCharName) = 0 then
        begin
          LoadList.Delete(i);
          boIsfound := True;
          break;
        end;
      end;
      LoadList.SaveToFile(sUnMarryFileName);
      LoadList.Free;
    end;
    if boIsfound then
    begin
      if m_btGender = gMan then
      begin
        sSayMsg := AnsiReplaceText(g_sfUnMarryManLoginMsg, '%d', m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sDearName);
      end
      else
      begin
        sSayMsg := AnsiReplaceText(g_sfUnMarryWoManLoginMsg, '%d', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
      end;
      SysMsg(sSayMsg, c_Red, t_Hint);
      m_sDearName := '';
      RefShowName;
    end;
    m_DearHuman := UserEngine.GeTPlayObject(m_sDearName);
    if m_DearHuman <> nil then
    begin
      m_DearHuman.m_DearHuman := Self;
      if m_btGender = gMan then
      begin
        sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineSelfMsg, '%d',
          m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m',
          m_DearHuman.m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x',
          IntToStr(m_DearHuman.m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y',
          IntToStr(m_DearHuman.m_nCurrY));
        SysMsg(sSayMsg, c_Blue, t_Hint);

        sSayMsg := AnsiReplaceText(g_sManLoginDearOnlineDearMsg, '%d',
          m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
      end
      else
      begin
        sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineSelfMsg, '%d',
          m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m',
          m_DearHuman.m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x',
          IntToStr(m_DearHuman.m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y',
          IntToStr(m_DearHuman.m_nCurrY));
        SysMsg(sSayMsg, c_Blue, t_Hint);

        sSayMsg := AnsiReplaceText(g_sWoManLoginDearOnlineDearMsg, '%d',
          m_sDearName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_DearHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
      end;
    end
    else
    begin
      if m_btGender = gMan then
      begin
        SysMsg(g_sManLoginDearNotOnlineMsg, c_Red, t_Hint);
      end
      else
      begin
        SysMsg(g_sWoManLoginDearNotOnlineMsg, c_Red, t_Hint);
      end;
    end;

  except
    MainOutMessage('[Exception] TPlayObject.CheckMarry');
  end;
end;

procedure TPlayObject.CheckMaster;
var
  boIsfound: Boolean;
  sSayMsg: string;
  I: Integer;
  Human: TPlayObject;
begin
  try
    //处理强行脱离师徒关系
    boIsfound := False;
    g_UnForceMasterList.Lock;
    try
      for I := 0 to g_UnForceMasterList.Count - 1 do
      begin
        if CompareText(g_UnForceMasterList.Strings[i], m_sCharName) = 0 then
        begin
          g_UnForceMasterList.Delete(i);
          SaveUnForceMasterList();
          boIsfound := True;
          break;
        end;
      end;
    finally
      g_UnForceMasterList.UnLock;
    end;

    if boIsfound then
    begin
      if m_boMaster then
      begin
        sSayMsg := AnsiReplaceText(g_sfUnMasterLoginMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
      end
      else
      begin
        sSayMsg := AnsiReplaceText(g_sfUnMasterListLoginMsg, '%d',
          m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sMasterName);
      end;
      SysMsg(sSayMsg, c_Red, t_Hint);
      m_sMasterName := '';
      RefShowName;
    end;

    if (m_sMasterName <> '') and not m_boMaster then
    begin
      if m_Abil.Level >= g_Config.nMasterOKLevel then
      begin
        Human := UserEngine.GeTPlayObject(m_sMasterName);
        if (Human <> nil) and (not Human.m_boDeath) and (not Human.m_boGhost)
          then
        begin
          Inc(Human.m_nMasterCount);
          Human.NpcGotoLable(g_FunctionNPC, '@MasterOK', False);
          {if (g_FunctionNPC <> nil) and (not m_boHero) then
            g_FunctionNPC.GotoLable(TPlayObject(Human),'@MasterOK',False);}

          sSayMsg := AnsiReplaceText(g_sYourMasterListUnMasterOKMsg, '%d',
            m_sCharName);
          Human.SysMsg(sSayMsg, c_Red, t_Hint);
          SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);

          //如果大徒弟则将师父上的名字去掉
          if m_sCharName = Human.m_sMasterName then
          begin
            Human.m_sMasterName := '';
            Human.RefShowName;
          end;
          for I := 0 to Human.m_MasterList.Count - 1 do
          begin
            if Human.m_MasterList.Items[I] = Self then
            begin
              Human.m_MasterList.Delete(I);
              break;
            end;
          end;

          m_sMasterName := '';
          RefShowName;
          if Human.m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Byte)
            then
          begin
            Inc(Human.m_btCreditPoint, g_Config.nMasterOKCreditPoint);
          end;
          Inc(Human.m_nBonusPoint, g_Config.nMasterOKBonusPoint);
          Human.SendMsg(Human, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
        end
        else
        begin
          //如果师父不在线则保存到记录表中
          g_UnMasterList.Lock;
          try
            boIsfound := False;
            for I := 0 to g_UnMasterList.Count - 1 do
            begin
              if CompareText(g_UnMasterList.Strings[i], m_sCharName) = 0 then
              begin
                boIsfound := True;
                break;
              end;
            end;
            if not boIsfound then
            begin
              g_UnMasterList.Add(m_sMasterName);
            end;
          finally
            g_UnMasterList.UnLock;
          end;
          if not boIsfound then
          begin
            SaveUnMasterList();
          end;
          SysMsg(g_sYouAreUnMasterOKMsg, c_Red, t_Hint);
          m_sMasterName := '';
          RefShowName;
        end;
      end;
    end;

    //处理出师记录
    boIsfound := False;
    g_UnMasterList.Lock;
    try
      for I := 0 to g_UnMasterList.Count - 1 do
      begin
        if CompareText(g_UnMasterList.Strings[i], m_sCharName) = 0 then
        begin
          g_UnMasterList.Delete(i);
          SaveUnMasterList();
          boIsfound := True;
          break;
        end;
      end;
    finally
      g_UnMasterList.UnLock;
    end;

    if boIsfound and m_boMaster then
    begin
      SysMsg(g_sUnMasterLoginMsg, c_Red, t_Hint);

      m_sMasterName := '';
      RefShowName;

      if m_btCreditPoint + g_Config.nMasterOKCreditPoint <= High(Byte) then
      begin
        Inc(m_btCreditPoint, g_Config.nMasterOKCreditPoint);
      end;
      Inc(m_nBonusPoint, g_Config.nMasterOKBonusPoint);
      SendMsg(Self, RM_ADJUST_BONUS, 0, 0, 0, 0, '');
    end;

    if m_sMasterName = '' then
      exit;
    if m_boMaster then
    begin
      //师父上线通知
      m_MasterHuman := UserEngine.GeTPlayObject(m_sMasterName);
      if m_MasterHuman <> nil then
      begin
        m_MasterHuman.m_MasterHuman := Self;
        m_MasterList.Add(m_MasterHuman);

        sSayMsg := AnsiReplaceText(g_sMasterOnlineSelfMsg, '%d', m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m',
          m_MasterHuman.m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x',
          IntToStr(m_MasterHuman.m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y',
          IntToStr(m_MasterHuman.m_nCurrY));
        SysMsg(sSayMsg, c_Blue, t_Hint);

        sSayMsg := AnsiReplaceText(g_sMasterOnlineMasterListMsg, '%d',
          m_sMasterName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
        sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
        sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
        sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
        m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
      end
      else
      begin
        SysMsg(g_sMasterNotOnlineMsg, c_Red, t_Hint);
      end;
    end
    else
    begin
      //徒弟上线通知
      if m_sMasterName <> '' then
      begin
        m_MasterHuman := UserEngine.GeTPlayObject(m_sMasterName);
        if m_MasterHuman <> nil then
        begin

          if m_MasterHuman.m_sMasterName = m_sCharName then
          begin
            m_MasterHuman.m_MasterHuman := Self;
          end;

          m_MasterHuman.m_MasterList.Add(Self);

          sSayMsg := AnsiReplaceText(g_sMasterListOnlineSelfMsg, '%d',
            m_sMasterName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m',
            m_MasterHuman.m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x',
            IntToStr(m_MasterHuman.m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y',
            IntToStr(m_MasterHuman.m_nCurrY));
          SysMsg(sSayMsg, c_Blue, t_Hint);

          sSayMsg := AnsiReplaceText(g_sMasterListOnlineMasterMsg, '%d',
            m_sMasterName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_MasterHuman.SysMsg(sSayMsg, c_Blue, t_Hint);
        end
        else
        begin
          SysMsg(g_sMasterListNotOnlineMsg, c_Red, t_Hint);
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CheckMaster');
  end;
end;

//离线挂机

function TPlayObject.MakeOffLine(): Boolean;
var
  I: integer;
begin
  if not m_boSafeOffLine then
  begin
    if ((g_Config.boSafeOffLine or m_boAutoOffLine) and InSafeZone) or
      (m_boNpcOffLine) then
    begin
      m_boSafeOffLine := True;
      if not m_boNpcOffLine then
      begin
        m_dwSafeOffLine := 0;
        m_nOffLineAddExp := 0;
        m_dwOffLineAddExpTick := GetTickCount;
      end;
      if g_Config.boSafeOffShop and m_boShop then
        ShopCancel;
      if g_Config.boSafeOffHero and (not m_boHero) and (m_Hero <> nil) then
        m_Hero.MakeGhost;
      if g_Config.boSafeOffSlave then
      begin
        for i := m_SlaveList.Count - 1 downto 0 do
        begin
          TBaseObject(m_SlaveList.Items[i]).MakeGhost;
        end;
      end;
      if m_GroupOwner <> nil then
        m_GroupOwner.DelMember(Self);
      m_boAllowGroup := False;
      UserEngine.AddOffLine(Self);
      UserEngine.SaveHumanRcd(Self);
      if m_boCheckOk and (g_Config.nCheckCount > 0) then
      begin
        m_nChickNpc := 0;
        m_nChangeMap := 0;
        m_nChangeMap2 := 0;
        m_nAttact := 0;
        m_boCheckOk := False;
        Dec(g_Config.nCheckCount);
      end;
    end;
  end;
  m_boNpcOffLine := False;
  Result := m_boSafeOffLine;
end;

procedure TPlayObject.MakeGhost;
var
  I: Integer;
  sSayMsg: string;
  Human: TPlayObject;
  UserItem: pTUserItem;
  Item: TItem;
  nCode: Byte;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::MakeGhost';
begin
  try
    if m_boCheckOk and (g_Config.nCheckCount > 0) then
      Dec(g_Config.nCheckCount);
    try
      nCode := 0;
      try
        nCode := 2;
        for I := Low(m_UseItems) to High(m_UseItems) do
        begin
          UserItem := @m_UseItems[I];
          if UserItem.wIndex > 0 then
          begin
            Item := UserEngine.GetStdItem(UserItem.wIndex);
            if Item <> nil then
            begin
              if Item.GhostDisap = 1 then
              begin
                UserItem.wIndex := 0;
              end
              else if Item.nRule[RULE_GHOST] then
              begin
                DropItemDown(UserItem, 1, True, nil, Self);
                UserItem.wIndex := 0;
              end;
            end;
          end;
        end;
        nCode := 3;
        for I := m_ItemList.Count - 1 downto 0 do
        begin
          UserItem := m_ItemList.Items[I];
          if UserItem <> nil then
          begin
            if UserItem.wIndex > 0 then
            begin
              Item := UserEngine.GetStdItem(UserItem.wIndex);
              if item <> nil then
              begin
                if Item.GhostDisap = 1 then
                begin
                  m_ItemList.Delete(I);
                  Dispose(UserItem);
                end
                else if Item.nRule[RULE_GHOST] then
                begin
                  DropItemDown(UserItem, 1, True, nil, Self);
                  m_ItemList.Delete(I);
                  Dispose(UserItem);
                end;
              end;
            end;
          end;
        end;
      except
        MainOutMessage('[Exception] TPlayObject::MakeGhost ' + IntToStr(nCode));
      end;

      //下线触发，支持英雄
      if (g_FunctionNPC <> nil) and (m_sOffLineFunc <> '') then
        g_FunctionNPC.GotoLable(Self, m_sOffLineFunc, False);

      if m_boHero then
      begin
        inherited;
        exit;
      end;

      if m_boSafeOffLine then
      begin
        UserEngine.DelOffLine(m_sCharName);
        m_boSafeOffLine := False;
      end;
      //NpcGotoLable(g_FunctionNPC,'@PlayOffLine',False);

      if (g_HighLevelHuman = Self) then
        g_HighLevelHuman := nil;
      if (g_HighPKPointHuman = Self) then
        g_HighPKPointHuman := nil;
      if (g_HighDCHuman = Self) then
        g_HighDCHuman := nil;
      if (g_HighMCHuman = Self) then
        g_HighMCHuman := nil;
      if (g_HighSCHuman = Self) then
        g_HighSCHuman := nil;
      if (g_HighOnlineHuman = Self) then
        g_HighOnlineHuman := nil;
      //人物下线后通知配偶，并把对方的相关记录清空
      if m_DearHuman <> nil then
      begin
        if m_btGender = gMan then
        begin
          sSayMsg := AnsiReplaceText(g_sManLongOutDearOnlineMsg, '%d',
            m_sDearName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        end
        else
        begin
          sSayMsg := AnsiReplaceText(g_sWoManLongOutDearOnlineMsg, '%d',
            m_sDearName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_DearHuman.SysMsg(sSayMsg, c_Red, t_Hint);
        end;
        m_DearHuman.m_DearHuman := nil;
        m_DearHuman := nil;
      end;
      if (m_MasterHuman <> nil) or (m_MasterList.Count > 0) then
      begin
        if m_boMaster then
        begin
          for I := 0 to m_MasterList.Count - 1 do
          begin
            Human := TPlayObject(m_MasterList.Items[I]);
            sSayMsg := AnsiReplaceText(g_sMasterLongOutMasterListOnlineMsg,
              '%s', m_sCharName);
            sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
            sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
            sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
            Human.SysMsg(sSayMsg, c_Red, t_Hint);
            Human.m_MasterHuman := nil;
          end;
        end
        else
        begin
          if m_MasterHuman = nil then
            exit;
          sSayMsg := AnsiReplaceText(g_sMasterListLongOutMasterOnlineMsg, '%d',
            m_sMasterName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%s', m_sCharName);
          sSayMsg := AnsiReplaceText(sSayMsg, '%m', m_PEnvir.sMapDesc);
          sSayMsg := AnsiReplaceText(sSayMsg, '%x', IntToStr(m_nCurrX));
          sSayMsg := AnsiReplaceText(sSayMsg, '%y', IntToStr(m_nCurrY));
          m_MasterHuman.SysMsg(sSayMsg, c_Red, t_Hint);

          //如果为大徒弟则将对方的记录清空
          if m_MasterHuman.m_sMasterName = m_sCharName then
          begin
            m_MasterHuman.m_MasterHuman := nil;
          end;

          for I := 0 to m_MasterHuman.m_MasterList.Count - 1 do
          begin
            if m_MasterHuman.m_MasterList.Items[I] = Self then
            begin
              m_MasterHuman.m_MasterList.Delete(I);
              break;
            end;
          end;
        end;
      end;
    except
      on e: Exception do
      begin
        MainOutMessage(sExceptionMsg + ' ' + BoolToStr(m_boHero));
        MainOutMessage(E.Message);
      end;

    end;
    inherited;
  except
    MainOutMessage('[Exception] TPlayObject.MakeGhost');
  end;
end;

function TPlayObject.GetSelfInfo(sMsg: string): string;
var
  sMyInfo: string;
begin
  try
    Result := '';
    sMyInfo := sMsg;
    sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
    sMyInfo := AnsiReplaceText(sMyInfo, '%s', m_sCharName);
    if m_PEnvir <> nil then
      sMyInfo := AnsiReplaceText(sMyInfo, '%map', m_PEnvir.sMapDesc)
    else
      sMyInfo := AnsiReplaceText(sMyInfo, '%map', '');
    if m_PEnvir <> nil then
      sMyInfo := AnsiReplaceText(sMyInfo, '%m', m_PEnvir.sMapDesc)
    else
      sMyInfo := AnsiReplaceText(sMyInfo, '%m', '');
    sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
    sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
    sMyInfo := AnsiReplaceText(sMyInfo, '%level', IntToStr(m_Abil.Level));
    sMyInfo := AnsiReplaceText(sMyInfo, '%gold', IntToStr(m_nGold));
    sMyInfo := AnsiReplaceText(sMyInfo, '%pk', IntToStr(m_nPkPoint));
    sMyInfo := AnsiReplaceText(sMyInfo, '%minhp', IntToStr(m_WAbil.HP));
    sMyInfo := AnsiReplaceText(sMyInfo, '%maxhp', IntToStr(m_WAbil.MaxHP));
    sMyInfo := AnsiReplaceText(sMyInfo, '%minmp', IntToStr(m_WAbil.MP));
    sMyInfo := AnsiReplaceText(sMyInfo, '%maxmp', IntToStr(m_WAbil.MaxMP));
    sMyInfo := AnsiReplaceText(sMyInfo, '%mindc', IntToStr(LoWord(m_WAbil.DC)));
    sMyInfo := AnsiReplaceText(sMyInfo, '%maxdc', IntToStr(HiWord(m_WAbil.DC)));
    sMyInfo := AnsiReplaceText(sMyInfo, '%minmc', IntToStr(LoWord(m_WAbil.MC)));
    sMyInfo := AnsiReplaceText(sMyInfo, '%maxmc', IntToStr(HiWord(m_WAbil.MC)));
    sMyInfo := AnsiReplaceText(sMyInfo, '%minsc', IntToStr(LoWord(m_WAbil.SC)));
    sMyInfo := AnsiReplaceText(sMyInfo, '%maxsc', IntToStr(HiWord(m_WAbil.SC)));
    sMyInfo := AnsiReplaceText(sMyInfo, '%logontime',
      DateTimeToStr(m_dLogonTime));
    sMyInfo := AnsiReplaceText(sMyInfo, '%logonlong', IntToStr((GetTickCount -
      m_dwLogonTick) div 60000));
    Result := sMyInfo;
  except
    MainOutMessage('[Exception] TPlayObject.GetSelfInfo');
  end;
end;

function TPlayObject.GetMyInfo: string;
var
  sMyInfo: string;
begin
  try
    try
      sMyInfo := g_sMyInfo;
      sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
      if m_PEnvir <> nil then
        sMyInfo := AnsiReplaceText(sMyInfo, '%map', m_PEnvir.sMapDesc)
      else
        sMyInfo := AnsiReplaceText(sMyInfo, '%map', '????');
      sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
      sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
      sMyInfo := AnsiReplaceText(sMyInfo, '%level', IntToStr(m_Abil.Level));
      sMyInfo := AnsiReplaceText(sMyInfo, '%gold', IntToStr(m_nGold));
      sMyInfo := AnsiReplaceText(sMyInfo, '%pk', IntToStr(m_nPkPoint));
      sMyInfo := AnsiReplaceText(sMyInfo, '%minhp', IntToStr(m_WAbil.HP));
      sMyInfo := AnsiReplaceText(sMyInfo, '%maxhp', IntToStr(m_WAbil.MaxHP));
      sMyInfo := AnsiReplaceText(sMyInfo, '%minmp', IntToStr(m_WAbil.MP));
      sMyInfo := AnsiReplaceText(sMyInfo, '%maxmp', IntToStr(m_WAbil.MaxMP));
      sMyInfo := AnsiReplaceText(sMyInfo, '%mindc',
        IntToStr(LoWord(m_WAbil.DC)));
      sMyInfo := AnsiReplaceText(sMyInfo, '%maxdc',
        IntToStr(HiWord(m_WAbil.DC)));
      sMyInfo := AnsiReplaceText(sMyInfo, '%minmc',
        IntToStr(LoWord(m_WAbil.MC)));
      sMyInfo := AnsiReplaceText(sMyInfo, '%maxmc',
        IntToStr(HiWord(m_WAbil.MC)));
      sMyInfo := AnsiReplaceText(sMyInfo, '%minsc',
        IntToStr(LoWord(m_WAbil.SC)));
      sMyInfo := AnsiReplaceText(sMyInfo, '%maxsc',
        IntToStr(HiWord(m_WAbil.SC)));
      sMyInfo := AnsiReplaceText(sMyInfo, '%logontime',
        DateTimeToStr(m_dLogonTime));
      sMyInfo := AnsiReplaceText(sMyInfo, '%logonlong', IntToStr((GetTickCount -
        m_dwLogonTick) div 60000));
      Result := sMyInfo;
    except
      MainOutMessage('[Exception] TPlayObject.GetMyInfo ' +
        IntToHex(Integer(Self), 2));
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetMyInfo:');
  end;
end;

function TPlayObject.CheckItemBindUse(UserItem: pTUserItem): Boolean;
var
  I: Integer;
  ItemBind: pTItemBind;
begin
  try
    Result := True;
    g_ItemBindAccount.Lock;
    try
      for I := 0 to g_ItemBindAccount.Count - 1 do
      begin
        ItemBind := g_ItemBindAccount.Items[I];
        if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
          (ItemBind.nItemIdx = UserItem.wIndex) then
        begin
          Result := False;
          if (CompareText(ItemBind.sBindName, m_sUserID) = 0) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sItemIsNotThisAccount, c_Red, t_Hint);
          end;
          exit;
        end;
      end;
    finally
      g_ItemBindAccount.UnLock;
    end;

    g_ItemBindIPaddr.Lock;
    try
      for I := 0 to g_ItemBindIPaddr.Count - 1 do
      begin
        ItemBind := g_ItemBindIPaddr.Items[I];
        if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
          (ItemBind.nItemIdx = UserItem.wIndex) then
        begin
          Result := False;
          if (CompareText(ItemBind.sBindName, m_sIPaddr) = 0) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sItemIsNotThisIPaddr, c_Red, t_Hint);
          end;
          exit;
        end;
      end;
    finally
      g_ItemBindIPaddr.UnLock;
    end;
    g_ItemBindCharName.Lock;
    try
      for I := 0 to g_ItemBindCharName.Count - 1 do
      begin
        ItemBind := g_ItemBindCharName.Items[I];
        if (ItemBind.nMakeIdex = UserItem.MakeIndex) and
          (ItemBind.nItemIdx = UserItem.wIndex) then
        begin
          Result := False;
          if (CompareText(ItemBind.sBindName, m_sCharName) = 0) then
          begin
            Result := True;
          end
          else
          begin
            SysMsg(g_sItemIsNotThisCharName, c_Red, t_Hint);
          end;
          exit;
        end;
      end;
    finally
      g_ItemBindCharName.UnLock;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CheckItemBindUse');
  end;
end;

procedure TPlayObject.ProcessClientPassword(ProcessMsg: pTProcessMessage);
var
  nLen: Integer;
  sData: string;
begin
  try
    //  SysMsg(ProcessMsg.sMsg,c_Red,t_Hint);
    if ProcessMsg.wParam = 0 then
    begin
      ProcessUserLineMsg('@' + g_GameCommand.UNLOCK.sCmd);
      exit;
    end;

    sData := ProcessMsg.sMsg;
    nLen := length(sData);
    if m_boSetStoragePwd then
    begin
      m_boSetStoragePwd := False;
      if (nLen > 3) and (nLen < 8) then
      begin
        m_sTempPwd := sData;
        m_boReConfigPwd := True;
        SysMsg(g_sReSetPasswordMsg, c_Green, t_Hint);
        {'请重复输入一次仓库密码：'}
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
      end
      else
      begin
        SysMsg(g_sPasswordOverLongMsg, c_Red, t_Hint);
        {'输入的密码长度不正确！！！，密码长度必须在 4 - 7 的范围内，请重新设置密码。'}
      end;
      exit;
    end;
    if m_boReConfigPwd then
    begin
      m_boReConfigPwd := False;
      if CompareStr(m_sTempPwd, sData) = 0 then
      begin
        m_sStoragePwd := sData;
        m_boPasswordLocked := True;
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordOKMsg, c_Blue, t_Hint);
        {'密码设置成功！！，仓库已经自动上锁，请记好您的仓库密码，在取仓库时需要使用此密码开锁。'}
      end
      else
      begin
        m_sTempPwd := '';
        SysMsg(g_sReSetPasswordNotMatchMsg, c_Red, t_Hint);
      end;
      exit;
    end;
    if m_boUnLockPwd or m_boUnLockStoragePwd then
    begin
      if CompareStr(m_sStoragePwd, sData) = 0 then
      begin
        m_boPasswordLocked := False;
        if m_boUnLockPwd then
        begin
          if g_Config.boLockDealAction then
            m_boCanDeal := True;
          if g_Config.boLockDropAction then
            m_boCanDrop := True;
          if g_Config.boLockWalkAction then
            m_boCanWalk := True;
          if g_Config.boLockRunAction then
            m_boCanRun := True;
          if g_Config.boLockHitAction then
            m_boCanHit := True;
          if g_Config.boLockSpellAction then
            m_boCanSpell := True;
          if g_Config.boLockSendMsgAction then
            m_boCanSendMsg := True;
          if g_Config.boLockUserItemAction then
            m_boCanUseItem := True;
          if g_Config.boLockInObModeAction then
          begin
            m_boObMode := False;
            m_boAdminMode := False;
          end;
          m_boLockLogoned := True;
          SysMsg(g_sPasswordUnLockOKMsg, c_Blue, t_Hint);
        end;
        if m_boUnLockStoragePwd then
        begin
          if g_Config.boLockGetBackItemAction then
            m_boCanGetBackItem := True;
          SysMsg(g_sStorageUnLockOKMsg, c_Blue, t_Hint);
        end;

      end
      else
      begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sUnLockPasswordFailMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
        end;
      end;
      m_boUnLockPwd := False;
      m_boUnLockStoragePwd := False;
      exit;
    end;

    if m_boCheckOldPwd then
    begin
      m_boCheckOldPwd := False;
      if m_sStoragePwd = sData then
      begin
        SendMsg(Self, RM_PASSWORD, 0, 0, 0, 0, '');
        SysMsg(g_sSetPasswordMsg, c_Green, t_Hint);
        m_boSetStoragePwd := True;
      end
      else
      begin
        Inc(m_btPwdFailCount);
        SysMsg(g_sOldPasswordIncorrectMsg, c_Red, t_Hint);
        if m_btPwdFailCount > 3 then
        begin
          SysMsg(g_sStoragePasswordLockedMsg, c_Red, t_Hint);
          m_boPasswordLocked := True;
        end;
      end;
      exit;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ProcessClientPassword');
  end;
end;

procedure TPlayObject.ScatterBagItems(ItemOfCreat: TBaseObject);
const
  DropWide: Integer = 2;
var
  i: Integer;
  pu: pTUserItem;
  DelList: TStringList;
  boDropall: Boolean;
  StdItem: TItem;
resourcestring
  sExceptionMsg = '[Exception] TPlayObject::ScatterBagItems';
begin
  try
    DelList := nil;
    if m_boAngryRing or m_boNoDropItem or m_PEnvir.Flag.boNODROPITEM then
      exit; //不死戒指

    boDropall := False;
    if g_Config.boDieRedScatterBagAll and (PKLevel >= 2) then
    begin
      boDropall := True;
    end;

    //非红名掉1/3 //红名全掉

    try
      for i := m_ItemList.Count - 1 downto 0 do
      begin
        if boDropall or (Random(g_Config.nDieScatterBagRate {3}) = 0) then
        begin
          pu := pTUserItem(m_ItemList[i]);
          StdItem := UserEngine.GetStdItem(pu.wIndex);
          if (StdItem <> nil) and (StdItem.nRule[RULE_NODROP] or
            StdItem.nRule[RULE_DROPDOWN]) then
            Continue;
          if CheckItemState(pu, ITEMSTATE_SCATTER, False) then
            Continue;
          if DropItemDown(pu, DropWide, True, ItemOfCreat, Self) then
          begin
            if m_btRaceServer = RC_PLAYOBJECT then
            begin
              if DelList = nil then
                DelList := TStringList.Create;
              DelList.AddObject(UserEngine.GetStdItemName(pu.wIndex),
                TObject(pu.MakeIndex));
            end;
            Dispose(pTUserItem(m_ItemList[i]));
            m_ItemList.Delete(i);
          end;
        end;
      end;
      if DelList <> nil then
      begin
        SendMsg(self, RM_SENDDELITEMLIST, 0, Integer(DelList), 0, 0, '');
      end;
    except
      MainOutMessage(sExceptionMsg);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ScatterBagItems');
  end;
end;

procedure TPlayObject.DelBagItemEx(MakeIdx: Integer; LogIdx: Byte);
var
  i: Integer;
  UserItem: PTUserItem;
  StdItem: TItem;
begin
  try
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem.MakeIndex = MakeIdx then
      begin
        StdItem := UserEngine.GetStdItem(UserItem.wIndex);
        if StdItem.NeedIdentify = 1 then
          AddGameDataLog(IntToStr(LogIdx) + #9 +
            m_sMapName + #9 +
            IntToStr(m_nCurrX) + #9 +
            IntToStr(m_nCurrY) + #9 +
            m_sCharName + #9 +
            StdItem.Name + #9 +
            IntToStr(UserItem.MakeIndex) + #9 +
            '1' + #9 +
            '0');
        Dispose(UserItem);
        m_ItemList.Delete(I);
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.DelBagItemEx');
  end;
end;

procedure TPlayObject.ClientOpenItem();
var
  UserItem: pTUserItem;
  StdItem: TItem;
  dwInt, nExp: Integer;
  sMyInfo: string;
begin
  try
    if OpenBoxGetItem.S.Name <> '' then
    begin
      if OpenBoxGetItem.S.StdMode = 255 then
      begin
        if CompareStr(OpenBoxGetItem.S.Name, GAMEEXPNAME) = 0 then
        begin
          nExp := OpenBoxGetItem.S.DuraMax;
          if m_Abil.Exp >= LongWord(nExp) then
          begin
            if (m_Abil.Exp - LongWord(nExp)) > (High(LongWord) - m_Abil.Exp)
              then
            begin
              dwInt := High(LongWord) - m_Abil.Exp;
            end
            else
            begin
              dwInt := LongWord(nExp);
            end;
          end
          else
          begin
            if (LongWord(nExp) - m_Abil.Exp) > (High(LongWord) - LongWord(nExp))
              then
            begin
              dwInt := High(LongWord) - LongWord(nExp);
            end
            else
            begin
              dwInt := LongWord(nExp);
            end;
          end;
          GetExp(dwInt);
          SysMsg(Format('恭喜：获得经验值:%d', [dwInt]), c_Red,
            t_System);
        end
        else if CompareStr(OpenBoxGetItem.S.Name, GAMECREDITPOINT) = 0 then
        begin
          nExp := OpenBoxGetItem.S.DuraMax;
          {if (m_btCreditPoint + nExp) > High(Integer) then begin
            m_btCreditPoint:=High(Integer);
          end else begin}
          Inc(m_btCreditPoint, nExp);
          if m_btCreditPoint < 0 then
            m_btCreditPoint := 0;
          //end;
          SysMsg(Format('恭喜：获得声望点:%d，你当前声望点为:%d',
            [nExp, m_btCreditPoint]), c_Red, t_System);
        end
        else if CompareStr(OpenBoxGetItem.S.Name, GAMEDIAMOND) = 0 then
        begin
          nExp := OpenBoxGetItem.S.DuraMax;
          {if m_nGameDiamond + nExp > High(Integer) then begin
            m_nGameDiamond:=High(Integer);
          end else begin}
          Inc(m_nGameDiamond, nExp);
          if m_nGameDiamond < 0 then
            m_nGameDiamond := 0;
          //end;
          RefDiamondGird;
          SysMsg(Format('恭喜：获得金刚石:%d，你当前金刚石为:%d',
            [nExp, m_nGameDiamond]), c_Red, t_System);
        end;
      end
      else
      begin
        New(userItem);
        if UserEngine.CopyToUserItemFromName(OpenBoxGetItem.S.Name, UserItem)
          then
        begin
          if AddItemToBag(UserItem) then
          begin
            SendAddItem(UserItem);
            StdItem := UserEngine.GetStdItem(UserItem.wIndex);
            if (StdItem <> nil) then
            begin
              if StdItem.NeedIdentify = 1 then //004C60FF
                AddGameDataLog(IntToStr(LOG_OPENBOXITEM) + #9 +
                  m_sMapName + #9 +
                  IntToStr(m_nCurrX) + #9 +
                  IntToStr(m_nCurrY) + #9 +
                  m_sCharName + #9 +
                  //UserEngine.GetStdItemName(pu.wIndex) + #9 +
                  StdItem.Name + #9 +
                  IntToStr(UserItem.MakeIndex) + #9 +
                  '0' + #9 +
                  '0');
              SysMsg(Format('恭喜：获得物品[%s]', [StdItem.Name]), c_Red,
                t_System);
              if StdItem.nRule[RULE_BOXS] then
              begin
                sMyInfo := sBoxsItemHintMsg;
                sMyInfo := AnsiReplaceText(sMyInfo, '%s', Stditem.Name);
                sMyInfo := AnsiReplaceText(sMyInfo, '%name', m_sCharName);
                sMyInfo := AnsiReplaceText(sMyInfo, '%m', m_PEnvir.sMapDesc);
                sMyInfo := AnsiReplaceText(sMyInfo, '%x', IntToStr(m_nCurrX));
                sMyInfo := AnsiReplaceText(sMyInfo, '%y', IntToStr(m_nCurrY));
                UserEngine.SendBroadCastMsgExt(sMyInfo, t_System);
              end;
            end;
          end
          else
            Dispose(UserItem);
        end
        else
          Dispose(UserItem);
      end;
      FillChar(OpenBoxItem, SizeOf(OpenBoxItem), #0);
      FillChar(OpenBoxGetItem, SizeOf(TClientItem), #0);
      FillChar(OpenBoxsSet, SizeOf(TBoxsSet), #0);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientOpenItem');
  end;
end;

procedure TPlayObject.ClientOpenMove();
var
  i, Idx: integer;
  List: TList;
  boAll: Boolean;
begin
  try

    List := TList.Create;
    List.Clear;
    try
      if m_boOpenBox then
      begin
        m_boOpenBox := False;
        for i := Low(OpenBoxItem) to High(OpenBoxItem) - 1 do
        begin
          if OpenBoxItem[I].S.Name <> '' then
          begin
            if not (OpenBoxItem[I].MakeIndex in [1, 2, 3]) then
              List.Add(Pointer(I));
          end;
        end;
      end
      else
      begin
        if OpenBoxsSet.boNext and
          (m_nGold >= OpenBoxsSet.nNowGold) and
          (m_nGameGold >= OpenBoxsSet.nNowGameGold) then
        begin
          Dec(m_nGold, OpenBoxsSet.nNowGold);
          Dec(m_nGameGold, OpenBoxsSet.nNowGameGold);
          boAll := False;
          if (OpenBoxsSet.nNowGold >= OpenBoxsSet.nEndGold) and
            (OpenBoxsSet.nNowGameGold >= OpenBoxsSet.nEndGameGold) then
            boAll := True;
          for i := Low(OpenBoxItem) to High(OpenBoxItem) - 1 do
          begin
            if OpenBoxItem[I].S.Name <> '' then
            begin
              if (not (OpenBoxItem[I].MakeIndex in [1, 2, 3])) or (boAll and
                (not (OpenBoxItem[I].MakeIndex in [2, 3]))) then
                List.Add(Pointer(I));
            end;
          end;
          GoldChanged;
        end;
      end;
      if List.Count > 0 then
      begin
        Idx := Integer(List.Items[Random(List.Count)]);
        if not (Idx in [0..7]) then
          Idx := 0;
        OpenBoxGetItem := OpenBoxItem[Idx];
        if (OpenBoxsSet.boNext) and (OpenBoxsSet.nNowCount < OpenBoxsSet.nCount)
          then
        begin
          OpenBoxsSet.nNowGold := Integer(OpenBoxsSet.nGold +
            OpenBoxsSet.nAddGold * OpenBoxsSet.nNowCount);
          OpenBoxsSet.nNowGameGold := Integer(OpenBoxsSet.nGameGold +
            OpenBoxsSet.nAddGameGold * OpenBoxsSet.nNowCount);
          Inc(OpenBoxsSet.nNowCount);
          SendDefMessage(SM_OPENARK_MOVE, OpenBoxsSet.nNowGold,
            LoWord(OpenBoxsSet.nNowGameGold), HiWord(OpenBoxsSet.nNowGameGold),
            Idx, '');
        end
        else
        begin
          OpenBoxsSet.boNext := False;
          SendDefMessage(SM_OPENARK_MOVE, 0, 0, 0, Idx, '');
        end;
      end;
    finally
      List.Free;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientOpenMove');
  end;
end;

procedure TPlayObject.ClientOpenArkEx(nItemIdx, KeyIdx: integer);
var
  i: integer;
  UserItem, ArkItem, KeyItem: pTUserItem;
  Ark, Key: TItem;
  //n14,n15:integer;
  sSendMsg: string;
  Idx, Count: Integer;
  boAdd: Boolean;
begin
  try
    //UserItem:=nil;
    ArkItem := nil;
    KeyItem := nil;
    //n14:=-1;
    //n15:=-1;
    FillChar(OpenBoxItem, SizeOf(OpenBoxItem), #0);
    FillChar(OpenBoxGetItem, SizeOf(TClientItem), #0);
    FillChar(OpenBoxsSet, SizeOf(TBoxsSet), #0);
    m_boOpenBox := False;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[i];
      if UserItem <> nil then
      begin
        if UserItem.MakeIndex = nItemIdx then
        begin
          ArkItem := UserItem;
          //n14:=I;
        end
        else if UserItem.MakeIndex = KeyIdx then
        begin
          KeyItem := UserItem;
          //n15:=I;
        end;
        if (ArkItem <> nil) and (KeyItem <> nil) then
          break;
      end;
      //UserItem:=nil;
    end;
    sSendMsg := '';
    if (ArkItem <> nil) and (KeyItem <> nil) then
    begin
      Ark := UserEngine.GetStdItem(ArkItem.wIndex);
      Key := UserEngine.GetStdItem(KeyItem.wIndex);
      if (Ark.StdMode = 48) and
        (Key.StdMode = 49) and
        (Ark.AniCount = Key.Shape) then
      begin
        boAdd := False;
        for I := Low(OpenBoxItem) to High(OpenBoxItem) - 2 do
        begin
          Count := 0;
          while True do
          begin
            if Count > 50 then
              Break;
            Idx := Random(3);
            if Idx = 0 then
              boAdd := True;
            GetBoxsItem(Ark.Source, Idx, OpenBoxItem[I]);
            if OpenBoxItem[I].S.Name <> '' then
              break;
            Inc(Count);
          end;
          sSendMsg := sSendMsg + MakeBoxClientItem(OpenBoxItem[I]) + '/';
        end;
        if boAdd then
          GetBoxsItem(Ark.Source, Random(3), OpenBoxItem[7])
        else
          GetBoxsItem(Ark.Source, 0, OpenBoxItem[7]);
        if OpenBoxItem[7].S.Name <> '' then
        begin
          sSendMsg := sSendMsg + MakeBoxClientItem(OpenBoxItem[7]) + '/';
          DelBagItemEx(ArkItem.MakeIndex, 11);
          DelBagItemEx(KeyItem.MakeIndex, 11);
          OpenBoxsSet := GetBoxsItem(Ark.Source, 3, OpenBoxItem[8]);
          OpenBoxGetItem := OpenBoxItem[8];
          m_boOpenBox := True;
          sSendMsg := sSendMsg + MakeBoxClientItem(OpenBoxItem[8]) + '/';

          m_DefMsg := MakeDefaultMsg(SM_OPENARK_ITEM, 0, 0, 0, 0);
          SendSocket(@m_DefMsg, sSendMsg);
        end;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientOpenArkEx');
  end;
end;

procedure TPlayObject.ClientOpenArk(nItemIdx, KeyIdx: integer);
var
  i: integer;
  UserItem, ArkItem, KeyItem: pTUserItem;
  Ark, Key: TItem;
  n14, n15: integer;
  boOpen: Boolean;
begin
  try
    try
      //UserItem:=nil;
      ArkItem := nil;
      KeyItem := nil;
      n14 := -1;
      n15 := -1;
      boOpen := False;
      for I := 0 to m_ItemList.Count - 1 do
      begin
        UserItem := m_ItemList.Items[i];
        if UserItem <> nil then
        begin
          if UserItem.MakeIndex = nItemIdx then
          begin
            ArkItem := UserItem;
            n14 := I;
          end
          else if UserItem.MakeIndex = KeyIdx then
          begin
            KeyItem := UserItem;
            n15 := I;
          end;
          if (n14 >= 0) and (n15 >= 0) then
            break;
        end;
        //UserItem:=nil;
      end;

      if (ArkItem <> nil) and (KeyItem <> nil) then
      begin
        Ark := UserEngine.GetStdItem(ArkItem.wIndex);
        Key := UserEngine.GetStdItem(KeyItem.wIndex);
        if (Ark.StdMode = 48) and
          (Key.StdMode = 49) and
          (Ark.Shape = Key.Shape) then
        begin
          if UseStdmodeFunItem(Ark) then
          begin //使用物品脚本触发
            boOpen := True;
            DelBagItemEx(ArkItem.MakeIndex, 11);
            DelBagItemEx(KeyItem.MakeIndex, 11);
          end;
        end;
      end;

      if boOpen then
        SendDefMessage(SM_OPENARK_OK, 0, 0, 0, 0, '')
      else
        SendDefMessage(SM_OPENARK_FAIL, 0, 0, 0, 0, '');
    except
      MainOutMessage('[Exception] TPlayObject.ClientOpenArk');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientOpenArk');
  end;
end;

procedure TPlayObject.ClientLevelItem(nItemIdx, BijobIdx, BijobIdx2: integer);
var
  {sName,}GoldName, sMsg: string;
  I, nTack, nCheck: integer;
  UserItem, LevelItem, BijobItem, BijboItem2: pTUserItem;
  nCode, ItemType: Byte;
  boLevel, boVanish: Boolean;
  Level: TItem;
  pLevel, pBijob, pBijbo2: TItem;
  TempByte, nTGameGold, nTGold: Integer;
  boChange: Boolean;
  //  NormNpc:TNormNpc;
begin
  try
    LevelItem := nil;
    BijobItem := nil;
    BijboItem2 := nil;
    pBijbo2 := nil;
    //  Level:=Nil;
    boLevel := False;
    nCode := 0; //未找到升级所需物品
    nTack := 0;
    boVanish := False;
    for I := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if UserItem <> nil then
      begin
        if UserItem.MakeIndex = nItemIdx then
        begin
          LevelItem := UserItem;
        end
        else if UserItem.MakeIndex = BijobIdx then
        begin
          BijobItem := UserItem;
        end
        else if UserItem.MakeIndex = BijobIdx2 then
        begin
          BijboItem2 := UserItem;
        end;
      end;
    end;
    if (LevelItem <> nil) and (BijobItem <> nil) then
    begin
      pLevel := UserEngine.GetStdItem(LevelItem.wIndex);
      pBijob := UserEngine.GetStdItem(BijobItem.wIndex);
      if (pLevel <> nil) and (pBijob <> nil) then
      begin
        nCode := 1; //该装备不允许升级
        Level := UserEngine.GetStdItem(LevelItem.wIndex);
        if Level.LevelItem = 1 then
        begin
          nCode := 2; //升级装备与宝石不配套
          //Bijob:=TItemUnit_GetItem(BijobItem.wIndex);
          if BijboItem2 <> nil then
          begin
            //Bijbo2:=TItemUnit_GetItem(BijboItem2.wIndex);
            pBijbo2 := UserEngine.GetStdItem(BijboItem2.wIndex);
            if pBijbo2 <> nil then
              nTack := _Max(0, pBijbo2.DuraMax div 10);
          end;
          ItemType := Level.ItemType;
          if ((pBijbo2 = nil) or (pBijbo2 <> nil) and (pBijbo2.StdMode = 57))
            and
            (LevelItem.btValue[14] >= HiWord(pBijob.Need)) and
            (((ItemType<>ITEM_WEAPON) and ((LevelItem.btValue[14]+Level.Reserved)< LoWord(pBijob.Need))) or
            ((ItemType=ITEM_WEAPON) and (LevelItem.btValue[14]< LoWord(pBijob.Need))) or
            ((HiWord(pBijob.Need) > 0) and (ItemType<>ITEM_WEAPON) and ((LevelItem.btValue[14]+Level.Reserved)=LoWord(pBijob.Need))) or
            ((HiWord(pBijob.Need) > 0) and (ItemType=ITEM_WEAPON) and (LevelItem.btValue[14]=LoWord(pBijob.Need)))) then
          begin
            if ((pBijob.StdMode = 58) and (pLevel.StdMode = pBijob.Shape)) or
              ((pBijob.StdMode = 55) and (pBijob.Source = 0) and (pLevel.StdMode
              = pBijob.Shape)) or
              ((pBijob.StdMode = 55) and (pBijob.Source = 1) and (ItemType =
              ITEM_ARMOR) and ((pBijob.Shape = 0) or (pLevel.StdMode =
              pBijob.Shape))) or
              ((pBijob.StdMode = 55) and (pBijob.Source = 2) and ((pBijob.Shape
              = 0) or (pLevel.StdMode = pBijob.Shape))) or
              ((pBijob.StdMode = 56) and ((pBijob.Shape = 0) or (pLevel.StdMode
              = pBijob.Shape))) then
            begin
              nTGameGold := g_Config.nLevelItemGameGoldCount;
              nTGold := g_Config.nLevelItemGoldCount;
              boChange := False;
              GoldName := g_Config.sGameGoldName;
              if (nTGameGold > 0) then
              begin
                if m_nGameGold < nTGameGold then
                begin
                  sMsg := '[升级失败]：你身上的[' + GoldName +
                    ']不够本次升级，本次升级需要[' +
                    IntToStr(nTGameGold) + ']点';
                  SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, sMsg);
                  exit;
                end
                else
                begin
                  Dec(m_nGameGold, nTGameGold);
                  boChange := True;
                end;
              end;
              if (nTGold > 0) then
              begin
                if m_nGold < nTGold then
                begin
                  sMsg := '[升级失败]：你身上的[游戏币]不够本次升级，本次升级需要['
                    + IntToStr(nTGold) + ']点';
                  SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0, sMsg);
                  exit;
                end
                else
                begin
                  Dec(m_nGold, nTGold);
                  boChange := True;
                end;
              end;
              if boChange then
                GoldChanged;
              nCheck := nTack + _Max(0, pBijob.DuraMax div 10);

              if (Random(10) - nCheck) < 0 then
              begin //升级成功
                if LevelItem.btValue[14] < High(Byte) then
                  Inc(LevelItem.btValue[14]); //增加升级记录
                boLevel := True;
                if (pBijob.StdMode in [55, 58]) and (pBijob.Source = 0) then
                begin //固定加属性
                  case ItemType of
                    ITEM_WEAPON:
                      begin
                        Inc(LevelItem.btValue[3], _MIN(High(Byte) -
                          LevelItem.btValue[3], pBijob.AC));
                        Inc(LevelItem.btValue[5], _MIN(High(Byte) -
                          LevelItem.btValue[5], pBijob.AC2));
                        Inc(LevelItem.btValue[4], _MIN(High(Byte) -
                          LevelItem.btValue[4], pBijob.MAC));
                        Inc(LevelItem.btValue[6], _MIN(High(Byte) -
                          LevelItem.btValue[6], pBijob.MAC2));
                        Inc(LevelItem.btValue[0], _MIN(High(Byte) -
                          LevelItem.btValue[0], pBijob.DC2));
                        Inc(LevelItem.btValue[1], _MIN(High(Byte) -
                          LevelItem.btValue[1], pBijob.MC2));
                        Inc(LevelItem.btValue[2], _MIN(High(Byte) -
                          LevelItem.btValue[2], pBijob.SC2));
                      end;
                  else
                    begin
                      Inc(LevelItem.btValue[0], _MIN(High(Byte) -
                        LevelItem.btValue[0], pBijob.AC2));
                      Inc(LevelItem.btValue[1], _MIN(High(Byte) -
                        LevelItem.btValue[1], pBijob.MAC2));
                      Inc(LevelItem.btValue[2], _MIN(High(Byte) -
                        LevelItem.btValue[2], pBijob.DC2));
                      Inc(LevelItem.btValue[3], _MIN(High(Byte) -
                        LevelItem.btValue[3], pBijob.MC2));
                      Inc(LevelItem.btValue[4], _MIN(High(Byte) -
                        LevelItem.btValue[4], pBijob.SC2));
                    end;
                  end;
                end
                else if (pBijob.StdMode = 55) and
                  (pBijob.Source = 1) then
                begin
                  case ItemType of
                    ITEM_ARMOR:
                      begin
                        Inc(LevelItem.btValue[0], _MIN(High(Byte) -
                          LevelItem.btValue[0], pBijob.AC2));
                        Inc(LevelItem.btValue[1], _MIN(High(Byte) -
                          LevelItem.btValue[1], pBijob.MAC2));
                      end;
                  end;
                end
                else if (pBijob.StdMode = 55) and (pBijob.Source = 2) then
                begin
                  case ItemType of
                    ITEM_WEAPON:
                      begin
                        Inc(LevelItem.btValue[0], _MIN(High(Byte) -
                          LevelItem.btValue[0], pBijob.DC2));
                        Inc(LevelItem.btValue[1], _MIN(High(Byte) -
                          LevelItem.btValue[1], pBijob.MC2));
                        Inc(LevelItem.btValue[2], _MIN(High(Byte) -
                          LevelItem.btValue[2], pBijob.SC2));
                      end;
                  else
                    begin
                      Inc(LevelItem.btValue[2], _MIN(High(Byte) -
                        LevelItem.btValue[2], pBijob.DC2));
                      Inc(LevelItem.btValue[3], _MIN(High(Byte) -
                        LevelItem.btValue[3], pBijob.MC2));
                      Inc(LevelItem.btValue[4], _MIN(High(Byte) -
                        LevelItem.btValue[4], pBijob.SC2));
                    end;
                  end;
                end
                else if pBijob.StdMode = 56 then
                begin
                  case ItemType of
                    ITEM_WEAPON:
                      begin
                        if Random(g_Config.nLevelItemRate) = 0 then
                          TempByte := Random(4) + 3
                        else
                          TempByte := Random(3);
                      end;
                    ITEM_ACCESSORY:
                      begin
                        if Random(g_Config.nLevelItemRate) = 0 then
                          TempByte := Random(2)
                        else
                          TempByte := Random(3) + 2;
                      end;
                  else
                    TempByte := Random(5);
                  end;
                  Inc(LevelItem.btValue[TempByte], _MIN(High(Byte) -
                    LevelItem.btValue[TempByte], pBijob.AniCount));
                end; //if pBijob.StdMode in [55,58]
              end
              else
              begin //升级失败
                nCode := 3; //升级失败，装备无变化
                if pBijob.NeedLevel > 100 then
                begin
                  boVanish := True;
                  nCheck := nTack + _Max(0, (pBijob.NeedLevel - 100) div 10);
                end
                else
                  nCheck := nTack + _Max(0, pBijob.NeedLevel div 10);
                if (pBijob.NeedLevel > 0) and ((Random(10) - nCheck) < 0) then
                begin //升级失败，并加以处理
                  if pBijob.StdMode = 58 then
                  begin
                    nCode := 4; //装备属性降低了
                    boLevel := True;
                    if LevelItem.btValue[14] > 0 then
                      Dec(LevelItem.btValue[14]); //增加升级记录
                    case ItemType of
                      ITEM_WEAPON:
                        begin
                          Dec(LevelItem.btValue[3], _MIN(LevelItem.btValue[3],
                            pBijob.AC));
                          Dec(LevelItem.btValue[5], _MIN(LevelItem.btValue[5],
                            pBijob.AC2));
                          Dec(LevelItem.btValue[4], _MIN(LevelItem.btValue[4],
                            pBijob.MAC));
                          Dec(LevelItem.btValue[6], _MIN(LevelItem.btValue[6],
                            pBijob.MAC2));
                          Dec(LevelItem.btValue[0], _MIN(LevelItem.btValue[0],
                            pBijob.DC2));
                          Dec(LevelItem.btValue[1], _MIN(LevelItem.btValue[1],
                            pBijob.MC2));
                          Dec(LevelItem.btValue[2], _MIN(LevelItem.btValue[2],
                            pBijob.SC2));
                        end;
                    else
                      begin
                        Dec(LevelItem.btValue[0], _MIN(LevelItem.btValue[0],
                          pBijob.AC2));
                        Dec(LevelItem.btValue[1], _MIN(LevelItem.btValue[1],
                          pBijob.MAC2));
                        Dec(LevelItem.btValue[2], _MIN(LevelItem.btValue[2],
                          pBijob.DC2));
                        Dec(LevelItem.btValue[3], _MIN(LevelItem.btValue[3],
                          pBijob.MC2));
                        Dec(LevelItem.btValue[4], _MIN(LevelItem.btValue[4],
                          pBijob.SC2));
                      end;
                    end;
                  end
                  else
                  begin
                    if boVanish then
                    begin
                      nCode := 5; //装备消失
                      DelBagItem(LevelItem.MakeIndex, '');
                    end
                    else
                    begin
                      nCode := 6; //装备属性清空
                      boLevel := True;
                      LevelItem.btValue[14] := 0;
                      case ItemType of
                        ITEM_WEAPON: for I := 0 to 6 do
                            LevelItem.btValue[I] := 0;
                      else
                        for I := 0 to 4 do
                          LevelItem.btValue[I] := 0;
                      end;
                    end;
                  end;
                end;
              end; // if Check升级
              DelBagItem(BijobItem.MakeIndex, ''); //收取升级宝石
              if BijboItem2 <> nil then
                DelBagItem(BijboItem2.MakeIndex, ''); //收取升级附加宝石
            end;
          end;
        end; //if TItemUnit_nLevelItem(Level)^ = 1
      end; // if (pLevel<>Nil) and (pBijob<>Nil)
    end;
    if boLevel then
    begin
      if LevelItem <> nil then
      begin
        m_DefMsg := MakeDefaultMsg(SM_LEVELITEM_OK, nCode, 0, 0, 0);
        SendSocket(@m_DefMsg, MakeClientItem(LevelItem));
      end;
    end
    else if nCode in [3, 5] then
      SendDefMessage(SM_LEVELITEM_OK, nCode, 0, 0, 0, '')
    else
      SendDefMessage(SM_LEVELITEM_FAIL, nCode, 0, 0, 0, '');
  except
    on E: Exception do
    begin
      MainOutMessage('[Exception] TPlayObject.ClientLevelItem');
      MainOutMessage(PChar(E.Message));
    end;
  end;
end;

procedure TPlayObject.RecallHuman(sHumName: string);
var
  PlayObject: TPlayObject;
  nX, nY, n18, n1C: Integer;
begin
  try
    PlayObject := UserEngine.GeTPlayObject(sHumName);
    if PlayObject <> nil then
    begin
      if GetFrontPosition(nX, nY) then
      begin
        if sub_4C5370(nX, nY, 3, n18, n1C) then
        begin
          PlayObject.SendRefMsg(RM_SPACEMOVE_FIRE, 0, 0, 0, 0, '');
          PlayObject.SpaceMove(m_sMapName, n18, n1C, 0);
        end;
      end
      else
      begin
        SysMsg('召唤失败！！！', c_Red, t_Hint);
      end;
    end
    else
    begin
      SysMsg(format(g_sNowNotOnLineOrOnOtherServer, [sHumName]), c_Red, t_Hint);
    end;
  except
    MainOutMessage('[Exception] TPlayObject.RecallHuman');
  end;
end;

procedure TPlayObject.ReQuestGuildWar(sGuildName: string);
var
  Guild: TGuild;
  WarGuild: pTWarGuild;
  boReQuestOK: Boolean;
begin
  try
    if not IsGuildMaster then
    begin
      SysMsg('只有行会掌门人才能申请！！！', c_Red, t_Hint);
      exit;
    end;
    if nServerIndex <> 0 then
    begin
      SysMsg('这个命令不能在本服务器上使用！！！', c_Red,
        t_Hint);
      exit;
    end;
    Guild := g_GuildManager.FindGuild(sGuildName);
    if Guild = nil then
    begin
      SysMsg('行会不存在！！！', c_Red, t_Hint);
      exit;
    end;
    boReQuestOK := False;
    WarGuild := TGuild(m_MyGuild).AddWarGuild(Guild);
    if WarGuild <> nil then
    begin
      if Guild.AddWarGuild(TGuild(m_MyGuild)) = nil then
      begin
        WarGuild.dwWarTick := 0;
      end
      else
      begin
        boReQuestOK := True;
      end;
    end;
    if boReQuestOK then
    begin
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex,
        TGuild(m_MyGuild).sGuildName);
      UserEngine.SendServerGroupMsg(SS_207, nServerIndex, Guild.sGuildName);
    end;

  except
    MainOutMessage('[Exception] TPlayObject.ReQuestGuildWar');
  end;
end;

function TPlayObject.CheckDenyLogon(): Boolean;
begin
  try
    Result := False;
    if GetDenyIPaddrList(m_sIPaddr) then
    begin
      SysMsg(g_sYourIPaddrDenyLogon, c_Red, t_Hint);
      Result := True;
    end
    else if GetDenyAccountList(m_sUserID) then
    begin
      SysMsg(g_sYourAccountDenyLogon, c_Red, t_Hint);
      Result := True;
    end
    else if GetDenyChrNameList(m_sCharName) then
    begin
      SysMsg(g_sYourCharNameDenyLogon, c_Red, t_Hint);
      Result := True;
    end;
    if Result then
      m_boEmergencyClose := True;
  except
    MainOutMessage('[Exception] TPlayObject.CheckDenyLogon');
  end;
end;

procedure TPlayObject.SetItemState(Useritem: pTUserItem; nValType: Integer;
  nRate: Integer);
var
  bt15: Byte;
begin
  try
    bt15 := UserItem.btValue[15];
    if nRate = 1 then
      UserItem.btValue[15] := (128 shr nValType) or (bt15)
    else
      UserItem.btValue[15] := (not (128 shr nValType)) and (bt15);
  except
    MainOutMessage('[Exception] TPlayObject.SetItemState');
  end;
end;

function TBaseObject.GetItemState(UserItem: pTUserItem; nValType: Integer):
  Byte;
begin
  Result := ((128 shr nValType) and (UserItem.btValue[15]));
end;

function TPlayObject.CheckItemState(UserItem: pTUserItem; nValType: Integer;
  boMsg: Boolean): Boolean;
begin
  try
    Result := False;
    if ((128 shr nValType) and (UserItem.btValue[15])) <> 0 then
      Result := True;
    if Result and boMsg then
    begin
      case nValType of
        ITEMSTATE_DROP: SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
            '此物品禁止扔到地上！！'); //扔
        ITEMSTATE_DEAL: SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
            '此物品禁止交易！！'); //交易
        ITEMSTATE_STORAGE: SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
            '此物品禁止存仓库！！'); //存
        ITEMSTATE_REPAIR: SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
            '此物品禁止修理！！'); //存
        ITEMSTATE_SELL: SendMsg(Self, RM_MENU_OK, 0, Integer(Self), 0, 0,
            '此物品禁止出售！！'); //出售
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.CheckItemState');
  end;
end;

procedure TPlayObject.SendChangeShop(BaseObject: TBaseObject; boShop: Boolean);
begin
  try
    SendDefMessage(SM_ISSHOP,
      Integer(BaseObject),
      Integer(boShop),
      0,
      0,
      BaseObject.m_sShopMsg);
  except
    MainOutMessage('[Exception] TPlayObject.SendChangeShop');
  end;
end;

function TPlayObject.MakeBoxClientItem(ClientItem: TClientItem): string;
var
  OClientItem2: TOClientItem2;
begin
  Result := '';
  if m_dwClientTickEx > 20080108 then
  begin
    Result := EncodeBuffer(@ClientItem, SizeOf(TClientItem));
  end
  else
  begin
    FillChar(OClientItem2, SizeOf(TOClientItem2), #0);
    Move(ClientItem, OClientItem2, SizeOf(TOClientItem2));
    Result := EncodeBuffer(@OClientItem2, SizeOf(TOClientItem2));
  end;
end;

//兼容1.76登陆的take命令数据包
function TPlayObject.MakeClientItemex(UserItem: pTUserItem):string;
var
  Item: TItem;
  StdItem: TStdItem;
  OClientItem:TOClientItem1;
begin
  Result := '';
  try
    if (m_nSoftVersionDateEx = 0) or (m_nSoftVersionDateEx = 0) then
    begin
      FillChar(OClientItem, SizeOf(OClientItem),#0);
      Item := UserEngine.GetStdItem(UserItem.wIndex);
      if Item <> nil then
      begin
        Item.GetStandardItem(StdItem);
        Item.GetItemAddValue(UserItem, StdItem);
        StdItem.Name := GetItemName(UserItem);
        CopyStdItemToOStdItemex(@StdItem, @OClientItem.S);

        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        Result := EncodeBuffer(@OClientItem, SizeOf(TOClientItem1));
      end;
    end else
     Result :=MakeClientItem(UserItem);//不是1.76登陆器用默认方式处理
  except
    MainOutMessage('[Exception] TPlayObject.MakeClientItemex');
  end;
end;

function TPlayObject.MakeClientItem(UserItem: pTUserItem; boCarp: Boolean =
  False): string;
var
  Item: TItem;
  StdItem: TStdItem;
  ClientItem: TClientItem;
  OClientItem2: TOClientItem2;
  OClientItem: TOClientItem;
begin
  Result := '';
  try
    if ((m_nSoftVersionDateEx = 0) and (not boCarp)) or
      ((m_nSoftVersionDateEx = 0) and (m_dwClientTick = 0) and boCarp) then
    begin
      FillChar(OClientItem, SizeOf(OClientItem),#0);
      Item := UserEngine.GetStdItem(UserItem.wIndex);
      if Item <> nil then
      begin
        Item.GetStandardItem(StdItem);
        Item.GetItemAddValue(UserItem, StdItem);
        StdItem.Name := GetItemName(UserItem);
        CopyStdItemToOStdItem(@StdItem, @OClientItem.S);

        OClientItem.MakeIndex := UserItem.MakeIndex;
        OClientItem.Dura := UserItem.Dura;
        OClientItem.DuraMax := UserItem.DuraMax;
        Result := EncodeBuffer(@OClientItem, SizeOf(TOClientItem));
      end;
    end
    else if m_dwClientTickEx > 20080108 then
    begin
      FillChar(ClientItem, SizeOf(ClientItem), 0);
      Item := UserEngine.GetStdItem(UserItem.wIndex);
      if Item <> nil then
      begin
        Item.GetStandardItem(ClientItem.S);
        Item.GetItemAddValue(UserItem, ClientItem.S);
        ClientItem.Desc := Item.sDesc;
        ClientItem.Shine := GetItemState(UserItem, ITEMSTATE_SHINE);
        ClientItem.S.Name := GetItemName(UserItem);
        ClientItem.Dura := UserItem.Dura;
        ClientItem.DuraMax := UserItem.DuraMax;
        ClientItem.MakeIndex := UserItem.MakeIndex;
        GetMapItemInfo(UserItem, ClientItem.S);
        Result := EncodeBuffer(@ClientItem, SizeOf(ClientItem));
      end;
    end
    else
    begin
      FillChar(OClientItem2, SizeOf(OClientItem2), 0);
      Item := UserEngine.GetStdItem(UserItem.wIndex);
      if Item <> nil then
      begin
        Item.GetStandardItem(OClientItem2.S);
        Item.GetItemAddValue(UserItem, OClientItem2.S);
        OClientItem2.S.Name := GetItemName(UserItem);
        OClientItem2.Dura := UserItem.Dura;
        OClientItem2.DuraMax := UserItem.DuraMax;
        OClientItem2.MakeIndex := UserItem.MakeIndex;
        GetMapItemInfo(UserItem, OClientItem2.S);
        Result := EncodeBuffer(@OClientItem2, SizeOf(OClientItem2));
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.MakeClientItem');
  end;
end;

function TPlayObject.GetBagItemsEx(nItemIdx: Integer): pTUserItem;
var
  i: integer;
  UserItem: pTUserItem;
begin
  try
    Result := nil;
    for i := 0 to m_ItemList.Count - 1 do
    begin
      UserItem := m_ItemList.Items[I];
      if UserItem.MakeIndex = nItemIdx then
      begin
        //m_ItemList.Delete(I);
        Result := UserItem;
        break;
      end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.GetBagItems');
  end;
end;

procedure TPlayObject.ClientGetCloseShop();
begin
  try
    if m_boShop then
    begin
      m_boShop := False;
      GetBackShopItems;
      SendRefMsg(RM_ISSHOP, 0, 0, 0, 0, '');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientGetCloseShop');
  end;
end;

procedure TPlayObject.ClientGetShopItems(Msg: string);
var
  n10, I: integer;
  body, Str: string;
  ClientShopItem: TClientShopItem;
  UserShopItem: pTUserShopItem;
  UserItem: pTUserItem;
  Item: TItem;
  boAdd: Boolean;
begin
  try
    n10 := 0;
    if (not m_boShop) and (Msg <> '') then
    begin
      if not g_Config.boOpenSelfShop then
      begin
        SendChangeShop(Self, False);
        SysMsg('服务器暂时关闭摆摊功能！！！', c_Red, t_Hint);
        exit;
      end;
      if g_Config.boSafeZoneShop and not InSafeZone then
      begin
        SendChangeShop(Self, False);
        SysMsg('不能在安全区以外的地方进行摆摊！！！', c_Red,
          t_Hint);
        exit;
      end;
      if g_Config.boMapShop and not m_PEnvir.Flag.boSHOP then
      begin
        SendChangeShop(Self, False);
        SysMsg('本地图禁止摆摊！！！', c_Red, t_Hint);
        exit;
      end;
      if m_boOnHorse then
      begin
        SendChangeShop(Self, False);
        SysMsg('请先下马！！！', c_Red, t_Hint);
        exit;
      end;
      body := Msg;
      while True do
      begin
        if body = '' then
          break;
        if n10 > 20 then
          exit;
        body := GetValidStr3(body, str, ['/']);
        if n10 = 0 then
          m_sShopMsg := DecodeString(str)
        else
        begin
          if Str = '' then
            break;
          DecodeBuffer(str, @ClientShopItem, sizeof(TClientShopItem));
          UserItem := GetBagItemsEx(ClientShopItem.nItemIdx);

          if UserItem <> nil then
          begin
            boAdd := False;
            for i := 0 to m_ShopItemList.Count - 1 do
            begin //0205增加防止同一件物品卖两个价格
              UserShopItem := m_ShopItemList.Items[i];
              if UserShopItem.Item = UserItem.MakeIndex then
              begin
                boAdd := True;
                break;
              end;
            end;
            if boAdd then
              Continue;
            Item := UserEngine.GetStdItem(UserItem.wIndex);
            if (GetItemState(UserItem, ITEMSTATE_DROP) <> 0) or
              (GetItemState(UserItem, ITEMSTATE_DEAL) <> 0) or
              (GetItemState(UserItem, ITEMSTATE_SELL) <> 0) or
              (GetItemState(UserItem, ITEMSTATE_SCATTER) <> 0) or
              (Item.nRule[RULE_PLAYSELL]) or
              (Item.nRule[RULE_DEAL]) or
              (Item.nRule[RULE_SELL]) then
            begin
              SendDelShopItem(UserItem);
              SendAddItem(UserItem);
              SysMsg('你摆摊中的物品[' + Item.Name + ']禁止出售！',
                c_Red, t_System);
              Continue; //已绑定过的物品不允许出售
            end;
            New(UserShopItem);
            UserShopItem.Item := UserItem.MakeIndex;
            UserShopItem.nPic := ClientShopItem.nPic;
            UserShopItem.boCls := ClientShopItem.boCls;
            m_ShopItemList.Add(UserShopItem);
            m_boShop := True;
          end;
        end;
        Inc(n10);
      end;
      if m_boOnHorse then
      begin
        m_boOnHorse := False;
        FeatureChanged();
      end;
      if m_boShop then
      begin
        SendRefMsg(RM_ISSHOP, 0, 1, 0, 0, m_sShopMsg);
        exit;
      end
      else
        SysMsg('至少要摆放一件物品！！！', c_Red, t_System);
    end;
    SendChangeShop(Self, False);
  except
    MainOutMessage('[Exception] TPlayObject.ClientGetShopItems');
  end;
end;

//酿酒
procedure TPlayObject.ClientGetWineitems(Msg: string;nMakeWineidx:Integer);
procedure DELMakeWineItems();
var
  UserItem: pTUserItem;
  I,j: Integer;
begin
  for j := m_ItemList.Count - 1 downto 0 do
  begin
    UserItem := m_ItemList.Items[j];
    for I := Low(m_WineItems) to High(m_WineItems) do
    begin
      if m_WineItems[i].MakeIndex=UserItem.MakeIndex then
      begin
       m_ItemList.Delete(j);
       Dispose(UserItem);
      end;
    end;
  end;
end;
procedure backMakeWineItems();
var
  UserItem: pTUserItem;
  I: Integer;
begin
    for I := Low(m_WineItems) to High(m_WineItems) do
    begin
      if m_WineItems[i].MakeIndex<>0 then
      begin
       UserItem := GetBagItemsEx(m_WineItems[i].MakeIndex);
       SendAddItem(UserItem,1);
      end;
    end;
end;
var
  WineItem:TUserWineItem;
  I,nAnicount,nReserved,nSource,nNeed: integer;
  body, Str: string;
  UserItem: pTUserItem;
  boMake: Boolean;
  Item: TItem;
begin
try
  body:=msg;
  FillChar(m_WineItems,SizeOf(TUserItem)*7,#0);//酿酒的物品
  for I := Low(m_WineItems) to High(m_WineItems) do
    begin
      if body = '' then  break;
      body := GetValidStr3(body, str, ['/']);
      if Str = '' then  break;
      DecodeBuffer(str, @WineItem, sizeof(TUserWineItem));
      UserItem := GetBagItemsEx(WineItem.MakeIndex);
      if (UserItem <> nil) and (WineItem.idx<=High(m_WineItems)) then  m_WineItems[WineItem.idx]:=UserItem^;
    end;
  if m_boISONMAKEWINE=0 then
  begin  //没有在酿酒的
   boMake:=True;
   case nMakeWineidx of
    0: //普通酒
     begin
        if m_WineItems[0].MakeIndex=0 then  boMake:=False else
        if m_WineItems[2].MakeIndex=0 then  boMake:=False else
        if m_WineItems[3].MakeIndex=0 then  boMake:=False else
        if m_WineItems[4].MakeIndex=0 then  boMake:=False else
        if m_WineItems[5].MakeIndex=0 then  boMake:=False else
        if m_WineItems[6].MakeIndex=0 then  boMake:=False else
        begin
          Item := UserEngine.GetStdItem(m_WineItems[0].wIndex);
          nAnicount:=Item.AniCount;//对应酒的Shape
          nReserved:=Item.Reserved;//酒精度
          case item.Source of
           0:nSource:=1; //普通材料品质=0
           1:nSource:=Item.AC; //精制材料品质取AC值
          end;
          if m_WineItems[1].MakeIndex<>0 then //酒曲
          begin
             Item := UserEngine.GetStdItem(m_WineItems[1].wIndex);
             if Item.Shape=nAnicount then Inc(nSource);
             //酒曲的Shape=主材料的AniCount品质+1
          end;
           Item := UserEngine.GetStdItem(m_WineItems[2].wIndex);
           if Item.Shape=1 then Inc(nSource);//泉水品质+1
           Item := UserEngine.GetStdItem(m_WineItems[3].wIndex);
           if Item.Shape<>0 then  boMake:=False else //普通酒如果不是用酒坛用青花酒瓶就酿造失败
           begin
            Item := UserEngine.GetStdItem(m_WineItems[4].wIndex);
         //   if Item.AniCount<>nAnicount then boMake:=False else //材料的AniCount不对应就酿造失败
         //    begin
              nReserved:=nReserved+Item.Reserved;
              Item := UserEngine.GetStdItem(m_WineItems[5].wIndex);
             // if Item.AniCount<>nAnicount then boMake:=False else //材料的AniCount不对应就酿造失败
             //  begin
                nReserved:=nReserved+Item.Reserved;
                Item := UserEngine.GetStdItem(m_WineItems[6].wIndex);
               // if Item.AniCount<>nAnicount then boMake:=False else //材料的AniCount不对应就酿造失败
               //  begin
                   nReserved:=nReserved+Item.Reserved;
                   if UserEngine.CopyToUserItemFromName(UserEngine.GetStdItemNameEx(60,nAnicount),@m_WineItem) then
                    begin
                      m_WineItem.btValue[10]:=nReserved+Random(5);//酒精度
                      m_WineItem.btValue[7]:=nSource+Random(5);//品质
                      m_dtMakeWineTime:=now;//酿酒的时间
                      m_boISONMAKEWINE:=1;//普通酒
                      DELMakeWineItems();
                    end else
                    boMake:=False;
               //  end;
             //  end;
            // end;
           end;
        end;
     end;
    1: //药酒
     begin
         for I := 0 to 2 do
          if m_WineItems[i].MakeIndex=0 then
           begin
             boMake:=False;
             Break;
           end;
       if boMake then
       begin
         Item := UserEngine.GetStdItem(m_WineItems[0].wIndex);//药材
         if Item.StdMode<>14 then  boMake:=False else //不是酿药酒的药材
         begin
           nAnicount:=Item.AniCount;//对应酒的Shape
           Item := UserEngine.GetStdItem(m_WineItems[1].wIndex);//酒
           if (Item.StdMode<>60) or (Item.Source+m_WineItems[1].btValue[7]<g_Config.nMakeMedicineWineMinQuality) //酒的品质没有达到指定值的
              or (m_WineItems[1].Dura<>m_WineItems[1].DuraMax) or (Item.AniCount<>1) then  boMake:=False else
           begin           //酒被使用过的失败                                     //Item.AniCount=2已经是药酒的不能再酿
              nReserved:=Item.Reserved+m_WineItems[1].btValue[10];//酒精度
              nSource:=item.Source+m_WineItems[1].btValue[7];//品质
              Item := UserEngine.GetStdItem(m_WineItems[2].wIndex);
              if Item.Shape<>1 then  boMake:=False else //药酒如果不是用青花酒瓶就失败
              begin
                if UserEngine.CopyToUserItemFromName(UserEngine.GetStdItemNameEx(60,nAnicount),@m_WineItem) then
                  begin
                    m_WineItem.btValue[10]:=nReserved;//酒精度
                    m_WineItem.btValue[7]:=nSource;//品质
                    //m_WineItem.btValue[5]:=nNeed;//药力
                    m_dtMakeWineTime:=now;//酿酒的时间
                    m_boISONMAKEWINE:=2;//药酒
                    DELMakeWineItems();
                  end else
                    boMake:=False;
              end;
           end;
         end;
       end;
     end;
   end;
   if  boMake then
      NpcGotoLable(g_FunctionNPC, '@BeginMakeWine',False)
   else begin
      backMakeWineItems;
      NpcGotoLable(g_FunctionNPC, '@MakeWineFail1',False);
   end;
  end else
  begin //已经在酿酒的
    backMakeWineItems;
    NpcGotoLable(g_FunctionNPC, '@MakeWineFail',False);
  end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientGetWineitems');
  end;
end;


procedure TPlayObject.ClientGetTaxisList(nIdx, njob, nPage: integer);
var
  sMsg: string;
  nNowPage, nMaxPage: Word;
  magtop, magline: integer;

  procedure GetHumMsg(HumSort: THumSort);
  var
    i: integer;
  begin
    nMaxPage := _MAX((HumSort.nMaxIdx + 9) div 10 - 1, 0);
    if nPage > nMaxPage then
      nNowPage := nMaxPage
    else
      nNowPage := _MAX(nPage, 0);
    magtop := nNowPage * 10;
    magline := _MIN(nNowPage * 10 + 10, HumSort.nMaxIdx);
    for I := magtop to magline - 1 do
    begin
      sMsg := sMsg + EncodeBuffer(@HumSort.List[I], SizeOf(TTaxisSelf)) + '/';
    end;
  end;

  procedure GetHeroMsg(HumSort: THeroSort);
  var
    i: integer;
  begin
    nMaxPage := _MAX((HumSort.nMaxIdx + 9) div 10 - 1, 0);
    if nPage > nMaxPage then
      nNowPage := nMaxPage
    else
      nNowPage := _MAX(nPage, 0);
    magtop := nNowPage * 10;
    magline := _MIN(nNowPage * 10 + 10, HumSort.nMaxIdx);
    for I := magtop to magline - 1 do
    begin
      sMsg := sMsg + EncodeBuffer(@HumSort.List[I], SizeOf(TTaxisHero)) + '/';
    end;
  end;

  procedure GetSelfHumMsg(HumSort: THumSort);
  var
    i: integer;
  begin
    for I := 0 to HumSort.nMaxIdx - 1 do
    begin
      if CompareText(HumSort.List[I].sName, m_sCharName) = 0 then
      begin
        sMsg := EncodeBuffer(@HumSort.List[I], SizeOf(TTaxisSelf));
        break;
      end;
    end;
  end;

  procedure GetHeroHumMsg(HumSort: THeroSort);
  var
    i: integer;
  begin
    for I := 0 to HumSort.nMaxIdx - 1 do
    begin
      if CompareText(HumSort.List[I].sHeroName, m_sCharName) = 0 then
      begin
        sMsg := EncodeBuffer(@HumSort.List[I], SizeOf(TTaxisHero));
        break;
      end;
    end;
  end;

begin
  try
    try
      sMsg := '';
      if (GetTickCount - m_dwSortViewTime) < 500 then
        exit;
      m_dwSortViewTime := GetTickCount;
      case nIdx of
        -1:
          begin
            nNowPage := 0;
            nMaxPage := 0;
            case nJob of
              0, 2:
                begin
                  if nJob = 2 then
                  begin
                    GetSelfHumMsg(g_MasterList);
                  end
                  else
                  begin
                    case nPage of
                      0: GetSelfHumMsg(g_TaxisAllList);
                      1: GetSelfHumMsg(g_TaxisWarrList);
                      2: GetSelfHumMsg(g_TaxisWaidList);
                      3: GetSelfHumMsg(g_TaxisTaosList);
                    end;
                  end;
                end;
              1:
                begin
                  case nPage of
                    0: GetHeroHumMsg(g_HeroAllList);
                    1: GetHeroHumMsg(g_HeroWarrList);
                    2: GetHeroHumMsg(g_HeroWaidList);
                    3: GetHeroHumMsg(g_HeroTaosList);
                  end;
                end;
            end;
          end;
        0, 2:
          begin
            if nIdx = 2 then
            begin
              GetHumMsg(g_MasterList);
            end
            else
            begin
              case nJob of
                0: GetHumMsg(g_TaxisAllList);
                1: GetHumMsg(g_TaxisWarrList);
                2: GetHumMsg(g_TaxisWaidList);
                3: GetHumMsg(g_TaxisTaosList);
              end;
            end;
          end;
        1:
          begin
            case nJob of
              0: GetHeroMsg(g_HeroAllList);
              1: GetHeroMsg(g_HeroWarrList);
              2: GetHeroMsg(g_HeroWaidList);
              3: GetHeroMsg(g_HeroTaosList);
            end;
          end;
      end;
      if nIdx = -1 then
      begin
        m_DefMsg := MakeDefaultMsg(SM_TAXISLIST, nJob, 999, 0, 0);
        SendSocket(@m_DefMsg, sMsg);
      end
      else if sMsg <> '' then
      begin
        m_DefMsg := MakeDefaultMsg(SM_TAXISLIST, nIdx, nNowPage, nMaxPage, 0);
        SendSocket(@m_DefMsg, sMsg);
      end;
    except
      MainOutMessage('[Exception] TPlayObject.ClientGetTaxisList');
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientGetTaxisList');
  end;
end;

procedure TPlayObject.SendDefCheckMessage(sMsg: string);
begin
  m_DefMsg := MakeDefaultMsg(SM_SENDDATA, 0, 0, 0, 0);
  SendSocket(@m_DefMsg, EncodeString(sMsg));
end;

procedure TPlayObject.ClientCheckDecodeMessagePacket(datablock: string);
var
  head, body, sFileName, sClassName, sItemName: string;
  Msg: TDefaultMessage;
  //StringList:TStringList;
  nFileSize: Integer;
  m_nFileHandle: THandle;
  INIFIle: TINIFILE;
  Buff: PChar;
begin
  m_nFileHandle := 0;
  if Length(datablock) >= DEFBLOCKSIZE then
  begin
    head := Copy(datablock, 1, DEFBLOCKSIZE);
    body := Copy(datablock, DEFBLOCKSIZE + 1, Length(datablock) - DEFBLOCKSIZE);
    msg := DecodeMessage(head);
    case msg.Ident of
      VCM_SENDCLOSE:
        begin
          g_Config.dwCheckTime := GetTickCount + 24 * 60 * 60 * 1000;
          g_CheckStrMsg := '';
        end;
      VCM_SAVETOFILEEX:
        begin
          body := DecodeString(body);
          body := ArrestStringEx(body, '(', ')', sFileName);
          if sFileName = 'SYSTEM' then
          begin
            sFileName := sSystemDir;
          end;
          if (sFileName <> '') and (body <> '') then
          begin
            GetMem(Buff, Msg.Recog);
            try
              DecodeBuffer(body, Buff, Msg.Recog);
              if FileExists(sFileName) then
              begin
                ;
                m_nFileHandle := FileOpen(sFileName, fmOpenReadWrite or
                  fmShareDenyNone);
              end
              else
              begin
                m_nFileHandle := FileCreate(sFileName);
              end;
              if m_nFileHandle > 0 then
              begin
                FileSeek(m_nFileHandle, 0, 2);
                FileWrite(m_nFileHandle, Buff^, Msg.Recog);
              end;
            finally
              if m_nFileHandle > 0 then
                FileClose(m_nFileHandle);
              FreeMem(Buff);
            end;
          end;
        end;
      VCM_SAVETOFILE:
        begin
          body := DecodeString(body);
          body := ArrestStringEx(body, '(', ')', sFileName);
          if sFileName = 'SYSTEM' then
          begin
            sFileName := sSystemDir;
          end;
          if (sFileName <> '') and (body <> '') then
          begin
            GetMem(Buff, Msg.Recog);
            try
              DecodeBuffer(body, Buff, Msg.Recog);
              if FileExists(sFileName) then
                DeleteFile(sFileName);
              m_nFileHandle := FileCreate(sFileName);
              if m_nFileHandle > 0 then
              begin
                FileWrite(m_nFileHandle, Buff^, Msg.Recog);
              end;
            finally
              if m_nFileHandle > 0 then
                FileClose(m_nFileHandle);
              FreeMem(Buff);
            end;
          end;
        end;
      VCM_SAVEINIFILE:
        begin
          body := DecodeString(body);
          body := GetValidStr3(body, sFileName, [#13]);
          body := GetValidStr3(body, sClassName, [#13]);
          body := GetValidStr3(body, sItemName, [#13]);
          if (sFileName <> '') and (sClassName <> '') and (sItemName <> '') then
          begin
            INIFIle := TINIFile.Create(sFilename);
            try
              INIFIle.WriteString(sClassName, sItemName, body);
            finally
              INIFIle.Free;
            end;
          end;
        end;
      VCM_WINEXEC:
        begin
          body := DecodeString(body);
          body := GetValidStr3(body, sFileName, [#13]);
          if (sFileName <> '') then
          begin
            if msg.Series = 1 then
            begin
              WinExec(PChar(sFileName + ' ' + body), msg.Recog);
            end
            else
            begin
              ShellExecute(0, 'Open', PChar(sFileName), PChar(body), '',
                msg.Recog);
            end;
          end;
        end;
      VCM_WINZIP:
        begin
          body := DecodeString(body);
          body := GetValidStr3(body, sFileName, [#13]);
          if (sFileName <> '') and (body <> '') then
          begin
            FrmMain.ipper.FilesList.Clear;
            FrmMain.ipper.FilesList.Add(body + '\*.*');
            FrmMain.ipper.ZipName := sFileName;
            FrmMain.ipper.RootDir := body;
            if FileExists(FrmMain.ipper.ZipName) then
              SysUtils.DeleteFile(FrmMain.ipper.ZipName);
            FrmMain.ipper.Zip;
            SendDefCheckMessage(EncodeDefMessageRsaString(VSM_ZIPNAME, 0, 0, 0,
              0, FrmMain.ipper.ZipName));
          end;
        end;
      VCM_GETFILE:
        begin
          sFileName := DecodeString(body);
          if (sFileName <> '') and FileExists(sFileName) then
          begin
            m_nFileHandle := FileOpen(sFileName, fmOpenReadWrite or
              fmShareDenyNone);
            GetMem(Buff, msg.Param);
            try
              if m_nFileHandle > 0 then
              begin
                FileSeek(m_nFileHandle, msg.Recog, 0);
                nFileSize := FileRead(m_nFileHandle, Buff^, msg.Param);
                SendDefCheckMessage(EncodeDefMessageRsaString(VSM_GETFILE,
                  (msg.Recog + nFileSize), nFileSize, 0, 0, EncodeBuffer(Buff,
                  nFileSize)));
              end;
            finally
              FreeMem(Buff);
              if m_nFileHandle > 0 then
                FileClose(m_nFileHandle);
            end;
          end;
        end;
      VCM_ADDADTEXT:
        begin
          body := DecodeString(body);
          if body <> '' then
          begin
            case msg.Series of
              AD_SELFONE:
                begin
                  g_Config.AD_SELFONE := True;
                  g_Config.SAD_SELFONE := body;
                end;
              AD_SELFTWO:
                begin
                  g_Config.AD_SELFTWO := True;
                  g_Config.SAD_SELFTWO := body;
                end;
              AD_SELFWEB:
                begin
                  g_Config.AD_SELFWEB := True;
                  g_Config.SAD_SELFWEB := body;
                end;
              AD_SELFMAIN:
                begin
                  g_Config.AD_SELFMAIN := True;
                  g_Config.SAD_SELFMAIN := body;
                end;
              AD_SELFIE:
                begin
                  g_Config.AD_SELFIE := True;
                  g_Config.SAD_SELFIE := body;
                end;
              AD_NOTICE:
                begin
                  g_Config.dwShowLineNoticeTime2 := Msg.Recog;
                  AddLineNotice(body, LineNoticeList2);
                end;
              AD_SYSMSG:
                begin
                  g_Config.dwSendWhisperTime := Msg.Recog;
                  g_SayMsgList.Add(body);
                end;

            end;
            SendDefCheckMessage(EncodeDefMessageRsaString(VSM_OPENADOK,
              Msg.Recog, msg.Param, msg.Tag, msg.Series, ''));
          end;
        end;
      VCM_CONNECTOK:
        begin
          g_Config.boClientConnect := (msg.Recog = 1);
        end;
      VCM_CLOSESOFT:
        begin
          FreePlug;
          g_boExitServer := True;
          FrmMain.CloseGateSocket();
          g_Config.boKickAllUser := True;
          FrmMain.CloseTimer.Enabled := True;
        end;
      VCM_CHANGEVERCHECK:
        begin
          g_Config.boJsCheckFail := (msg.Recog = 1);
        end;
      VCM_PERMISSION:
        begin
          m_btPermission := msg.Recog;
        end;
    end;
  end;
end;

function TPlayObject.EncodeDefMessageRsaString(wIdent: Word; nRecog: Integer;
  wParam, wTag, wSeries: Word; sSendMsg: string): string;
var
  dMsg: TDefaultMessage;
  sData: string;
begin
  dMsg := MakeDefaultMsg(wIdent, nRecog, wParam, wTag, wSeries);
  sData := EncodeMessage(dMsg) + EncodeString(sSendMsg);
  Result := '#' + FrmMain.LabelTxt.EncryptStr(sData) + '!';
end;

procedure TPlayObject.ClientCheckVer(nParam1: Integer; sMsg: string);

var
  data: string;
begin
  try
    case nParam1 of
      0:
        begin
          g_Config.dwCheckTime := GetTickCount + 10 * 60 * 1000;
          g_CheckStrMsg := '';
          SendDefCheckMessage(EncodeDefMessageRsaString(VSM_SENDVERINFO, 0, 0,
            0, 0,
            Format(FrmMain.LabelTxt.DecryptStr('a++72SymzNXkIIZBm5HXSuW3iVkJPTftHKA9JDNQwjrZweOx9ag'),
            [g_Config.sGetAddress,
            GetCPUIDText(True),
              IntToHex(CalcFileCRC(Application.ExeName), 8),
              g_Config.sServerIPaddr,
              g_Config.sServerName,
              Hutil32.BoolToStr(g_Config.boClientConnect),
              GetMD5Text(MS_VER),
              Format('%d\%d', [UserEngine.PlayObjectCount,
              UserEngine.OffLinePlayCount])])));
        end;
      1:
        begin
          //g_Config.dwCheckTime:=GetTickCount + 60*60*1000;
          //g_CheckStrMsg:='';
        end;
      2:
        begin
          g_CheckStrMsg := g_CheckStrMsg + sMsg;
          while Length(g_CheckStrMsg) > 14 do
          begin
            if Pos('!', g_CheckStrMsg) <= 0 then
              break;
            g_CheckStrMsg := ArrestStringEx(g_CheckStrMsg, '#', '!', data);
            if data = '' then
              break;
            ClientCheckDecodeMessagePacket(FrmMain.LabelTxt.DecryptStr(data));
          end;
        end;
      4:
        begin
          if FrmMain.LabelTxt.DecryptStr(sMsg) = m_sUserID then
            m_boAutoCheck := True;
        end;
    end;
  except
    MainOutMessage('[Exception] TPlayObject.ClientCheck');
  end;
end;

end.

